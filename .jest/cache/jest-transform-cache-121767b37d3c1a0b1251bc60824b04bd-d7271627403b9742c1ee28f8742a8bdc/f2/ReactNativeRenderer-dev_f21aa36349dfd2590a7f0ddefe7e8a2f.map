{"version":3,"sources":["ReactNativeRenderer-dev.js"],"names":["__DEV__","require","invariant","warning","emptyFunction","UIManager","RCTEventEmitter","TextInputState","deepDiffer","flattenStyle","React","emptyObject","checkPropTypes","shallowEqual","ExceptionsManager","deepFreezeAndThrowOnMutationInDev","invokeGuardedCallback","name","func","context","a","b","c","d","e","f","_hasCaughtError","_caughtError","funcArgs","Array","prototype","slice","call","arguments","apply","error","window","dispatchEvent","document","createEvent","fakeNode","createElement","invokeGuardedCallbackDev","evt","didError","callCallback","removeEventListener","evtType","didSetError","isCrossOriginError","onError","event","colno","lineno","addEventListener","initEvent","Error","invokeGuardedCallback$1","ReactErrorUtils","_rethrowError","_hasRethrowError","invokeGuardedCallbackAndCatchFirstError","hasCaughtError","clearCaughtError","rethrowCaughtError","eventPluginOrder","namesToPlugins","recomputePluginOrdering","pluginName","pluginModule","pluginIndex","indexOf","plugins","extractEvents","publishedEvents","eventTypes","eventName","publishEventForPlugin","dispatchConfig","eventNameDispatchConfigs","hasOwnProperty","phasedRegistrationNames","phaseName","phasedRegistrationName","publishRegistrationName","registrationName","registrationNameModules","registrationNameDependencies","dependencies","lowerCasedName","toLowerCase","injectEventPluginOrder","injectedEventPluginOrder","injectEventPluginsByName","injectedNamesToPlugins","isOrderingDirty","getFiberCurrentPropsFromNode","getInstanceFromNode","getNodeFromInstance","injection$1","injectComponentTree","Injected","isEndish","topLevelType","isMoveish","isStartish","validateEventDispatches","dispatchListeners","_dispatchListeners","dispatchInstances","_dispatchInstances","listenersIsArr","isArray","listenersLen","length","instancesIsArr","instancesLen","executeDispatch","simulated","listener","inst","type","currentTarget","undefined","executeDispatchesInOrder","i","isPropagationStopped","executeDispatchesInOrderStopAtTrueImpl","executeDispatchesInOrderStopAtTrue","ret","executeDirectDispatch","dispatchListener","dispatchInstance","res","hasDispatches","accumulateInto","current","next","push","concat","forEachAccumulated","arr","cb","scope","forEach","eventQueue","executeDispatchesAndRelease","isPersistent","constructor","release","executeDispatchesAndReleaseSimulated","executeDispatchesAndReleaseTopLevel","isInteractive","tag","shouldPreventMouseEvent","props","disabled","injection","getListener","stateNode","targetInst","nativeEvent","nativeEventTarget","events","possiblePlugin","extractedEvents","runEventsInBatch","processingEventQueue","runExtractedEventsInBatch","IndeterminateComponent","FunctionalComponent","ClassComponent","HostRoot","HostPortal","HostComponent","HostText","CallComponent","CallHandlerPhase","ReturnComponent","Fragment","Mode","ContextConsumer","ContextProvider","getParent","getLowestCommonAncestor","instA","instB","depthA","tempA","depthB","tempB","depth","alternate","isAncestor","getParentInstance","traverseTwoPhase","fn","arg","path","listenerAtPhase","propagationPhase","accumulateDirectionalDispatches","phase","accumulateTwoPhaseDispatchesSingle","_targetInst","accumulateTwoPhaseDispatchesSingleSkipTarget","parentInst","accumulateDispatches","ignoredDirection","accumulateDirectDispatchesSingle","accumulateTwoPhaseDispatches","accumulateTwoPhaseDispatchesSkipTarget","accumulateDirectDispatches","didWarnForAddedNewProperty","EVENT_POOL_SIZE","shouldBeReleasedProperties","EventInterface","target","thatReturnsNull","eventPhase","bubbles","cancelable","timeStamp","Date","now","defaultPrevented","isTrusted","SyntheticEvent","preventDefault","stopPropagation","Interface","propName","normalize","returnValue","isDefaultPrevented","thatReturnsTrue","thatReturnsFalse","cancelBubble","persist","destructor","Object","defineProperty","getPooledWarningPropertyDefinition","extend","Super","E","Class","addEventPoolingTo","isProxySupported","Proxy","isSealed","construct","args","create","that","set","prop","value","getVal","isFunction","configurable","get","val","action","warn","result","warningCondition","getPooledEvent","nativeInst","EventConstructor","eventPool","instance","pop","releasePooledEvent","getPooled","SyntheticEvent$1","ResponderSyntheticEvent","touchHistory","MAX_TOUCH_BANK","touchBank","numberActiveTouches","indexOfSingleActiveTouch","mostRecentTimeStamp","timestampForTouch","touch","timestamp","createTouchRecord","touchActive","startPageX","pageX","startPageY","pageY","startTimeStamp","currentPageX","currentPageY","currentTimeStamp","previousPageX","previousPageY","previousTimeStamp","resetTouchRecord","touchRecord","getTouchIdentifier","_ref","identifier","recordTouchStart","recordTouchMove","console","printTouch","printTouchBank","recordTouchEnd","JSON","stringify","printed","ResponderTouchHistoryStore","recordTouchTrack","changedTouches","touches","touchTrackToCheck","activeRecord","accumulate","responderInst","trackedTouchCount","previousActiveTouches","changeResponder","nextResponderInst","blockHostResponder","oldResponderInst","ResponderEventPlugin","GlobalResponderHandler","onChange","startShouldSetResponder","bubbled","captured","scrollShouldSetResponder","selectionChangeShouldSetResponder","moveShouldSetResponder","responderStart","responderMove","responderEnd","responderRelease","responderTerminationRequest","responderGrant","responderReject","responderTerminate","setResponderAndExtractTransfer","shouldSetEventType","bubbleShouldSetFrom","skipOverBubbleShouldSetFrom","shouldSetEvent","wantsResponderInst","extracted","grantEvent","terminationRequestEvent","shouldSwitch","terminateEvent","rejectEvent","canTriggerTransfer","topLevelInst","responderIgnoreScroll","noResponderTouches","activeTouch","_getResponder","isResponderTouchStart","isResponderTouchMove","isResponderTouchEnd","incrementalTouch","gesture","isResponderTerminate","isResponderRelease","finalTouch","finalEvent","GlobalInteractionHandler","injectGlobalResponderHandler","injectGlobalInteractionHandler","customBubblingEventTypes","customDirectEventTypes","ReactNativeBridgeEventPlugin","bubbleDispatchConfig","directDispatchConfig","processEventTypes","viewConfig","bubblingEventTypes","directEventTypes","_topLevelType","_topLevelType2","instanceCache","instanceProps","precacheFiberNode","hostInst","uncacheFiberNode","getInstanceFromTag","getTagFromInstance","_nativeTag","canonical","getFiberCurrentPropsFromNode$1","updateFiberProps","ReactNativeComponentTree","freeze","getClosestInstanceFromNode","ReactNativeEventPluginOrder","ReactNativeGlobalResponderHandler","from","to","blockNativeResponder","setJSResponder","clearJSResponder","fiberHostComponent","restoreTarget","restoreQueue","restoreStateOfTarget","internalInstance","restoreControlledState","needsStateRestore","restoreStateIfNeeded","queuedTargets","_batchedUpdates","bookkeeping","_interactiveUpdates","_flushInteractiveUpdates","isBatching","batchedUpdates","controlledComponentsHavePendingUpdates","injection$2","injectRenderer","renderer","interactiveUpdates","flushInteractiveUpdates","INITIAL_TAG_COUNT","ReactNativeTagHandles","tagsStartAt","tagCount","allocateTag","reactTagIsNativeTopRootID","assertRootTag","reactTag","EMPTY_NATIVE_EVENT","touchSubsequence","indices","removeTouchesAtIndices","rippedOut","temp","index","fillAt","j","cur","_receiveRootNodeIDEvent","rootNodeID","nativeEventParam","receiveEvent","receiveTouches","eventTopLevelType","changedIndices","jj","ReactNativeEventEmitter","registrationNames","register","hasSymbol","Symbol","REACT_ELEMENT_TYPE","REACT_CALL_TYPE","REACT_RETURN_TYPE","REACT_PORTAL_TYPE","REACT_FRAGMENT_TYPE","REACT_STRICT_MODE_TYPE","REACT_PROVIDER_TYPE","REACT_CONTEXT_TYPE","REACT_ASYNC_MODE_TYPE","MAYBE_ITERATOR_SYMBOL","iterator","FAUX_ITERATOR_SYMBOL","getIteratorFn","maybeIterable","maybeIterator","createPortal","children","containerInfo","implementation","key","$$typeof","TouchHistoryMath","centroidDimension","touchesChangedAfter","isXAxis","ofCurrent","total","count","oneTouchData","touchTrack","toAdd","noCentroid","currentCentroidXOfTouchesChangedAfter","currentCentroidYOfTouchesChangedAfter","previousCentroidXOfTouchesChangedAfter","previousCentroidYOfTouchesChangedAfter","currentCentroidX","currentCentroidY","ReactVersion","_classCallCheck","Constructor","TypeError","objects","uniqueID","emptyObject$2","ReactNativePropRegistry","object","id","getByID","emptyObject$1","removedKeys","removedKeyCount","defaultDiffer","prevProp","nextProp","resolveObject","idOrObject","restoreDeletedValuesInNestedArray","updatePayload","node","validAttributes","obj","propKey","_nextProp","attributeConfig","diff","process","nextValue","diffNestedArrayProperty","prevArray","nextArray","minLength","diffNestedProperty","clearNestedProperty","addNestedProperty","diffProperties","addProperties","clearProperties","prevProps","nextProps","shouldUpdate","_nextValue","_propKey","mountSafeCallback","callback","__isMounted","isMounted","throwOnStylesProp","component","styles","owner","_owner","displayName","msg","warnForStyleProps","style","_reactInternalFiber","ReactInternals","__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED","ReactCurrentOwner","ReactDebugCurrentFrame","getComponentName","fiber","findHostInstance","findHostInstanceFabric","injectFindHostInstance","impl","findNodeHandle","componentOrHandle","_warnedAboutRefsInRender","render","keys","findNumericNodeHandleFiber","NativeMethodsMixin","measure","measureInWindow","measureLayout","relativeToNativeNode","onSuccess","onFail","setNativeProps","nativeProps","maybeInstance","updateView","uiViewClassName","focus","focusTextInput","blur","blurTextInput","NativeMethodsMixin_DEV","componentWillMount","componentWillReceiveProps","UNSAFE_componentWillMount","UNSAFE_componentWillReceiveProps","newProps","__suppressDeprecationWarning","_classCallCheck$1","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","enumerable","writable","setPrototypeOf","__proto__","ReactNativeComponent","_React$Component","Component","NoEffect","PerformedWork","Placement","Update","PlacementAndUpdate","Deletion","ContentReset","Callback","DidCapture","Ref","ErrLog","HostEffectMask","Incomplete","ShouldCapture","MOUNTING","MOUNTED","UNMOUNTED","isFiberMountedImpl","effectTag","isFiberMounted","ownerFiber","assertIsMounted","findCurrentFiberUsingSlowPath","state","parentA","parentB","child","sibling","didFindChild","_child","findCurrentHostFiber","parent","currentParent","findCurrentHostFiberWithNoPortals","valueStack","fiberStack","createCursor","defaultValue","cursor","reset","describeComponentFrame","source","ownerName","fileName","replace","lineNumber","describeFiber","_debugOwner","_debugSource","getStackAddendumByWorkInProgressFiber","workInProgress","info","getCurrentFiberOwnerName","ReactDebugCurrentFiber","getCurrentFiberStackAddendum","resetCurrentFiber","getCurrentStack","setCurrentFiber","setCurrentPhase","_require","enableGetDerivedStateFromCatch","debugRenderPhaseSideEffects","debugRenderPhaseSideEffectsForStrictMode","warnAboutDeprecatedLifecycles","replayFailedUnitOfWorkWithInvokeGuardedCallback","enableUserTimingAPI","enableMutatingReconciler","enableNoopReconciler","enablePersistentReconciler","reactEmoji","warningEmoji","supportsUserTiming","performance","mark","clearMarks","clearMeasures","currentFiber","currentPhase","currentPhaseFiber","isCommitting","hasScheduledUpdateInCurrentCommit","hasScheduledUpdateInCurrentPhase","commitCountInCurrentWorkLoop","effectCountInCurrentCommit","isWaitingForCallback","labelsInCurrentCommit","Set","formatMarkName","markName","formatLabel","label","warning$$1","prefix","suffix","beginMark","clearMark","endMark","formattedMarkName","formattedLabel","err","getFiberMarkName","debugID","getFiberLabel","componentName","beginFiberMark","_debugID","has","add","clearFiberMark","endFiberMark","shouldIgnoreFiber","clearPendingPhaseMeasurement","pauseTimers","_debugIsCurrentlyTiming","resumeTimersRecursively","resumeTimers","recordEffect","recordScheduleUpdate","startRequestCallbackTimer","stopRequestCallbackTimer","didExpire","startWorkTimer","cancelWorkTimer","stopWorkTimer","stopFailedWorkTimer","startPhaseTimer","stopPhaseTimer","startWorkLoopTimer","nextUnitOfWork","stopWorkLoopTimer","interruptedBy","startCommitTimer","clear","stopCommitTimer","startCommitHostEffectsTimer","stopCommitHostEffectsTimer","startCommitLifeCyclesTimer","stopCommitLifeCyclesTimer","warnedAboutMissingGetChildContext","contextStackCursor","didPerformWorkStackCursor","previousContext","getUnmaskedContext","hasOwnContext","isContextProvider","cacheContext","unmaskedContext","maskedContext","__reactInternalMemoizedUnmaskedChildContext","__reactInternalMemoizedMaskedChildContext","getMaskedContext","contextTypes","hasContextChanged","isContextConsumer","childContextTypes","popContextProvider","popTopLevelContextObject","pushTopLevelContextObject","didChange","processChildContext","parentContext","getChildContext","childContext","contextKey","pushContextProvider","memoizedMergedChildContext","__reactInternalMemoizedMergedChildContext","invalidateContextProvider","mergedContext","resetContext","findCurrentUnmaskedContext","MAX_SIGNED_31_BIT_INT","NoWork","Sync","Never","UNIT_SIZE","MAGIC_NUMBER_OFFSET","msToExpirationTime","ms","expirationTimeToMs","expirationTime","ceiling","num","precision","computeExpirationBucket","currentTime","expirationInMs","bucketSizeMs","NoContext","AsyncMode","StrictMode","hasBadMapPolyfill","nonExtensibleObject","preventExtensions","testMap","Map","testSet","debugCounter","FiberNode","pendingProps","mode","ref","memoizedProps","updateQueue","memoizedState","nextEffect","firstEffect","lastEffect","createFiber","shouldConstruct","isReactComponent","createWorkInProgress","createHostRootFiber","isAsync","createFiberFromElement","element","fiberTag","createFiberFromFragment","throwOnInvalidElementType","_source","elements","createFiberFromText","content","createFiberFromHostInstanceForDeletion","createFiberFromPortal","portal","pendingChildren","createFiberRoot","hydrate","uninitializedFiber","root","pendingCommitExpirationTime","finishedWork","pendingContext","remainingExpirationTime","firstBatch","nextScheduledRoot","onCommitFiberRoot","onCommitFiberUnmount","hasLoggedError","catchErrors","injectInternals","internals","__REACT_DEVTOOLS_GLOBAL_HOOK__","hook","isDisabled","supportsFiber","rendererID","inject","onCommitRoot","onCommitUnmount","lowPriorityWarning","printWarning","format","_len","_key","argIndex","message","x","condition","_len2","_key2","lowPriorityWarning$1","ReactStrictModeWarnings","discardPendingWarnings","flushPendingDeprecationWarnings","flushPendingUnsafeLifecycleWarnings","recordDeprecationWarnings","recordUnsafeLifecycleWarnings","LIFECYCLE_SUGGESTIONS","UNSAFE_componentWillUpdate","pendingComponentWillMountWarnings","pendingComponentWillReceivePropsWarnings","pendingComponentWillUpdateWarnings","pendingUnsafeLifecycleWarnings","didWarnAboutDeprecatedLifecycles","didWarnAboutUnsafeLifecycles","lifecycleWarningsMap","strictRoot","lifecyclesWarningMesages","lifecycle","lifecycleWarnings","componentNames","formatted","suggestion","sortedComponentNames","sort","join","strictRootComponentStack","getStrictRoot","maybeStrictRoot","uniqueNames","sortedNames","_uniqueNames","_sortedNames","_uniqueNames2","_sortedNames2","componentWillUpdate","warningsForRoot","unsafeLifecycles","didWarnUpdateInsideUpdate","createUpdateQueue","baseState","queue","first","last","callbackList","hasForceUpdate","isInitialized","capturedValues","isProcessing","insertUpdateIntoQueue","update","q1","q2","ensureUpdateQueues","alternateFiber","queue1","queue2","insertUpdateIntoFiber","getUpdateExpirationTime","getStateFromUpdate","prevState","partialState","processUpdateQueue","renderExpirationTime","currentQueue","dontMutatePrevState","didSkip","updateExpirationTime","_partialState","isReplace","isForced","_callbackList","capturedValue","_capturedValues","commitCallbacks","_callback","fakeInternalInstance","didWarnAboutStateAssignmentForComponent","didWarnAboutUndefinedDerivedState","didWarnAboutUninitializedState","didWarnAboutWillReceivePropsAndDerivedState","warnOnInvalidCallback","didWarnOnInvalidCallback","callerName","callGetDerivedStateFromCatch","ctor","resultState","getDerivedStateFromCatch","ReactFiberClassComponent","scheduleWork","computeExpirationForFiber","memoizeProps","memoizeState","updater","enqueueSetState","enqueueReplaceState","enqueueForceUpdate","checkShouldComponentUpdate","oldProps","oldState","newState","newContext","shouldComponentUpdate","isPureReactComponent","checkClassInstance","renderPresent","noGetInitialStateOnES6","getInitialState","isReactClassApproved","noGetDefaultPropsOnES6","getDefaultProps","noInstancePropTypes","propTypes","noInstanceContextTypes","noComponentShouldUpdate","componentShouldUpdate","noComponentDidUnmount","componentDidUnmount","noComponentDidReceiveProps","componentDidReceiveProps","noComponentWillRecieveProps","componentWillRecieveProps","noUnsafeComponentWillRecieveProps","UNSAFE_componentWillRecieveProps","hasMutatedProps","noInstanceDefaultProps","defaultProps","resetInputPointers","adoptClassInstance","_reactInternalInstance","constructClassInstance","needsContext","getDerivedStateFromProps","callGetDerivedStateFromProps","callComponentWillMount","callComponentWillReceiveProps","_componentName","mountClassInstance","refs","componentDidMount","resumeMountClassInstance","oldContext","newUnmaskedContext","derivedStateFromProps","derivedStateFromCatch","componentDidUpdate","updateClassInstance","getCurrentFiberStackAddendum$1","didWarnAboutMaps","didWarnAboutStringRefInStrictMode","ownerHasKeyUseWarning","ownerHasFunctionTypeWarning","warnForMissingKey","_store","validated","currentComponentErrorInfo","isArray$1","coerceRef","returnFiber","mixedRef","stringRef","_stringRef","throwOnInvalidObjectType","newChild","addendum","toString","warnOnFunctionType","ChildReconciler","shouldTrackSideEffects","deleteChild","childToDelete","deleteRemainingChildren","currentFirstChild","mapRemainingChildren","existingChildren","existingChild","useFiber","clone","placeChild","newFiber","lastPlacedIndex","newIndex","oldIndex","placeSingleChild","updateTextNode","textContent","created","existing","updateElement","updatePortal","updateFragment","fragment","createChild","_created","_created2","_created3","updateSlot","oldFiber","updateFromMap","newIdx","matchedFiber","_matchedFiber","_matchedFiber2","_matchedFiber3","warnOnInvalidKey","knownKeys","reconcileChildrenArray","newChildren","resultingFirstChild","previousNewFiber","nextOldFiber","_newFiber","_newFiber2","reconcileChildrenIterator","newChildrenIterable","iteratorFn","entries","possibleMap","_newChildren","_step","done","step","_newFiber3","_newFiber4","reconcileSingleTextNode","reconcileSingleElement","_created4","reconcileSinglePortal","reconcileChildFibers","isObject","_isMockFunction","mountChildFibers","cloneChildFibers","currentChild","changedBitsStack","currentValueStack","stack","index$1","rendererSigil","pushProvider","providerFiber","_changedBits","_currentValue","_currentRenderer","popProvider","changedBits","currentValue","resetProviderStack","_defaultValue","didWarnAboutBadClass","didWarnAboutGetDerivedStateOnFunctionalComponent","didWarnAboutStatelessRefs","ReactFiberBeginWork","config","hostContext","hydrationContext","shouldSetTextContent","shouldDeprioritizeSubtree","pushHostContext","pushHostContainer","enterHydrationState","resetHydrationState","tryToClaimNextHydratableInstance","_ReactFiberClassCompo","reconcileChildren","nextChildren","reconcileChildrenAtExpirationTime","bailoutOnAlreadyFinishedWork","updateMode","markRef","updateFunctionalComponent","updateClassComponent","hasContext","didCaptureError","finishClassComponent","pushHostRootContext","updateHostRoot","updateHostComponent","isHidden","isDirectTextChild","updateHostText","mountIndeterminateComponent","_Component","warningKey","debugSource","updateCallComponent","updatePortalComponent","propagateContextChange","nextFiber","observedBits","updateContextProvider","providerType","newValue","oldValue","_calculateChangedBits","updateContextConsumer","unstable_observedBits","bailoutOnLowPriority","nextState","beginWork","ReactFiberCompleteWork","createInstance","createTextInstance","appendInitialChild","finalizeInitialChildren","prepareUpdate","mutation","persistence","getRootHostContainer","popHostContext","getHostContext","popHostContainer","prepareToHydrateHostInstance","prepareToHydrateHostTextInstance","popHydrationState","markUpdate","appendAllReturns","returns","moveCallToHandlerPhase","handler","childProps","appendAllChildren","updateHostContainer","rootContainerInstance","currentHostContext","oldText","newText","cloneInstance","createContainerChildSet","appendChildToContainerChildSet","finalizeContainerChildren","appendAllChildrenToContainer","containerChildSet","portalOrRoot","childrenUnchanged","container","newChildSet","currentInstance","recyclableInstance","newInstance","completeWork","componentDidCatch","fiberRoot","_updateQueue","_instance","_currentHostContext","wasHydrated","_instance2","_rootContainerInstance","_currentHostContext2","_wasHydrated","createCapturedValue","ReactFiberUnwindWork","isAlreadyFailedLegacyErrorBoundary","throwException","sourceFiber","rawValue","errorInfo","unwindWork","_effectTag","showErrorDialog","capturedError","componentStack","errorToHandle","summary","handleException","logCapturedError","logError","suppressLogging","suppressReactErrorLogging","errorBoundaryName","errorBoundaryFound","willRetry","componentNameMessage","errorBoundaryMessage","combinedMessage","invokeGuardedCallback$3","hasCaughtError$1","clearCaughtError$1","boundary","errorBoundary","ReactFiberCommitWork","captureError","markLegacyErrorBoundaryAsFailed","recalculateCurrentTime","getPublicInstance","callComponentWillUnmountWithTimer","componentWillUnmount","safelyCallComponentWillUnmount","unmountError","safelyDetachRef","refError","commitLifeCycles","finishedRoot","committedExpirationTime","_instance3","commitMount","commitErrorLogging","onUncaughtError","_instance4","capturedErrors","_error","_updateQueue2","_capturedErrors","_i","_errorInfo","commitAttachRef","_instance5","instanceToUse","commitDetachRef","currentRef","commitUnmount","_instance6","commitNestedUnmounts","unmountHostComponents","emptyPortalContainer","detachFiber","commitContainer","replaceContainerChildren","emptyChildSet","_pendingChildren","commitResetTextContent","commitPlacement","commitDeletion","commitWork","commitUpdate","resetTextContent","commitTextUpdate","appendChild","appendChildToContainer","insertBefore","insertInContainerBefore","removeChild","removeChildFromContainer","getHostParentFiber","isHostParent","getHostSibling","siblings","parentFiber","isContainer","before","currentParentIsValid","currentParentIsContainer","findParent","_instance7","textInstance","NO_CONTEXT","ReactFiberHostContext","getChildHostContext","getRootHostContext","contextFiberStackCursor","rootInstanceStackCursor","requiredContext","rootInstance","nextRootInstance","nextRootContext","nextContext","resetHostContainer","ReactFiberHydrationContext","hydration","canHydrateInstance","canHydrateTextInstance","getNextHydratableSibling","getFirstHydratableChild","hydrateInstance","hydrateTextInstance","didNotMatchHydratedContainerTextInstance","didNotMatchHydratedTextInstance","didNotHydrateContainerInstance","didNotHydrateInstance","didNotFindHydratableContainerInstance","didNotFindHydratableContainerTextInstance","didNotFindHydratableInstance","didNotFindHydratableTextInstance","hydrationParentFiber","nextHydratableInstance","isHydrating","parentInstance","deleteHydratableInstance","insertNonHydratedInstance","parentContainer","text","parentType","parentProps","_type","_props","_text","tryHydrate","nextInstance","popToNextHostParent","ReactFiberInstrumentation","debugTool","ReactFiberInstrumentation_1","invokeGuardedCallback$2","didWarnAboutStateTransition","didWarnSetStateChildContext","warnAboutUpdateOnUnmounted","warnAboutInvalidUpdates","didWarnStateUpdateForUnmountedComponent","ReactFiberScheduler","_ReactFiberBeginWork","_ReactFiberCompleteWo","_ReactFiberUnwindWork","_ReactFiberCommitWork","onCommitPhaseError","scheduleDeferredCallback","cancelDeferredCallback","prepareForCommit","resetAfterCommit","originalStartTimeMs","mostRecentCurrentTime","mostRecentCurrentTimeMs","lastUniqueAsyncExpiration","expirationContext","isWorking","nextRoot","nextRenderExpirationTime","isRootReadyForCommit","legacyErrorBoundariesThatAlreadyFailed","stashedWorkInProgressProperties","replayUnitOfWork","failedUnitOfWork","workLoop","resetContextStack","commitAllHostEffects","primaryEffectTag","_current","_current2","commitAllLifeCycles","commitRoot","_didError","onCommitWork","remainingTime","resetExpirationTime","renderTime","newExpirationTime","completeUnitOfWork","siblingFiber","onCompleteWork","_next","performUnitOfWork","onBeginWork","shouldYield","renderRoot","didFatal","thrownValue","scheduleCapture","boundaryFiber","dispatch","computeAsyncExpiration","expirationMs","computeInteractiveExpiration","computeUniqueAsyncExpiration","isBatchingInteractiveUpdates","_currentTime","lowestPendingInteractiveExpirationTime","scheduleWorkImpl","isErrorRecovery","requestWork","nestedUpdateCount","NESTED_UPDATE_LIMIT","deferredUpdates","previousExpirationContext","syncUpdates","firstScheduledRoot","lastScheduledRoot","callbackExpirationTime","callbackID","isRendering","nextFlushedRoot","nextFlushedExpirationTime","deadlineDidExpire","hasUnhandledError","unhandledError","deadline","isBatchingUpdates","isUnbatchingUpdates","completedBatches","timeHeuristicForUnitOfWork","scheduleCallbackWithExpiration","currentMs","timeout","performAsyncWork","addRootToSchedule","performWorkOnRoot","performSyncWork","findHighestPriorityRoot","highestPriorityWork","highestPriorityRoot","previousScheduledRoot","previousFlushedRoot","dl","performWork","minExpirationTime","finishRendering","flushRoot","batches","batch","_onComplete","completeRoot","_finishedWork","_expirationTime","_defer","timeRemaining","previousIsBatchingUpdates","unbatchedUpdates","flushSync","previousIsBatchingInteractiveUpdates","flushControlled","didWarnAboutNestedUpdates","getContextForSubtree","parentComponent","ReactFiberReconciler$1","_ReactFiberScheduler","scheduleRootUpdate","updateContainerAtExpirationTime","onMountContainer","onUnmountContainer","onUpdateContainer","hostFiber","createContainer","updateContainer","getPublicRootInstance","containerFiber","findHostInstanceWithNoPortals","injectIntoDevTools","devToolsConfig","findFiberByHostInstance","findHostInstanceByFiber","ReactFiberReconciler$2","default","ReactFiberReconciler$3","reactReconciler","viewConfigCallbacks","viewConfigs","get$1","_classCallCheck$2","ReactNativeFiberHostComponent","_children","hasNativePerformanceNow","scheduledCallback","frameDeadline","frameDeadlineObject","setTimeoutCallback","setTimeout","clearTimeout","recursivelyUncacheFiberNode","NativeRenderer","internalInstanceHandle","createView","nativeTags","map","setChildren","childTag","splice","manageChildren","updatePayloadTODO","beforeChild","beforeChildIndex","_beforeChildIndex","getInspectorDataForViewTag","traverseOwnerTreeUp","hierarchy","unshift","getOwnerHierarchy","lastNonHostInstance","getHostProps","host","getHostNode","hostNode","createHierarchy","fiberHierarchy","getInspectorData","viewTag","closestInstance","selection","createReactNativeComponentClass","takeSnapshot","view","options","__takeSnapshot","roots","ReactNativeRenderer","NativeComponent","containerTag","unmountComponentAtNode","unmountComponentAtNodeAndRemoveContainer","removeRootView","unstable_batchedUpdates","ReactDebugTool","addHook","removeHook","ReactPerf","start","stop","printInclusive","printWasted","bundleType","version","rendererPackageName","ReactNativeRenderer$2","ReactNativeRenderer$3","reactNativeRenderer","module","exports"],"mappings":"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","file":"ReactNativeRenderer-dev.js","sourcesContent":["/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @noflow\n * @providesModule ReactNativeRenderer-dev\n * @preventMunge\n */\n\n'use strict';\n\nif (__DEV__) {\n  (function() {\n\"use strict\";\n\nrequire(\"InitializeCore\");\nvar invariant = require(\"fbjs/lib/invariant\");\nvar warning = require(\"fbjs/lib/warning\");\nvar emptyFunction = require(\"fbjs/lib/emptyFunction\");\nvar UIManager = require(\"UIManager\");\nvar RCTEventEmitter = require(\"RCTEventEmitter\");\nvar TextInputState = require(\"TextInputState\");\nvar deepDiffer = require(\"deepDiffer\");\nvar flattenStyle = require(\"flattenStyle\");\nvar React = require(\"react\");\nvar emptyObject = require(\"fbjs/lib/emptyObject\");\nvar checkPropTypes = require(\"prop-types/checkPropTypes\");\nvar shallowEqual = require(\"fbjs/lib/shallowEqual\");\nvar ExceptionsManager = require(\"ExceptionsManager\");\nvar deepFreezeAndThrowOnMutationInDev = require(\"deepFreezeAndThrowOnMutationInDev\");\n\nvar invokeGuardedCallback = function(name, func, context, a, b, c, d, e, f) {\n  this._hasCaughtError = false;\n  this._caughtError = null;\n  var funcArgs = Array.prototype.slice.call(arguments, 3);\n  try {\n    func.apply(context, funcArgs);\n  } catch (error) {\n    this._caughtError = error;\n    this._hasCaughtError = true;\n  }\n};\n\n{\n  // In DEV mode, we swap out invokeGuardedCallback for a special version\n  // that plays more nicely with the browser's DevTools. The idea is to preserve\n  // \"Pause on exceptions\" behavior. Because React wraps all user-provided\n  // functions in invokeGuardedCallback, and the production version of\n  // invokeGuardedCallback uses a try-catch, all user exceptions are treated\n  // like caught exceptions, and the DevTools won't pause unless the developer\n  // takes the extra step of enabling pause on caught exceptions. This is\n  // untintuitive, though, because even though React has caught the error, from\n  // the developer's perspective, the error is uncaught.\n  //\n  // To preserve the expected \"Pause on exceptions\" behavior, we don't use a\n  // try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake\n  // DOM node, and call the user-provided callback from inside an event handler\n  // for that fake event. If the callback throws, the error is \"captured\" using\n  // a global event handler. But because the error happens in a different\n  // event loop context, it does not interrupt the normal program flow.\n  // Effectively, this gives us try-catch behavior without actually using\n  // try-catch. Neat!\n\n  // Check that the browser supports the APIs we need to implement our special\n  // DEV version of invokeGuardedCallback\n  if (\n    typeof window !== \"undefined\" &&\n    typeof window.dispatchEvent === \"function\" &&\n    typeof document !== \"undefined\" &&\n    typeof document.createEvent === \"function\"\n  ) {\n    var fakeNode = document.createElement(\"react\");\n\n    var invokeGuardedCallbackDev = function(\n      name,\n      func,\n      context,\n      a,\n      b,\n      c,\n      d,\n      e,\n      f\n    ) {\n      // If document doesn't exist we know for sure we will crash in this method\n      // when we call document.createEvent(). However this can cause confusing\n      // errors: https://github.com/facebookincubator/create-react-app/issues/3482\n      // So we preemptively throw with a better message instead.\n      invariant(\n        typeof document !== \"undefined\",\n        \"The `document` global was defined when React was initialized, but is not \" +\n          \"defined anymore. This can happen in a test environment if a component \" +\n          \"schedules an update from an asynchronous callback, but the test has already \" +\n          \"finished running. To solve this, you can either unmount the component at \" +\n          \"the end of your test (and ensure that any asynchronous operations get \" +\n          \"canceled in `componentWillUnmount`), or you can change the test itself \" +\n          \"to be asynchronous.\"\n      );\n      var evt = document.createEvent(\"Event\");\n\n      // Keeps track of whether the user-provided callback threw an error. We\n      // set this to true at the beginning, then set it to false right after\n      // calling the function. If the function errors, `didError` will never be\n      // set to false. This strategy works even if the browser is flaky and\n      // fails to call our global error handler, because it doesn't rely on\n      // the error event at all.\n      var didError = true;\n\n      // Create an event handler for our fake event. We will synchronously\n      // dispatch our fake event using `dispatchEvent`. Inside the handler, we\n      // call the user-provided callback.\n      var funcArgs = Array.prototype.slice.call(arguments, 3);\n      function callCallback() {\n        // We immediately remove the callback from event listeners so that\n        // nested `invokeGuardedCallback` calls do not clash. Otherwise, a\n        // nested call would trigger the fake event handlers of any call higher\n        // in the stack.\n        fakeNode.removeEventListener(evtType, callCallback, false);\n        func.apply(context, funcArgs);\n        didError = false;\n      }\n\n      // Create a global error event handler. We use this to capture the value\n      // that was thrown. It's possible that this error handler will fire more\n      // than once; for example, if non-React code also calls `dispatchEvent`\n      // and a handler for that event throws. We should be resilient to most of\n      // those cases. Even if our error event handler fires more than once, the\n      // last error event is always used. If the callback actually does error,\n      // we know that the last error event is the correct one, because it's not\n      // possible for anything else to have happened in between our callback\n      // erroring and the code that follows the `dispatchEvent` call below. If\n      // the callback doesn't error, but the error event was fired, we know to\n      // ignore it because `didError` will be false, as described above.\n      var error = void 0;\n      // Use this to track whether the error event is ever called.\n      var didSetError = false;\n      var isCrossOriginError = false;\n\n      function onError(event) {\n        error = event.error;\n        didSetError = true;\n        if (error === null && event.colno === 0 && event.lineno === 0) {\n          isCrossOriginError = true;\n        }\n      }\n\n      // Create a fake event type.\n      var evtType = \"react-\" + (name ? name : \"invokeguardedcallback\");\n\n      // Attach our event handlers\n      window.addEventListener(\"error\", onError);\n      fakeNode.addEventListener(evtType, callCallback, false);\n\n      // Synchronously dispatch our fake event. If the user-provided function\n      // errors, it will trigger our global error handler.\n      evt.initEvent(evtType, false, false);\n      fakeNode.dispatchEvent(evt);\n\n      if (didError) {\n        if (!didSetError) {\n          // The callback errored, but the error event never fired.\n          error = new Error(\n            \"An error was thrown inside one of your components, but React \" +\n              \"doesn't know what it was. This is likely due to browser \" +\n              'flakiness. React does its best to preserve the \"Pause on ' +\n              'exceptions\" behavior of the DevTools, which requires some ' +\n              \"DEV-mode only tricks. It's possible that these don't work in \" +\n              \"your browser. Try triggering the error in production mode, \" +\n              \"or switching to a modern browser. If you suspect that this is \" +\n              \"actually an issue with React, please file an issue.\"\n          );\n        } else if (isCrossOriginError) {\n          error = new Error(\n            \"A cross-origin error was thrown. React doesn't have access to \" +\n              \"the actual error object in development. \" +\n              \"See https://fb.me/react-crossorigin-error for more information.\"\n          );\n        }\n        this._hasCaughtError = true;\n        this._caughtError = error;\n      } else {\n        this._hasCaughtError = false;\n        this._caughtError = null;\n      }\n\n      // Remove our event listeners\n      window.removeEventListener(\"error\", onError);\n    };\n\n    invokeGuardedCallback = invokeGuardedCallbackDev;\n  }\n}\n\nvar invokeGuardedCallback$1 = invokeGuardedCallback;\n\nvar ReactErrorUtils = {\n  // Used by Fiber to simulate a try-catch.\n  _caughtError: null,\n  _hasCaughtError: false,\n\n  // Used by event system to capture/rethrow the first error.\n  _rethrowError: null,\n  _hasRethrowError: false,\n\n  /**\n   * Call a function while guarding against errors that happens within it.\n   * Returns an error if it throws, otherwise null.\n   *\n   * In production, this is implemented using a try-catch. The reason we don't\n   * use a try-catch directly is so that we can swap out a different\n   * implementation in DEV mode.\n   *\n   * @param {String} name of the guard to use for logging or debugging\n   * @param {Function} func The function to invoke\n   * @param {*} context The context to use when calling the function\n   * @param {...*} args Arguments for function\n   */\n  invokeGuardedCallback: function(name, func, context, a, b, c, d, e, f) {\n    invokeGuardedCallback$1.apply(ReactErrorUtils, arguments);\n  },\n\n  /**\n   * Same as invokeGuardedCallback, but instead of returning an error, it stores\n   * it in a global so it can be rethrown by `rethrowCaughtError` later.\n   * TODO: See if _caughtError and _rethrowError can be unified.\n   *\n   * @param {String} name of the guard to use for logging or debugging\n   * @param {Function} func The function to invoke\n   * @param {*} context The context to use when calling the function\n   * @param {...*} args Arguments for function\n   */\n  invokeGuardedCallbackAndCatchFirstError: function(\n    name,\n    func,\n    context,\n    a,\n    b,\n    c,\n    d,\n    e,\n    f\n  ) {\n    ReactErrorUtils.invokeGuardedCallback.apply(this, arguments);\n    if (ReactErrorUtils.hasCaughtError()) {\n      var error = ReactErrorUtils.clearCaughtError();\n      if (!ReactErrorUtils._hasRethrowError) {\n        ReactErrorUtils._hasRethrowError = true;\n        ReactErrorUtils._rethrowError = error;\n      }\n    }\n  },\n\n  /**\n   * During execution of guarded functions we will capture the first error which\n   * we will rethrow to be handled by the top level error handler.\n   */\n  rethrowCaughtError: function() {\n    return rethrowCaughtError.apply(ReactErrorUtils, arguments);\n  },\n\n  hasCaughtError: function() {\n    return ReactErrorUtils._hasCaughtError;\n  },\n\n  clearCaughtError: function() {\n    if (ReactErrorUtils._hasCaughtError) {\n      var error = ReactErrorUtils._caughtError;\n      ReactErrorUtils._caughtError = null;\n      ReactErrorUtils._hasCaughtError = false;\n      return error;\n    } else {\n      invariant(\n        false,\n        \"clearCaughtError was called but no error was captured. This error \" +\n          \"is likely caused by a bug in React. Please file an issue.\"\n      );\n    }\n  }\n};\n\nvar rethrowCaughtError = function() {\n  if (ReactErrorUtils._hasRethrowError) {\n    var error = ReactErrorUtils._rethrowError;\n    ReactErrorUtils._rethrowError = null;\n    ReactErrorUtils._hasRethrowError = false;\n    throw error;\n  }\n};\n\n/**\n * Injectable ordering of event plugins.\n */\nvar eventPluginOrder = null;\n\n/**\n * Injectable mapping from names to event plugin modules.\n */\nvar namesToPlugins = {};\n\n/**\n * Recomputes the plugin list using the injected plugins and plugin ordering.\n *\n * @private\n */\nfunction recomputePluginOrdering() {\n  if (!eventPluginOrder) {\n    // Wait until an `eventPluginOrder` is injected.\n    return;\n  }\n  for (var pluginName in namesToPlugins) {\n    var pluginModule = namesToPlugins[pluginName];\n    var pluginIndex = eventPluginOrder.indexOf(pluginName);\n    invariant(\n      pluginIndex > -1,\n      \"EventPluginRegistry: Cannot inject event plugins that do not exist in \" +\n        \"the plugin ordering, `%s`.\",\n      pluginName\n    );\n    if (plugins[pluginIndex]) {\n      continue;\n    }\n    invariant(\n      pluginModule.extractEvents,\n      \"EventPluginRegistry: Event plugins must implement an `extractEvents` \" +\n        \"method, but `%s` does not.\",\n      pluginName\n    );\n    plugins[pluginIndex] = pluginModule;\n    var publishedEvents = pluginModule.eventTypes;\n    for (var eventName in publishedEvents) {\n      invariant(\n        publishEventForPlugin(\n          publishedEvents[eventName],\n          pluginModule,\n          eventName\n        ),\n        \"EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.\",\n        eventName,\n        pluginName\n      );\n    }\n  }\n}\n\n/**\n * Publishes an event so that it can be dispatched by the supplied plugin.\n *\n * @param {object} dispatchConfig Dispatch configuration for the event.\n * @param {object} PluginModule Plugin publishing the event.\n * @return {boolean} True if the event was successfully published.\n * @private\n */\nfunction publishEventForPlugin(dispatchConfig, pluginModule, eventName) {\n  invariant(\n    !eventNameDispatchConfigs.hasOwnProperty(eventName),\n    \"EventPluginHub: More than one plugin attempted to publish the same \" +\n      \"event name, `%s`.\",\n    eventName\n  );\n  eventNameDispatchConfigs[eventName] = dispatchConfig;\n\n  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;\n  if (phasedRegistrationNames) {\n    for (var phaseName in phasedRegistrationNames) {\n      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {\n        var phasedRegistrationName = phasedRegistrationNames[phaseName];\n        publishRegistrationName(\n          phasedRegistrationName,\n          pluginModule,\n          eventName\n        );\n      }\n    }\n    return true;\n  } else if (dispatchConfig.registrationName) {\n    publishRegistrationName(\n      dispatchConfig.registrationName,\n      pluginModule,\n      eventName\n    );\n    return true;\n  }\n  return false;\n}\n\n/**\n * Publishes a registration name that is used to identify dispatched events.\n *\n * @param {string} registrationName Registration name to add.\n * @param {object} PluginModule Plugin publishing the event.\n * @private\n */\nfunction publishRegistrationName(registrationName, pluginModule, eventName) {\n  invariant(\n    !registrationNameModules[registrationName],\n    \"EventPluginHub: More than one plugin attempted to publish the same \" +\n      \"registration name, `%s`.\",\n    registrationName\n  );\n  registrationNameModules[registrationName] = pluginModule;\n  registrationNameDependencies[registrationName] =\n    pluginModule.eventTypes[eventName].dependencies;\n\n  {\n    var lowerCasedName = registrationName.toLowerCase();\n  }\n}\n\n/**\n * Registers plugins so that they can extract and dispatch events.\n *\n * @see {EventPluginHub}\n */\n\n/**\n * Ordered list of injected plugins.\n */\nvar plugins = [];\n\n/**\n * Mapping from event name to dispatch config\n */\nvar eventNameDispatchConfigs = {};\n\n/**\n * Mapping from registration name to plugin module\n */\nvar registrationNameModules = {};\n\n/**\n * Mapping from registration name to event name\n */\nvar registrationNameDependencies = {};\n\n/**\n * Mapping from lowercase registration names to the properly cased version,\n * used to warn in the case of missing event handlers. Available\n * only in true.\n * @type {Object}\n */\n\n// Trust the developer to only use possibleRegistrationNames in true\n\n/**\n * Injects an ordering of plugins (by plugin name). This allows the ordering\n * to be decoupled from injection of the actual plugins so that ordering is\n * always deterministic regardless of packaging, on-the-fly injection, etc.\n *\n * @param {array} InjectedEventPluginOrder\n * @internal\n * @see {EventPluginHub.injection.injectEventPluginOrder}\n */\nfunction injectEventPluginOrder(injectedEventPluginOrder) {\n  invariant(\n    !eventPluginOrder,\n    \"EventPluginRegistry: Cannot inject event plugin ordering more than \" +\n      \"once. You are likely trying to load more than one copy of React.\"\n  );\n  // Clone the ordering so it cannot be dynamically mutated.\n  eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);\n  recomputePluginOrdering();\n}\n\n/**\n * Injects plugins to be used by `EventPluginHub`. The plugin names must be\n * in the ordering injected by `injectEventPluginOrder`.\n *\n * Plugins can be injected as part of page initialization or on-the-fly.\n *\n * @param {object} injectedNamesToPlugins Map from names to plugin modules.\n * @internal\n * @see {EventPluginHub.injection.injectEventPluginsByName}\n */\nfunction injectEventPluginsByName(injectedNamesToPlugins) {\n  var isOrderingDirty = false;\n  for (var pluginName in injectedNamesToPlugins) {\n    if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {\n      continue;\n    }\n    var pluginModule = injectedNamesToPlugins[pluginName];\n    if (\n      !namesToPlugins.hasOwnProperty(pluginName) ||\n      namesToPlugins[pluginName] !== pluginModule\n    ) {\n      invariant(\n        !namesToPlugins[pluginName],\n        \"EventPluginRegistry: Cannot inject two different event plugins \" +\n          \"using the same name, `%s`.\",\n        pluginName\n      );\n      namesToPlugins[pluginName] = pluginModule;\n      isOrderingDirty = true;\n    }\n  }\n  if (isOrderingDirty) {\n    recomputePluginOrdering();\n  }\n}\n\nvar getFiberCurrentPropsFromNode = null;\nvar getInstanceFromNode = null;\nvar getNodeFromInstance = null;\n\nvar injection$1 = {\n  injectComponentTree: function(Injected) {\n    getFiberCurrentPropsFromNode = Injected.getFiberCurrentPropsFromNode;\n    getInstanceFromNode = Injected.getInstanceFromNode;\n    getNodeFromInstance = Injected.getNodeFromInstance;\n\n    {\n      warning(\n        getNodeFromInstance && getInstanceFromNode,\n        \"EventPluginUtils.injection.injectComponentTree(...): Injected \" +\n          \"module is missing getNodeFromInstance or getInstanceFromNode.\"\n      );\n    }\n  }\n};\n\nfunction isEndish(topLevelType) {\n  return (\n    topLevelType === \"topMouseUp\" ||\n    topLevelType === \"topTouchEnd\" ||\n    topLevelType === \"topTouchCancel\"\n  );\n}\n\nfunction isMoveish(topLevelType) {\n  return topLevelType === \"topMouseMove\" || topLevelType === \"topTouchMove\";\n}\nfunction isStartish(topLevelType) {\n  return topLevelType === \"topMouseDown\" || topLevelType === \"topTouchStart\";\n}\n\nvar validateEventDispatches = void 0;\n{\n  validateEventDispatches = function(event) {\n    var dispatchListeners = event._dispatchListeners;\n    var dispatchInstances = event._dispatchInstances;\n\n    var listenersIsArr = Array.isArray(dispatchListeners);\n    var listenersLen = listenersIsArr\n      ? dispatchListeners.length\n      : dispatchListeners ? 1 : 0;\n\n    var instancesIsArr = Array.isArray(dispatchInstances);\n    var instancesLen = instancesIsArr\n      ? dispatchInstances.length\n      : dispatchInstances ? 1 : 0;\n\n    warning(\n      instancesIsArr === listenersIsArr && instancesLen === listenersLen,\n      \"EventPluginUtils: Invalid `event`.\"\n    );\n  };\n}\n\n/**\n * Dispatch the event to the listener.\n * @param {SyntheticEvent} event SyntheticEvent to handle\n * @param {boolean} simulated If the event is simulated (changes exn behavior)\n * @param {function} listener Application-level callback\n * @param {*} inst Internal component instance\n */\nfunction executeDispatch(event, simulated, listener, inst) {\n  var type = event.type || \"unknown-event\";\n  event.currentTarget = getNodeFromInstance(inst);\n  ReactErrorUtils.invokeGuardedCallbackAndCatchFirstError(\n    type,\n    listener,\n    undefined,\n    event\n  );\n  event.currentTarget = null;\n}\n\n/**\n * Standard/simple iteration through an event's collected dispatches.\n */\nfunction executeDispatchesInOrder(event, simulated) {\n  var dispatchListeners = event._dispatchListeners;\n  var dispatchInstances = event._dispatchInstances;\n  {\n    validateEventDispatches(event);\n  }\n  if (Array.isArray(dispatchListeners)) {\n    for (var i = 0; i < dispatchListeners.length; i++) {\n      if (event.isPropagationStopped()) {\n        break;\n      }\n      // Listeners and Instances are two parallel arrays that are always in sync.\n      executeDispatch(\n        event,\n        simulated,\n        dispatchListeners[i],\n        dispatchInstances[i]\n      );\n    }\n  } else if (dispatchListeners) {\n    executeDispatch(event, simulated, dispatchListeners, dispatchInstances);\n  }\n  event._dispatchListeners = null;\n  event._dispatchInstances = null;\n}\n\n/**\n * Standard/simple iteration through an event's collected dispatches, but stops\n * at the first dispatch execution returning true, and returns that id.\n *\n * @return {?string} id of the first dispatch execution who's listener returns\n * true, or null if no listener returned true.\n */\nfunction executeDispatchesInOrderStopAtTrueImpl(event) {\n  var dispatchListeners = event._dispatchListeners;\n  var dispatchInstances = event._dispatchInstances;\n  {\n    validateEventDispatches(event);\n  }\n  if (Array.isArray(dispatchListeners)) {\n    for (var i = 0; i < dispatchListeners.length; i++) {\n      if (event.isPropagationStopped()) {\n        break;\n      }\n      // Listeners and Instances are two parallel arrays that are always in sync.\n      if (dispatchListeners[i](event, dispatchInstances[i])) {\n        return dispatchInstances[i];\n      }\n    }\n  } else if (dispatchListeners) {\n    if (dispatchListeners(event, dispatchInstances)) {\n      return dispatchInstances;\n    }\n  }\n  return null;\n}\n\n/**\n * @see executeDispatchesInOrderStopAtTrueImpl\n */\nfunction executeDispatchesInOrderStopAtTrue(event) {\n  var ret = executeDispatchesInOrderStopAtTrueImpl(event);\n  event._dispatchInstances = null;\n  event._dispatchListeners = null;\n  return ret;\n}\n\n/**\n * Execution of a \"direct\" dispatch - there must be at most one dispatch\n * accumulated on the event or it is considered an error. It doesn't really make\n * sense for an event with multiple dispatches (bubbled) to keep track of the\n * return values at each dispatch execution, but it does tend to make sense when\n * dealing with \"direct\" dispatches.\n *\n * @return {*} The return value of executing the single dispatch.\n */\nfunction executeDirectDispatch(event) {\n  {\n    validateEventDispatches(event);\n  }\n  var dispatchListener = event._dispatchListeners;\n  var dispatchInstance = event._dispatchInstances;\n  invariant(\n    !Array.isArray(dispatchListener),\n    \"executeDirectDispatch(...): Invalid `event`.\"\n  );\n  event.currentTarget = dispatchListener\n    ? getNodeFromInstance(dispatchInstance)\n    : null;\n  var res = dispatchListener ? dispatchListener(event) : null;\n  event.currentTarget = null;\n  event._dispatchListeners = null;\n  event._dispatchInstances = null;\n  return res;\n}\n\n/**\n * @param {SyntheticEvent} event\n * @return {boolean} True iff number of dispatches accumulated is greater than 0.\n */\nfunction hasDispatches(event) {\n  return !!event._dispatchListeners;\n}\n\n/**\n * Accumulates items that must not be null or undefined into the first one. This\n * is used to conserve memory by avoiding array allocations, and thus sacrifices\n * API cleanness. Since `current` can be null before being passed in and not\n * null after this function, make sure to assign it back to `current`:\n *\n * `a = accumulateInto(a, b);`\n *\n * This API should be sparingly used. Try `accumulate` for something cleaner.\n *\n * @return {*|array<*>} An accumulation of items.\n */\n\nfunction accumulateInto(current, next) {\n  invariant(\n    next != null,\n    \"accumulateInto(...): Accumulated items must not be null or undefined.\"\n  );\n\n  if (current == null) {\n    return next;\n  }\n\n  // Both are not empty. Warning: Never call x.concat(y) when you are not\n  // certain that x is an Array (x could be a string with concat method).\n  if (Array.isArray(current)) {\n    if (Array.isArray(next)) {\n      current.push.apply(current, next);\n      return current;\n    }\n    current.push(next);\n    return current;\n  }\n\n  if (Array.isArray(next)) {\n    // A bit too dangerous to mutate `next`.\n    return [current].concat(next);\n  }\n\n  return [current, next];\n}\n\n/**\n * @param {array} arr an \"accumulation\" of items which is either an Array or\n * a single item. Useful when paired with the `accumulate` module. This is a\n * simple utility that allows us to reason about a collection of items, but\n * handling the case when there is exactly one item (and we do not need to\n * allocate an array).\n * @param {function} cb Callback invoked with each element or a collection.\n * @param {?} [scope] Scope used as `this` in a callback.\n */\nfunction forEachAccumulated(arr, cb, scope) {\n  if (Array.isArray(arr)) {\n    arr.forEach(cb, scope);\n  } else if (arr) {\n    cb.call(scope, arr);\n  }\n}\n\n/**\n * Internal queue of events that have accumulated their dispatches and are\n * waiting to have their dispatches executed.\n */\nvar eventQueue = null;\n\n/**\n * Dispatches an event and releases it back into the pool, unless persistent.\n *\n * @param {?object} event Synthetic event to be dispatched.\n * @param {boolean} simulated If the event is simulated (changes exn behavior)\n * @private\n */\nvar executeDispatchesAndRelease = function(event, simulated) {\n  if (event) {\n    executeDispatchesInOrder(event, simulated);\n\n    if (!event.isPersistent()) {\n      event.constructor.release(event);\n    }\n  }\n};\nvar executeDispatchesAndReleaseSimulated = function(e) {\n  return executeDispatchesAndRelease(e, true);\n};\nvar executeDispatchesAndReleaseTopLevel = function(e) {\n  return executeDispatchesAndRelease(e, false);\n};\n\nfunction isInteractive(tag) {\n  return (\n    tag === \"button\" ||\n    tag === \"input\" ||\n    tag === \"select\" ||\n    tag === \"textarea\"\n  );\n}\n\nfunction shouldPreventMouseEvent(name, type, props) {\n  switch (name) {\n    case \"onClick\":\n    case \"onClickCapture\":\n    case \"onDoubleClick\":\n    case \"onDoubleClickCapture\":\n    case \"onMouseDown\":\n    case \"onMouseDownCapture\":\n    case \"onMouseMove\":\n    case \"onMouseMoveCapture\":\n    case \"onMouseUp\":\n    case \"onMouseUpCapture\":\n      return !!(props.disabled && isInteractive(type));\n    default:\n      return false;\n  }\n}\n\n/**\n * This is a unified interface for event plugins to be installed and configured.\n *\n * Event plugins can implement the following properties:\n *\n *   `extractEvents` {function(string, DOMEventTarget, string, object): *}\n *     Required. When a top-level event is fired, this method is expected to\n *     extract synthetic events that will in turn be queued and dispatched.\n *\n *   `eventTypes` {object}\n *     Optional, plugins that fire events must publish a mapping of registration\n *     names that are used to register listeners. Values of this mapping must\n *     be objects that contain `registrationName` or `phasedRegistrationNames`.\n *\n *   `executeDispatch` {function(object, function, string)}\n *     Optional, allows plugins to override how an event gets dispatched. By\n *     default, the listener is simply invoked.\n *\n * Each plugin that is injected into `EventsPluginHub` is immediately operable.\n *\n * @public\n */\n\n/**\n * Methods for injecting dependencies.\n */\nvar injection = {\n  /**\n   * @param {array} InjectedEventPluginOrder\n   * @public\n   */\n  injectEventPluginOrder: injectEventPluginOrder,\n\n  /**\n   * @param {object} injectedNamesToPlugins Map from names to plugin modules.\n   */\n  injectEventPluginsByName: injectEventPluginsByName\n};\n\n/**\n * @param {object} inst The instance, which is the source of events.\n * @param {string} registrationName Name of listener (e.g. `onClick`).\n * @return {?function} The stored callback.\n */\nfunction getListener(inst, registrationName) {\n  var listener = void 0;\n\n  // TODO: shouldPreventMouseEvent is DOM-specific and definitely should not\n  // live here; needs to be moved to a better place soon\n  var stateNode = inst.stateNode;\n  if (!stateNode) {\n    // Work in progress (ex: onload events in incremental mode).\n    return null;\n  }\n  var props = getFiberCurrentPropsFromNode(stateNode);\n  if (!props) {\n    // Work in progress.\n    return null;\n  }\n  listener = props[registrationName];\n  if (shouldPreventMouseEvent(registrationName, inst.type, props)) {\n    return null;\n  }\n  invariant(\n    !listener || typeof listener === \"function\",\n    \"Expected `%s` listener to be a function, instead got a value of `%s` type.\",\n    registrationName,\n    typeof listener\n  );\n  return listener;\n}\n\n/**\n * Allows registered plugins an opportunity to extract events from top-level\n * native browser events.\n *\n * @return {*} An accumulation of synthetic events.\n * @internal\n */\nfunction extractEvents(\n  topLevelType,\n  targetInst,\n  nativeEvent,\n  nativeEventTarget\n) {\n  var events = null;\n  for (var i = 0; i < plugins.length; i++) {\n    // Not every plugin in the ordering may be loaded at runtime.\n    var possiblePlugin = plugins[i];\n    if (possiblePlugin) {\n      var extractedEvents = possiblePlugin.extractEvents(\n        topLevelType,\n        targetInst,\n        nativeEvent,\n        nativeEventTarget\n      );\n      if (extractedEvents) {\n        events = accumulateInto(events, extractedEvents);\n      }\n    }\n  }\n  return events;\n}\n\nfunction runEventsInBatch(events, simulated) {\n  if (events !== null) {\n    eventQueue = accumulateInto(eventQueue, events);\n  }\n\n  // Set `eventQueue` to null before processing it so that we can tell if more\n  // events get enqueued while processing.\n  var processingEventQueue = eventQueue;\n  eventQueue = null;\n\n  if (!processingEventQueue) {\n    return;\n  }\n\n  if (simulated) {\n    forEachAccumulated(\n      processingEventQueue,\n      executeDispatchesAndReleaseSimulated\n    );\n  } else {\n    forEachAccumulated(\n      processingEventQueue,\n      executeDispatchesAndReleaseTopLevel\n    );\n  }\n  invariant(\n    !eventQueue,\n    \"processEventQueue(): Additional events were enqueued while processing \" +\n      \"an event queue. Support for this has not yet been implemented.\"\n  );\n  // This would be a good time to rethrow if any of the event handlers threw.\n  ReactErrorUtils.rethrowCaughtError();\n}\n\nfunction runExtractedEventsInBatch(\n  topLevelType,\n  targetInst,\n  nativeEvent,\n  nativeEventTarget\n) {\n  var events = extractEvents(\n    topLevelType,\n    targetInst,\n    nativeEvent,\n    nativeEventTarget\n  );\n  runEventsInBatch(events, false);\n}\n\nvar IndeterminateComponent = 0; // Before we know whether it is functional or class\nvar FunctionalComponent = 1;\nvar ClassComponent = 2;\nvar HostRoot = 3; // Root of a host tree. Could be nested inside another node.\nvar HostPortal = 4; // A subtree. Could be an entry point to a different renderer.\nvar HostComponent = 5;\nvar HostText = 6;\nvar CallComponent = 7;\nvar CallHandlerPhase = 8;\nvar ReturnComponent = 9;\nvar Fragment = 10;\nvar Mode = 11;\nvar ContextConsumer = 12;\nvar ContextProvider = 13;\n\nfunction getParent(inst) {\n  do {\n    inst = inst[\"return\"];\n    // TODO: If this is a HostRoot we might want to bail out.\n    // That is depending on if we want nested subtrees (layers) to bubble\n    // events to their parent. We could also go through parentNode on the\n    // host node but that wouldn't work for React Native and doesn't let us\n    // do the portal feature.\n  } while (inst && inst.tag !== HostComponent);\n  if (inst) {\n    return inst;\n  }\n  return null;\n}\n\n/**\n * Return the lowest common ancestor of A and B, or null if they are in\n * different trees.\n */\nfunction getLowestCommonAncestor(instA, instB) {\n  var depthA = 0;\n  for (var tempA = instA; tempA; tempA = getParent(tempA)) {\n    depthA++;\n  }\n  var depthB = 0;\n  for (var tempB = instB; tempB; tempB = getParent(tempB)) {\n    depthB++;\n  }\n\n  // If A is deeper, crawl up.\n  while (depthA - depthB > 0) {\n    instA = getParent(instA);\n    depthA--;\n  }\n\n  // If B is deeper, crawl up.\n  while (depthB - depthA > 0) {\n    instB = getParent(instB);\n    depthB--;\n  }\n\n  // Walk in lockstep until we find a match.\n  var depth = depthA;\n  while (depth--) {\n    if (instA === instB || instA === instB.alternate) {\n      return instA;\n    }\n    instA = getParent(instA);\n    instB = getParent(instB);\n  }\n  return null;\n}\n\n/**\n * Return if A is an ancestor of B.\n */\nfunction isAncestor(instA, instB) {\n  while (instB) {\n    if (instA === instB || instA === instB.alternate) {\n      return true;\n    }\n    instB = getParent(instB);\n  }\n  return false;\n}\n\n/**\n * Return the parent instance of the passed-in instance.\n */\nfunction getParentInstance(inst) {\n  return getParent(inst);\n}\n\n/**\n * Simulates the traversal of a two-phase, capture/bubble event dispatch.\n */\nfunction traverseTwoPhase(inst, fn, arg) {\n  var path = [];\n  while (inst) {\n    path.push(inst);\n    inst = getParent(inst);\n  }\n  var i = void 0;\n  for (i = path.length; i-- > 0; ) {\n    fn(path[i], \"captured\", arg);\n  }\n  for (i = 0; i < path.length; i++) {\n    fn(path[i], \"bubbled\", arg);\n  }\n}\n\n/**\n * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that\n * should would receive a `mouseEnter` or `mouseLeave` event.\n *\n * Does not invoke the callback on the nearest common ancestor because nothing\n * \"entered\" or \"left\" that element.\n */\n\n/**\n * Some event types have a notion of different registration names for different\n * \"phases\" of propagation. This finds listeners by a given phase.\n */\nfunction listenerAtPhase(inst, event, propagationPhase) {\n  var registrationName =\n    event.dispatchConfig.phasedRegistrationNames[propagationPhase];\n  return getListener(inst, registrationName);\n}\n\n/**\n * A small set of propagation patterns, each of which will accept a small amount\n * of information, and generate a set of \"dispatch ready event objects\" - which\n * are sets of events that have already been annotated with a set of dispatched\n * listener functions/ids. The API is designed this way to discourage these\n * propagation strategies from actually executing the dispatches, since we\n * always want to collect the entire set of dispatches before executing even a\n * single one.\n */\n\n/**\n * Tags a `SyntheticEvent` with dispatched listeners. Creating this function\n * here, allows us to not have to bind or create functions for each event.\n * Mutating the event's members allows us to not have to create a wrapping\n * \"dispatch\" object that pairs the event with the listener.\n */\nfunction accumulateDirectionalDispatches(inst, phase, event) {\n  {\n    warning(inst, \"Dispatching inst must not be null\");\n  }\n  var listener = listenerAtPhase(inst, event, phase);\n  if (listener) {\n    event._dispatchListeners = accumulateInto(\n      event._dispatchListeners,\n      listener\n    );\n    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n  }\n}\n\n/**\n * Collect dispatches (must be entirely collected before dispatching - see unit\n * tests). Lazily allocate the array to conserve memory.  We must loop through\n * each event and perform the traversal for each one. We cannot perform a\n * single traversal for the entire collection of events because each event may\n * have a different target.\n */\nfunction accumulateTwoPhaseDispatchesSingle(event) {\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\n    traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);\n  }\n}\n\n/**\n * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.\n */\nfunction accumulateTwoPhaseDispatchesSingleSkipTarget(event) {\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\n    var targetInst = event._targetInst;\n    var parentInst = targetInst ? getParentInstance(targetInst) : null;\n    traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);\n  }\n}\n\n/**\n * Accumulates without regard to direction, does not look for phased\n * registration names. Same as `accumulateDirectDispatchesSingle` but without\n * requiring that the `dispatchMarker` be the same as the dispatched ID.\n */\nfunction accumulateDispatches(inst, ignoredDirection, event) {\n  if (inst && event && event.dispatchConfig.registrationName) {\n    var registrationName = event.dispatchConfig.registrationName;\n    var listener = getListener(inst, registrationName);\n    if (listener) {\n      event._dispatchListeners = accumulateInto(\n        event._dispatchListeners,\n        listener\n      );\n      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n    }\n  }\n}\n\n/**\n * Accumulates dispatches on an `SyntheticEvent`, but only for the\n * `dispatchMarker`.\n * @param {SyntheticEvent} event\n */\nfunction accumulateDirectDispatchesSingle(event) {\n  if (event && event.dispatchConfig.registrationName) {\n    accumulateDispatches(event._targetInst, null, event);\n  }\n}\n\nfunction accumulateTwoPhaseDispatches(events) {\n  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);\n}\n\nfunction accumulateTwoPhaseDispatchesSkipTarget(events) {\n  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);\n}\n\nfunction accumulateDirectDispatches(events) {\n  forEachAccumulated(events, accumulateDirectDispatchesSingle);\n}\n\n/* eslint valid-typeof: 0 */\n\nvar didWarnForAddedNewProperty = false;\nvar EVENT_POOL_SIZE = 10;\n\nvar shouldBeReleasedProperties = [\n  \"dispatchConfig\",\n  \"_targetInst\",\n  \"nativeEvent\",\n  \"isDefaultPrevented\",\n  \"isPropagationStopped\",\n  \"_dispatchListeners\",\n  \"_dispatchInstances\"\n];\n\n/**\n * @interface Event\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar EventInterface = {\n  type: null,\n  target: null,\n  // currentTarget is set when dispatching; no use in copying it here\n  currentTarget: emptyFunction.thatReturnsNull,\n  eventPhase: null,\n  bubbles: null,\n  cancelable: null,\n  timeStamp: function(event) {\n    return event.timeStamp || Date.now();\n  },\n  defaultPrevented: null,\n  isTrusted: null\n};\n\n/**\n * Synthetic events are dispatched by event plugins, typically in response to a\n * top-level event delegation handler.\n *\n * These systems should generally use pooling to reduce the frequency of garbage\n * collection. The system should check `isPersistent` to determine whether the\n * event should be released into the pool after being dispatched. Users that\n * need a persisted event should invoke `persist`.\n *\n * Synthetic events (and subclasses) implement the DOM Level 3 Events API by\n * normalizing browser quirks. Subclasses do not necessarily have to implement a\n * DOM interface; custom application-specific events can also subclass this.\n *\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {*} targetInst Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @param {DOMEventTarget} nativeEventTarget Target node.\n */\nfunction SyntheticEvent(\n  dispatchConfig,\n  targetInst,\n  nativeEvent,\n  nativeEventTarget\n) {\n  {\n    // these have a getter/setter for warnings\n    delete this.nativeEvent;\n    delete this.preventDefault;\n    delete this.stopPropagation;\n  }\n\n  this.dispatchConfig = dispatchConfig;\n  this._targetInst = targetInst;\n  this.nativeEvent = nativeEvent;\n\n  var Interface = this.constructor.Interface;\n  for (var propName in Interface) {\n    if (!Interface.hasOwnProperty(propName)) {\n      continue;\n    }\n    {\n      delete this[propName]; // this has a getter/setter for warnings\n    }\n    var normalize = Interface[propName];\n    if (normalize) {\n      this[propName] = normalize(nativeEvent);\n    } else {\n      if (propName === \"target\") {\n        this.target = nativeEventTarget;\n      } else {\n        this[propName] = nativeEvent[propName];\n      }\n    }\n  }\n\n  var defaultPrevented =\n    nativeEvent.defaultPrevented != null\n      ? nativeEvent.defaultPrevented\n      : nativeEvent.returnValue === false;\n  if (defaultPrevented) {\n    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;\n  } else {\n    this.isDefaultPrevented = emptyFunction.thatReturnsFalse;\n  }\n  this.isPropagationStopped = emptyFunction.thatReturnsFalse;\n  return this;\n}\n\nObject.assign(SyntheticEvent.prototype, {\n  preventDefault: function() {\n    this.defaultPrevented = true;\n    var event = this.nativeEvent;\n    if (!event) {\n      return;\n    }\n\n    if (event.preventDefault) {\n      event.preventDefault();\n    } else if (typeof event.returnValue !== \"unknown\") {\n      event.returnValue = false;\n    }\n    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;\n  },\n\n  stopPropagation: function() {\n    var event = this.nativeEvent;\n    if (!event) {\n      return;\n    }\n\n    if (event.stopPropagation) {\n      event.stopPropagation();\n    } else if (typeof event.cancelBubble !== \"unknown\") {\n      // The ChangeEventPlugin registers a \"propertychange\" event for\n      // IE. This event does not support bubbling or cancelling, and\n      // any references to cancelBubble throw \"Member not found\".  A\n      // typeof check of \"unknown\" circumvents this issue (and is also\n      // IE specific).\n      event.cancelBubble = true;\n    }\n\n    this.isPropagationStopped = emptyFunction.thatReturnsTrue;\n  },\n\n  /**\n   * We release all dispatched `SyntheticEvent`s after each event loop, adding\n   * them back into the pool. This allows a way to hold onto a reference that\n   * won't be added back into the pool.\n   */\n  persist: function() {\n    this.isPersistent = emptyFunction.thatReturnsTrue;\n  },\n\n  /**\n   * Checks if this event should be released back into the pool.\n   *\n   * @return {boolean} True if this should not be released, false otherwise.\n   */\n  isPersistent: emptyFunction.thatReturnsFalse,\n\n  /**\n   * `PooledClass` looks for `destructor` on each instance it releases.\n   */\n  destructor: function() {\n    var Interface = this.constructor.Interface;\n    for (var propName in Interface) {\n      {\n        Object.defineProperty(\n          this,\n          propName,\n          getPooledWarningPropertyDefinition(propName, Interface[propName])\n        );\n      }\n    }\n    for (var i = 0; i < shouldBeReleasedProperties.length; i++) {\n      this[shouldBeReleasedProperties[i]] = null;\n    }\n    {\n      Object.defineProperty(\n        this,\n        \"nativeEvent\",\n        getPooledWarningPropertyDefinition(\"nativeEvent\", null)\n      );\n      Object.defineProperty(\n        this,\n        \"preventDefault\",\n        getPooledWarningPropertyDefinition(\"preventDefault\", emptyFunction)\n      );\n      Object.defineProperty(\n        this,\n        \"stopPropagation\",\n        getPooledWarningPropertyDefinition(\"stopPropagation\", emptyFunction)\n      );\n    }\n  }\n});\n\nSyntheticEvent.Interface = EventInterface;\n\n/**\n * Helper to reduce boilerplate when creating subclasses.\n */\nSyntheticEvent.extend = function(Interface) {\n  var Super = this;\n\n  var E = function() {};\n  E.prototype = Super.prototype;\n  var prototype = new E();\n\n  function Class() {\n    return Super.apply(this, arguments);\n  }\n  Object.assign(prototype, Class.prototype);\n  Class.prototype = prototype;\n  Class.prototype.constructor = Class;\n\n  Class.Interface = Object.assign({}, Super.Interface, Interface);\n  Class.extend = Super.extend;\n  addEventPoolingTo(Class);\n\n  return Class;\n};\n\n/** Proxying after everything set on SyntheticEvent\n * to resolve Proxy issue on some WebKit browsers\n * in which some Event properties are set to undefined (GH#10010)\n */\n{\n  var isProxySupported =\n    typeof Proxy === \"function\" &&\n    // https://github.com/facebook/react/issues/12011\n    !Object.isSealed(new Proxy({}, {}));\n\n  if (isProxySupported) {\n    /*eslint-disable no-func-assign */\n    SyntheticEvent = new Proxy(SyntheticEvent, {\n      construct: function(target, args) {\n        return this.apply(target, Object.create(target.prototype), args);\n      },\n      apply: function(constructor, that, args) {\n        return new Proxy(constructor.apply(that, args), {\n          set: function(target, prop, value) {\n            if (\n              prop !== \"isPersistent\" &&\n              !target.constructor.Interface.hasOwnProperty(prop) &&\n              shouldBeReleasedProperties.indexOf(prop) === -1\n            ) {\n              warning(\n                didWarnForAddedNewProperty || target.isPersistent(),\n                \"This synthetic event is reused for performance reasons. If you're \" +\n                  \"seeing this, you're adding a new property in the synthetic event object. \" +\n                  \"The property is never released. See \" +\n                  \"https://fb.me/react-event-pooling for more information.\"\n              );\n              didWarnForAddedNewProperty = true;\n            }\n            target[prop] = value;\n            return true;\n          }\n        });\n      }\n    });\n    /*eslint-enable no-func-assign */\n  }\n}\n\naddEventPoolingTo(SyntheticEvent);\n\n/**\n * Helper to nullify syntheticEvent instance properties when destructing\n *\n * @param {String} propName\n * @param {?object} getVal\n * @return {object} defineProperty object\n */\nfunction getPooledWarningPropertyDefinition(propName, getVal) {\n  var isFunction = typeof getVal === \"function\";\n  return {\n    configurable: true,\n    set: set,\n    get: get\n  };\n\n  function set(val) {\n    var action = isFunction ? \"setting the method\" : \"setting the property\";\n    warn(action, \"This is effectively a no-op\");\n    return val;\n  }\n\n  function get() {\n    var action = isFunction ? \"accessing the method\" : \"accessing the property\";\n    var result = isFunction\n      ? \"This is a no-op function\"\n      : \"This is set to null\";\n    warn(action, result);\n    return getVal;\n  }\n\n  function warn(action, result) {\n    var warningCondition = false;\n    warning(\n      warningCondition,\n      \"This synthetic event is reused for performance reasons. If you're seeing this, \" +\n        \"you're %s `%s` on a released/nullified synthetic event. %s. \" +\n        \"If you must keep the original synthetic event around, use event.persist(). \" +\n        \"See https://fb.me/react-event-pooling for more information.\",\n      action,\n      propName,\n      result\n    );\n  }\n}\n\nfunction getPooledEvent(dispatchConfig, targetInst, nativeEvent, nativeInst) {\n  var EventConstructor = this;\n  if (EventConstructor.eventPool.length) {\n    var instance = EventConstructor.eventPool.pop();\n    EventConstructor.call(\n      instance,\n      dispatchConfig,\n      targetInst,\n      nativeEvent,\n      nativeInst\n    );\n    return instance;\n  }\n  return new EventConstructor(\n    dispatchConfig,\n    targetInst,\n    nativeEvent,\n    nativeInst\n  );\n}\n\nfunction releasePooledEvent(event) {\n  var EventConstructor = this;\n  invariant(\n    event instanceof EventConstructor,\n    \"Trying to release an event instance  into a pool of a different type.\"\n  );\n  event.destructor();\n  if (EventConstructor.eventPool.length < EVENT_POOL_SIZE) {\n    EventConstructor.eventPool.push(event);\n  }\n}\n\nfunction addEventPoolingTo(EventConstructor) {\n  EventConstructor.eventPool = [];\n  EventConstructor.getPooled = getPooledEvent;\n  EventConstructor.release = releasePooledEvent;\n}\n\nvar SyntheticEvent$1 = SyntheticEvent;\n\n/**\n * `touchHistory` isn't actually on the native event, but putting it in the\n * interface will ensure that it is cleaned up when pooled/destroyed. The\n * `ResponderEventPlugin` will populate it appropriately.\n */\nvar ResponderSyntheticEvent = SyntheticEvent$1.extend({\n  touchHistory: function(nativeEvent) {\n    return null; // Actually doesn't even look at the native event.\n  }\n});\n\n/**\n * Tracks the position and time of each active touch by `touch.identifier`. We\n * should typically only see IDs in the range of 1-20 because IDs get recycled\n * when touches end and start again.\n */\n\nvar MAX_TOUCH_BANK = 20;\nvar touchBank = [];\nvar touchHistory = {\n  touchBank: touchBank,\n  numberActiveTouches: 0,\n  // If there is only one active touch, we remember its location. This prevents\n  // us having to loop through all of the touches all the time in the most\n  // common case.\n  indexOfSingleActiveTouch: -1,\n  mostRecentTimeStamp: 0\n};\n\nfunction timestampForTouch(touch) {\n  // The legacy internal implementation provides \"timeStamp\", which has been\n  // renamed to \"timestamp\". Let both work for now while we iron it out\n  // TODO (evv): rename timeStamp to timestamp in internal code\n  return touch.timeStamp || touch.timestamp;\n}\n\n/**\n * TODO: Instead of making gestures recompute filtered velocity, we could\n * include a built in velocity computation that can be reused globally.\n */\nfunction createTouchRecord(touch) {\n  return {\n    touchActive: true,\n    startPageX: touch.pageX,\n    startPageY: touch.pageY,\n    startTimeStamp: timestampForTouch(touch),\n    currentPageX: touch.pageX,\n    currentPageY: touch.pageY,\n    currentTimeStamp: timestampForTouch(touch),\n    previousPageX: touch.pageX,\n    previousPageY: touch.pageY,\n    previousTimeStamp: timestampForTouch(touch)\n  };\n}\n\nfunction resetTouchRecord(touchRecord, touch) {\n  touchRecord.touchActive = true;\n  touchRecord.startPageX = touch.pageX;\n  touchRecord.startPageY = touch.pageY;\n  touchRecord.startTimeStamp = timestampForTouch(touch);\n  touchRecord.currentPageX = touch.pageX;\n  touchRecord.currentPageY = touch.pageY;\n  touchRecord.currentTimeStamp = timestampForTouch(touch);\n  touchRecord.previousPageX = touch.pageX;\n  touchRecord.previousPageY = touch.pageY;\n  touchRecord.previousTimeStamp = timestampForTouch(touch);\n}\n\nfunction getTouchIdentifier(_ref) {\n  var identifier = _ref.identifier;\n\n  invariant(identifier != null, \"Touch object is missing identifier.\");\n  {\n    warning(\n      identifier <= MAX_TOUCH_BANK,\n      \"Touch identifier %s is greater than maximum supported %s which causes \" +\n        \"performance issues backfilling array locations for all of the indices.\",\n      identifier,\n      MAX_TOUCH_BANK\n    );\n  }\n  return identifier;\n}\n\nfunction recordTouchStart(touch) {\n  var identifier = getTouchIdentifier(touch);\n  var touchRecord = touchBank[identifier];\n  if (touchRecord) {\n    resetTouchRecord(touchRecord, touch);\n  } else {\n    touchBank[identifier] = createTouchRecord(touch);\n  }\n  touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n}\n\nfunction recordTouchMove(touch) {\n  var touchRecord = touchBank[getTouchIdentifier(touch)];\n  if (touchRecord) {\n    touchRecord.touchActive = true;\n    touchRecord.previousPageX = touchRecord.currentPageX;\n    touchRecord.previousPageY = touchRecord.currentPageY;\n    touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;\n    touchRecord.currentPageX = touch.pageX;\n    touchRecord.currentPageY = touch.pageY;\n    touchRecord.currentTimeStamp = timestampForTouch(touch);\n    touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n  } else {\n    console.error(\n      \"Cannot record touch move without a touch start.\\n\" + \"Touch Move: %s\\n\",\n      \"Touch Bank: %s\",\n      printTouch(touch),\n      printTouchBank()\n    );\n  }\n}\n\nfunction recordTouchEnd(touch) {\n  var touchRecord = touchBank[getTouchIdentifier(touch)];\n  if (touchRecord) {\n    touchRecord.touchActive = false;\n    touchRecord.previousPageX = touchRecord.currentPageX;\n    touchRecord.previousPageY = touchRecord.currentPageY;\n    touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;\n    touchRecord.currentPageX = touch.pageX;\n    touchRecord.currentPageY = touch.pageY;\n    touchRecord.currentTimeStamp = timestampForTouch(touch);\n    touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n  } else {\n    console.error(\n      \"Cannot record touch end without a touch start.\\n\" + \"Touch End: %s\\n\",\n      \"Touch Bank: %s\",\n      printTouch(touch),\n      printTouchBank()\n    );\n  }\n}\n\nfunction printTouch(touch) {\n  return JSON.stringify({\n    identifier: touch.identifier,\n    pageX: touch.pageX,\n    pageY: touch.pageY,\n    timestamp: timestampForTouch(touch)\n  });\n}\n\nfunction printTouchBank() {\n  var printed = JSON.stringify(touchBank.slice(0, MAX_TOUCH_BANK));\n  if (touchBank.length > MAX_TOUCH_BANK) {\n    printed += \" (original size: \" + touchBank.length + \")\";\n  }\n  return printed;\n}\n\nvar ResponderTouchHistoryStore = {\n  recordTouchTrack: function(topLevelType, nativeEvent) {\n    if (isMoveish(topLevelType)) {\n      nativeEvent.changedTouches.forEach(recordTouchMove);\n    } else if (isStartish(topLevelType)) {\n      nativeEvent.changedTouches.forEach(recordTouchStart);\n      touchHistory.numberActiveTouches = nativeEvent.touches.length;\n      if (touchHistory.numberActiveTouches === 1) {\n        touchHistory.indexOfSingleActiveTouch =\n          nativeEvent.touches[0].identifier;\n      }\n    } else if (isEndish(topLevelType)) {\n      nativeEvent.changedTouches.forEach(recordTouchEnd);\n      touchHistory.numberActiveTouches = nativeEvent.touches.length;\n      if (touchHistory.numberActiveTouches === 1) {\n        for (var i = 0; i < touchBank.length; i++) {\n          var touchTrackToCheck = touchBank[i];\n          if (touchTrackToCheck != null && touchTrackToCheck.touchActive) {\n            touchHistory.indexOfSingleActiveTouch = i;\n            break;\n          }\n        }\n        {\n          var activeRecord = touchBank[touchHistory.indexOfSingleActiveTouch];\n          warning(\n            activeRecord != null && activeRecord.touchActive,\n            \"Cannot find single active touch.\"\n          );\n        }\n      }\n    }\n  },\n\n  touchHistory: touchHistory\n};\n\n/**\n * Accumulates items that must not be null or undefined.\n *\n * This is used to conserve memory by avoiding array allocations.\n *\n * @return {*|array<*>} An accumulation of items.\n */\nfunction accumulate(current, next) {\n  invariant(\n    next != null,\n    \"accumulate(...): Accumulated items must be not be null or undefined.\"\n  );\n\n  if (current == null) {\n    return next;\n  }\n\n  // Both are not empty. Warning: Never call x.concat(y) when you are not\n  // certain that x is an Array (x could be a string with concat method).\n  if (Array.isArray(current)) {\n    return current.concat(next);\n  }\n\n  if (Array.isArray(next)) {\n    return [current].concat(next);\n  }\n\n  return [current, next];\n}\n\n/**\n * Instance of element that should respond to touch/move types of interactions,\n * as indicated explicitly by relevant callbacks.\n */\nvar responderInst = null;\n\n/**\n * Count of current touches. A textInput should become responder iff the\n * selection changes while there is a touch on the screen.\n */\nvar trackedTouchCount = 0;\n\n/**\n * Last reported number of active touches.\n */\nvar previousActiveTouches = 0;\n\nvar changeResponder = function(nextResponderInst, blockHostResponder) {\n  var oldResponderInst = responderInst;\n  responderInst = nextResponderInst;\n  if (ResponderEventPlugin.GlobalResponderHandler !== null) {\n    ResponderEventPlugin.GlobalResponderHandler.onChange(\n      oldResponderInst,\n      nextResponderInst,\n      blockHostResponder\n    );\n  }\n};\n\nvar eventTypes = {\n  /**\n   * On a `touchStart`/`mouseDown`, is it desired that this element become the\n   * responder?\n   */\n  startShouldSetResponder: {\n    phasedRegistrationNames: {\n      bubbled: \"onStartShouldSetResponder\",\n      captured: \"onStartShouldSetResponderCapture\"\n    }\n  },\n\n  /**\n   * On a `scroll`, is it desired that this element become the responder? This\n   * is usually not needed, but should be used to retroactively infer that a\n   * `touchStart` had occurred during momentum scroll. During a momentum scroll,\n   * a touch start will be immediately followed by a scroll event if the view is\n   * currently scrolling.\n   *\n   * TODO: This shouldn't bubble.\n   */\n  scrollShouldSetResponder: {\n    phasedRegistrationNames: {\n      bubbled: \"onScrollShouldSetResponder\",\n      captured: \"onScrollShouldSetResponderCapture\"\n    }\n  },\n\n  /**\n   * On text selection change, should this element become the responder? This\n   * is needed for text inputs or other views with native selection, so the\n   * JS view can claim the responder.\n   *\n   * TODO: This shouldn't bubble.\n   */\n  selectionChangeShouldSetResponder: {\n    phasedRegistrationNames: {\n      bubbled: \"onSelectionChangeShouldSetResponder\",\n      captured: \"onSelectionChangeShouldSetResponderCapture\"\n    }\n  },\n\n  /**\n   * On a `touchMove`/`mouseMove`, is it desired that this element become the\n   * responder?\n   */\n  moveShouldSetResponder: {\n    phasedRegistrationNames: {\n      bubbled: \"onMoveShouldSetResponder\",\n      captured: \"onMoveShouldSetResponderCapture\"\n    }\n  },\n\n  /**\n   * Direct responder events dispatched directly to responder. Do not bubble.\n   */\n  responderStart: { registrationName: \"onResponderStart\" },\n  responderMove: { registrationName: \"onResponderMove\" },\n  responderEnd: { registrationName: \"onResponderEnd\" },\n  responderRelease: { registrationName: \"onResponderRelease\" },\n  responderTerminationRequest: {\n    registrationName: \"onResponderTerminationRequest\"\n  },\n  responderGrant: { registrationName: \"onResponderGrant\" },\n  responderReject: { registrationName: \"onResponderReject\" },\n  responderTerminate: { registrationName: \"onResponderTerminate\" }\n};\n\n/**\n *\n * Responder System:\n * ----------------\n *\n * - A global, solitary \"interaction lock\" on a view.\n * - If a node becomes the responder, it should convey visual feedback\n *   immediately to indicate so, either by highlighting or moving accordingly.\n * - To be the responder means, that touches are exclusively important to that\n *   responder view, and no other view.\n * - While touches are still occurring, the responder lock can be transferred to\n *   a new view, but only to increasingly \"higher\" views (meaning ancestors of\n *   the current responder).\n *\n * Responder being granted:\n * ------------------------\n *\n * - Touch starts, moves, and scrolls can cause an ID to become the responder.\n * - We capture/bubble `startShouldSetResponder`/`moveShouldSetResponder` to\n *   the \"appropriate place\".\n * - If nothing is currently the responder, the \"appropriate place\" is the\n *   initiating event's `targetID`.\n * - If something *is* already the responder, the \"appropriate place\" is the\n *   first common ancestor of the event target and the current `responderInst`.\n * - Some negotiation happens: See the timing diagram below.\n * - Scrolled views automatically become responder. The reasoning is that a\n *   platform scroll view that isn't built on top of the responder system has\n *   began scrolling, and the active responder must now be notified that the\n *   interaction is no longer locked to it - the system has taken over.\n *\n * - Responder being released:\n *   As soon as no more touches that *started* inside of descendants of the\n *   *current* responderInst, an `onResponderRelease` event is dispatched to the\n *   current responder, and the responder lock is released.\n *\n * TODO:\n * - on \"end\", a callback hook for `onResponderEndShouldRemainResponder` that\n *   determines if the responder lock should remain.\n * - If a view shouldn't \"remain\" the responder, any active touches should by\n *   default be considered \"dead\" and do not influence future negotiations or\n *   bubble paths. It should be as if those touches do not exist.\n * -- For multitouch: Usually a translate-z will choose to \"remain\" responder\n *  after one out of many touches ended. For translate-y, usually the view\n *  doesn't wish to \"remain\" responder after one of many touches end.\n * - Consider building this on top of a `stopPropagation` model similar to\n *   `W3C` events.\n * - Ensure that `onResponderTerminate` is called on touch cancels, whether or\n *   not `onResponderTerminationRequest` returns `true` or `false`.\n *\n */\n\n/*                                             Negotiation Performed\n                                             +-----------------------+\n                                            /                         \\\nProcess low level events to    +     Current Responder      +   wantsResponderID\ndetermine who to perform negot-|   (if any exists at all)   |\niation/transition              | Otherwise just pass through|\n-------------------------------+----------------------------+------------------+\nBubble to find first ID        |                            |\nto return true:wantsResponderID|                            |\n                               |                            |\n     +-------------+           |                            |\n     | onTouchStart|           |                            |\n     +------+------+     none  |                            |\n            |            return|                            |\n+-----------v-------------+true| +------------------------+ |\n|onStartShouldSetResponder|----->|onResponderStart (cur)  |<-----------+\n+-----------+-------------+    | +------------------------+ |          |\n            |                  |                            | +--------+-------+\n            | returned true for|       false:REJECT +-------->|onResponderReject\n            | wantsResponderID |                    |       | +----------------+\n            | (now attempt     | +------------------+-----+ |\n            |  handoff)        | |   onResponder          | |\n            +------------------->|      TerminationRequest| |\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |         true:GRANT +-------->|onResponderGrant|\n                               |                            | +--------+-------+\n                               | +------------------------+ |          |\n                               | |   onResponderTerminate |<-----------+\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |                    +-------->|onResponderStart|\n                               |                            | +----------------+\nBubble to find first ID        |                            |\nto return true:wantsResponderID|                            |\n                               |                            |\n     +-------------+           |                            |\n     | onTouchMove |           |                            |\n     +------+------+     none  |                            |\n            |            return|                            |\n+-----------v-------------+true| +------------------------+ |\n|onMoveShouldSetResponder |----->|onResponderMove (cur)   |<-----------+\n+-----------+-------------+    | +------------------------+ |          |\n            |                  |                            | +--------+-------+\n            | returned true for|       false:REJECT +-------->|onResponderRejec|\n            | wantsResponderID |                    |       | +----------------+\n            | (now attempt     | +------------------+-----+ |\n            |  handoff)        | |   onResponder          | |\n            +------------------->|      TerminationRequest| |\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |         true:GRANT +-------->|onResponderGrant|\n                               |                            | +--------+-------+\n                               | +------------------------+ |          |\n                               | |   onResponderTerminate |<-----------+\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |                    +-------->|onResponderMove |\n                               |                            | +----------------+\n                               |                            |\n                               |                            |\n      Some active touch started|                            |\n      inside current responder | +------------------------+ |\n      +------------------------->|      onResponderEnd    | |\n      |                        | +------------------------+ |\n  +---+---------+              |                            |\n  | onTouchEnd  |              |                            |\n  +---+---------+              |                            |\n      |                        | +------------------------+ |\n      +------------------------->|     onResponderEnd     | |\n      No active touches started| +-----------+------------+ |\n      inside current responder |             |              |\n                               |             v              |\n                               | +------------------------+ |\n                               | |    onResponderRelease  | |\n                               | +------------------------+ |\n                               |                            |\n                               +                            + */\n\n/**\n * A note about event ordering in the `EventPluginHub`.\n *\n * Suppose plugins are injected in the following order:\n *\n * `[R, S, C]`\n *\n * To help illustrate the example, assume `S` is `SimpleEventPlugin` (for\n * `onClick` etc) and `R` is `ResponderEventPlugin`.\n *\n * \"Deferred-Dispatched Events\":\n *\n * - The current event plugin system will traverse the list of injected plugins,\n *   in order, and extract events by collecting the plugin's return value of\n *   `extractEvents()`.\n * - These events that are returned from `extractEvents` are \"deferred\n *   dispatched events\".\n * - When returned from `extractEvents`, deferred-dispatched events contain an\n *   \"accumulation\" of deferred dispatches.\n * - These deferred dispatches are accumulated/collected before they are\n *   returned, but processed at a later time by the `EventPluginHub` (hence the\n *   name deferred).\n *\n * In the process of returning their deferred-dispatched events, event plugins\n * themselves can dispatch events on-demand without returning them from\n * `extractEvents`. Plugins might want to do this, so that they can use event\n * dispatching as a tool that helps them decide which events should be extracted\n * in the first place.\n *\n * \"On-Demand-Dispatched Events\":\n *\n * - On-demand-dispatched events are not returned from `extractEvents`.\n * - On-demand-dispatched events are dispatched during the process of returning\n *   the deferred-dispatched events.\n * - They should not have side effects.\n * - They should be avoided, and/or eventually be replaced with another\n *   abstraction that allows event plugins to perform multiple \"rounds\" of event\n *   extraction.\n *\n * Therefore, the sequence of event dispatches becomes:\n *\n * - `R`s on-demand events (if any)   (dispatched by `R` on-demand)\n * - `S`s on-demand events (if any)   (dispatched by `S` on-demand)\n * - `C`s on-demand events (if any)   (dispatched by `C` on-demand)\n * - `R`s extracted events (if any)   (dispatched by `EventPluginHub`)\n * - `S`s extracted events (if any)   (dispatched by `EventPluginHub`)\n * - `C`s extracted events (if any)   (dispatched by `EventPluginHub`)\n *\n * In the case of `ResponderEventPlugin`: If the `startShouldSetResponder`\n * on-demand dispatch returns `true` (and some other details are satisfied) the\n * `onResponderGrant` deferred dispatched event is returned from\n * `extractEvents`. The sequence of dispatch executions in this case\n * will appear as follows:\n *\n * - `startShouldSetResponder` (`ResponderEventPlugin` dispatches on-demand)\n * - `touchStartCapture`       (`EventPluginHub` dispatches as usual)\n * - `touchStart`              (`EventPluginHub` dispatches as usual)\n * - `responderGrant/Reject`   (`EventPluginHub` dispatches as usual)\n */\n\nfunction setResponderAndExtractTransfer(\n  topLevelType,\n  targetInst,\n  nativeEvent,\n  nativeEventTarget\n) {\n  var shouldSetEventType = isStartish(topLevelType)\n    ? eventTypes.startShouldSetResponder\n    : isMoveish(topLevelType)\n      ? eventTypes.moveShouldSetResponder\n      : topLevelType === \"topSelectionChange\"\n        ? eventTypes.selectionChangeShouldSetResponder\n        : eventTypes.scrollShouldSetResponder;\n\n  // TODO: stop one short of the current responder.\n  var bubbleShouldSetFrom = !responderInst\n    ? targetInst\n    : getLowestCommonAncestor(responderInst, targetInst);\n\n  // When capturing/bubbling the \"shouldSet\" event, we want to skip the target\n  // (deepest ID) if it happens to be the current responder. The reasoning:\n  // It's strange to get an `onMoveShouldSetResponder` when you're *already*\n  // the responder.\n  var skipOverBubbleShouldSetFrom = bubbleShouldSetFrom === responderInst;\n  var shouldSetEvent = ResponderSyntheticEvent.getPooled(\n    shouldSetEventType,\n    bubbleShouldSetFrom,\n    nativeEvent,\n    nativeEventTarget\n  );\n  shouldSetEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n  if (skipOverBubbleShouldSetFrom) {\n    accumulateTwoPhaseDispatchesSkipTarget(shouldSetEvent);\n  } else {\n    accumulateTwoPhaseDispatches(shouldSetEvent);\n  }\n  var wantsResponderInst = executeDispatchesInOrderStopAtTrue(shouldSetEvent);\n  if (!shouldSetEvent.isPersistent()) {\n    shouldSetEvent.constructor.release(shouldSetEvent);\n  }\n\n  if (!wantsResponderInst || wantsResponderInst === responderInst) {\n    return null;\n  }\n  var extracted = void 0;\n  var grantEvent = ResponderSyntheticEvent.getPooled(\n    eventTypes.responderGrant,\n    wantsResponderInst,\n    nativeEvent,\n    nativeEventTarget\n  );\n  grantEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n\n  accumulateDirectDispatches(grantEvent);\n  var blockHostResponder = executeDirectDispatch(grantEvent) === true;\n  if (responderInst) {\n    var terminationRequestEvent = ResponderSyntheticEvent.getPooled(\n      eventTypes.responderTerminationRequest,\n      responderInst,\n      nativeEvent,\n      nativeEventTarget\n    );\n    terminationRequestEvent.touchHistory =\n      ResponderTouchHistoryStore.touchHistory;\n    accumulateDirectDispatches(terminationRequestEvent);\n    var shouldSwitch =\n      !hasDispatches(terminationRequestEvent) ||\n      executeDirectDispatch(terminationRequestEvent);\n    if (!terminationRequestEvent.isPersistent()) {\n      terminationRequestEvent.constructor.release(terminationRequestEvent);\n    }\n\n    if (shouldSwitch) {\n      var terminateEvent = ResponderSyntheticEvent.getPooled(\n        eventTypes.responderTerminate,\n        responderInst,\n        nativeEvent,\n        nativeEventTarget\n      );\n      terminateEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n      accumulateDirectDispatches(terminateEvent);\n      extracted = accumulate(extracted, [grantEvent, terminateEvent]);\n      changeResponder(wantsResponderInst, blockHostResponder);\n    } else {\n      var rejectEvent = ResponderSyntheticEvent.getPooled(\n        eventTypes.responderReject,\n        wantsResponderInst,\n        nativeEvent,\n        nativeEventTarget\n      );\n      rejectEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n      accumulateDirectDispatches(rejectEvent);\n      extracted = accumulate(extracted, rejectEvent);\n    }\n  } else {\n    extracted = accumulate(extracted, grantEvent);\n    changeResponder(wantsResponderInst, blockHostResponder);\n  }\n  return extracted;\n}\n\n/**\n * A transfer is a negotiation between a currently set responder and the next\n * element to claim responder status. Any start event could trigger a transfer\n * of responderInst. Any move event could trigger a transfer.\n *\n * @param {string} topLevelType Record from `BrowserEventConstants`.\n * @return {boolean} True if a transfer of responder could possibly occur.\n */\nfunction canTriggerTransfer(topLevelType, topLevelInst, nativeEvent) {\n  return (\n    topLevelInst &&\n    // responderIgnoreScroll: We are trying to migrate away from specifically\n    // tracking native scroll events here and responderIgnoreScroll indicates we\n    // will send topTouchCancel to handle canceling touch events instead\n    ((topLevelType === \"topScroll\" && !nativeEvent.responderIgnoreScroll) ||\n      (trackedTouchCount > 0 && topLevelType === \"topSelectionChange\") ||\n      isStartish(topLevelType) ||\n      isMoveish(topLevelType))\n  );\n}\n\n/**\n * Returns whether or not this touch end event makes it such that there are no\n * longer any touches that started inside of the current `responderInst`.\n *\n * @param {NativeEvent} nativeEvent Native touch end event.\n * @return {boolean} Whether or not this touch end event ends the responder.\n */\nfunction noResponderTouches(nativeEvent) {\n  var touches = nativeEvent.touches;\n  if (!touches || touches.length === 0) {\n    return true;\n  }\n  for (var i = 0; i < touches.length; i++) {\n    var activeTouch = touches[i];\n    var target = activeTouch.target;\n    if (target !== null && target !== undefined && target !== 0) {\n      // Is the original touch location inside of the current responder?\n      var targetInst = getInstanceFromNode(target);\n      if (isAncestor(responderInst, targetInst)) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nvar ResponderEventPlugin = {\n  /* For unit testing only */\n  _getResponder: function() {\n    return responderInst;\n  },\n\n  eventTypes: eventTypes,\n\n  /**\n   * We must be resilient to `targetInst` being `null` on `touchMove` or\n   * `touchEnd`. On certain platforms, this means that a native scroll has\n   * assumed control and the original touch targets are destroyed.\n   */\n  extractEvents: function(\n    topLevelType,\n    targetInst,\n    nativeEvent,\n    nativeEventTarget\n  ) {\n    if (isStartish(topLevelType)) {\n      trackedTouchCount += 1;\n    } else if (isEndish(topLevelType)) {\n      if (trackedTouchCount >= 0) {\n        trackedTouchCount -= 1;\n      } else {\n        console.error(\n          \"Ended a touch event which was not counted in `trackedTouchCount`.\"\n        );\n        return null;\n      }\n    }\n\n    ResponderTouchHistoryStore.recordTouchTrack(topLevelType, nativeEvent);\n\n    var extracted = canTriggerTransfer(topLevelType, targetInst, nativeEvent)\n      ? setResponderAndExtractTransfer(\n          topLevelType,\n          targetInst,\n          nativeEvent,\n          nativeEventTarget\n        )\n      : null;\n    // Responder may or may not have transferred on a new touch start/move.\n    // Regardless, whoever is the responder after any potential transfer, we\n    // direct all touch start/move/ends to them in the form of\n    // `onResponderMove/Start/End`. These will be called for *every* additional\n    // finger that move/start/end, dispatched directly to whoever is the\n    // current responder at that moment, until the responder is \"released\".\n    //\n    // These multiple individual change touch events are are always bookended\n    // by `onResponderGrant`, and one of\n    // (`onResponderRelease/onResponderTerminate`).\n    var isResponderTouchStart = responderInst && isStartish(topLevelType);\n    var isResponderTouchMove = responderInst && isMoveish(topLevelType);\n    var isResponderTouchEnd = responderInst && isEndish(topLevelType);\n    var incrementalTouch = isResponderTouchStart\n      ? eventTypes.responderStart\n      : isResponderTouchMove\n        ? eventTypes.responderMove\n        : isResponderTouchEnd ? eventTypes.responderEnd : null;\n\n    if (incrementalTouch) {\n      var gesture = ResponderSyntheticEvent.getPooled(\n        incrementalTouch,\n        responderInst,\n        nativeEvent,\n        nativeEventTarget\n      );\n      gesture.touchHistory = ResponderTouchHistoryStore.touchHistory;\n      accumulateDirectDispatches(gesture);\n      extracted = accumulate(extracted, gesture);\n    }\n\n    var isResponderTerminate =\n      responderInst && topLevelType === \"topTouchCancel\";\n    var isResponderRelease =\n      responderInst &&\n      !isResponderTerminate &&\n      isEndish(topLevelType) &&\n      noResponderTouches(nativeEvent);\n    var finalTouch = isResponderTerminate\n      ? eventTypes.responderTerminate\n      : isResponderRelease ? eventTypes.responderRelease : null;\n    if (finalTouch) {\n      var finalEvent = ResponderSyntheticEvent.getPooled(\n        finalTouch,\n        responderInst,\n        nativeEvent,\n        nativeEventTarget\n      );\n      finalEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n      accumulateDirectDispatches(finalEvent);\n      extracted = accumulate(extracted, finalEvent);\n      changeResponder(null);\n    }\n\n    var numberActiveTouches =\n      ResponderTouchHistoryStore.touchHistory.numberActiveTouches;\n    if (\n      ResponderEventPlugin.GlobalInteractionHandler &&\n      numberActiveTouches !== previousActiveTouches\n    ) {\n      ResponderEventPlugin.GlobalInteractionHandler.onChange(\n        numberActiveTouches\n      );\n    }\n    previousActiveTouches = numberActiveTouches;\n\n    return extracted;\n  },\n\n  GlobalResponderHandler: null,\n  GlobalInteractionHandler: null,\n\n  injection: {\n    /**\n     * @param {{onChange: (ReactID, ReactID) => void} GlobalResponderHandler\n     * Object that handles any change in responder. Use this to inject\n     * integration with an existing touch handling system etc.\n     */\n    injectGlobalResponderHandler: function(GlobalResponderHandler) {\n      ResponderEventPlugin.GlobalResponderHandler = GlobalResponderHandler;\n    },\n\n    /**\n     * @param {{onChange: (numberActiveTouches) => void} GlobalInteractionHandler\n     * Object that handles any change in the number of active touches.\n     */\n    injectGlobalInteractionHandler: function(GlobalInteractionHandler) {\n      ResponderEventPlugin.GlobalInteractionHandler = GlobalInteractionHandler;\n    }\n  }\n};\n\nvar customBubblingEventTypes = {};\nvar customDirectEventTypes = {};\n\nvar ReactNativeBridgeEventPlugin = {\n  eventTypes: {},\n\n  /**\n   * @see {EventPluginHub.extractEvents}\n   */\n  extractEvents: function(\n    topLevelType,\n    targetInst,\n    nativeEvent,\n    nativeEventTarget\n  ) {\n    if (targetInst == null) {\n      // Probably a node belonging to another renderer's tree.\n      return null;\n    }\n    var bubbleDispatchConfig = customBubblingEventTypes[topLevelType];\n    var directDispatchConfig = customDirectEventTypes[topLevelType];\n    invariant(\n      bubbleDispatchConfig || directDispatchConfig,\n      'Unsupported top level event type \"%s\" dispatched',\n      topLevelType\n    );\n    var event = SyntheticEvent$1.getPooled(\n      bubbleDispatchConfig || directDispatchConfig,\n      targetInst,\n      nativeEvent,\n      nativeEventTarget\n    );\n    if (bubbleDispatchConfig) {\n      accumulateTwoPhaseDispatches(event);\n    } else if (directDispatchConfig) {\n      accumulateDirectDispatches(event);\n    } else {\n      return null;\n    }\n    return event;\n  },\n\n  processEventTypes: function(viewConfig) {\n    var bubblingEventTypes = viewConfig.bubblingEventTypes,\n      directEventTypes = viewConfig.directEventTypes;\n\n    {\n      if (bubblingEventTypes != null && directEventTypes != null) {\n        for (var topLevelType in directEventTypes) {\n          invariant(\n            bubblingEventTypes[topLevelType] == null,\n            \"Event cannot be both direct and bubbling: %s\",\n            topLevelType\n          );\n        }\n      }\n    }\n\n    if (bubblingEventTypes != null) {\n      for (var _topLevelType in bubblingEventTypes) {\n        if (customBubblingEventTypes[_topLevelType] == null) {\n          ReactNativeBridgeEventPlugin.eventTypes[\n            _topLevelType\n          ] = customBubblingEventTypes[_topLevelType] =\n            bubblingEventTypes[_topLevelType];\n        }\n      }\n    }\n\n    if (directEventTypes != null) {\n      for (var _topLevelType2 in directEventTypes) {\n        if (customDirectEventTypes[_topLevelType2] == null) {\n          ReactNativeBridgeEventPlugin.eventTypes[\n            _topLevelType2\n          ] = customDirectEventTypes[_topLevelType2] =\n            directEventTypes[_topLevelType2];\n        }\n      }\n    }\n  }\n};\n\nvar instanceCache = {};\nvar instanceProps = {};\n\nfunction precacheFiberNode(hostInst, tag) {\n  instanceCache[tag] = hostInst;\n}\n\nfunction uncacheFiberNode(tag) {\n  delete instanceCache[tag];\n  delete instanceProps[tag];\n}\n\nfunction getInstanceFromTag(tag) {\n  if (typeof tag === \"number\") {\n    return instanceCache[tag] || null;\n  } else {\n    // Fabric will invoke event emitters on a direct fiber reference\n    return tag;\n  }\n}\n\nfunction getTagFromInstance(inst) {\n  var tag = inst.stateNode._nativeTag;\n  if (tag === undefined) {\n    tag = inst.stateNode.canonical._nativeTag;\n  }\n  invariant(tag, \"All native instances should have a tag.\");\n  return tag;\n}\n\nfunction getFiberCurrentPropsFromNode$1(stateNode) {\n  return instanceProps[stateNode._nativeTag] || null;\n}\n\nfunction updateFiberProps(tag, props) {\n  instanceProps[tag] = props;\n}\n\nvar ReactNativeComponentTree = Object.freeze({\n  precacheFiberNode: precacheFiberNode,\n  uncacheFiberNode: uncacheFiberNode,\n  getClosestInstanceFromNode: getInstanceFromTag,\n  getInstanceFromNode: getInstanceFromTag,\n  getNodeFromInstance: getTagFromInstance,\n  getFiberCurrentPropsFromNode: getFiberCurrentPropsFromNode$1,\n  updateFiberProps: updateFiberProps\n});\n\nvar ReactNativeEventPluginOrder = [\n  \"ResponderEventPlugin\",\n  \"ReactNativeBridgeEventPlugin\"\n];\n\n// Module provided by RN:\nvar ReactNativeGlobalResponderHandler = {\n  onChange: function(from, to, blockNativeResponder) {\n    if (to !== null) {\n      var tag = to.stateNode._nativeTag;\n      UIManager.setJSResponder(tag, blockNativeResponder);\n    } else {\n      UIManager.clearJSResponder();\n    }\n  }\n};\n\n/**\n * Make sure essential globals are available and are patched correctly. Please don't remove this\n * line. Bundles created by react-packager `require` it before executing any application code. This\n * ensures it exists in the dependency graph and can be `require`d.\n * TODO: require this in packager, not in React #10932517\n */\n// Module provided by RN:\n/**\n * Inject module for resolving DOM hierarchy and plugin ordering.\n */\ninjection.injectEventPluginOrder(ReactNativeEventPluginOrder);\ninjection$1.injectComponentTree(ReactNativeComponentTree);\n\nResponderEventPlugin.injection.injectGlobalResponderHandler(\n  ReactNativeGlobalResponderHandler\n);\n\n/**\n * Some important event plugins included by default (without having to require\n * them).\n */\ninjection.injectEventPluginsByName({\n  ResponderEventPlugin: ResponderEventPlugin,\n  ReactNativeBridgeEventPlugin: ReactNativeBridgeEventPlugin\n});\n\n// Use to restore controlled state after a change event has fired.\n\nvar fiberHostComponent = null;\n\nvar restoreTarget = null;\nvar restoreQueue = null;\n\nfunction restoreStateOfTarget(target) {\n  // We perform this translation at the end of the event loop so that we\n  // always receive the correct fiber here\n  var internalInstance = getInstanceFromNode(target);\n  if (!internalInstance) {\n    // Unmounted\n    return;\n  }\n  invariant(\n    fiberHostComponent &&\n      typeof fiberHostComponent.restoreControlledState === \"function\",\n    \"Fiber needs to be injected to handle a fiber target for controlled \" +\n      \"events. This error is likely caused by a bug in React. Please file an issue.\"\n  );\n  var props = getFiberCurrentPropsFromNode(internalInstance.stateNode);\n  fiberHostComponent.restoreControlledState(\n    internalInstance.stateNode,\n    internalInstance.type,\n    props\n  );\n}\n\nfunction needsStateRestore() {\n  return restoreTarget !== null || restoreQueue !== null;\n}\n\nfunction restoreStateIfNeeded() {\n  if (!restoreTarget) {\n    return;\n  }\n  var target = restoreTarget;\n  var queuedTargets = restoreQueue;\n  restoreTarget = null;\n  restoreQueue = null;\n\n  restoreStateOfTarget(target);\n  if (queuedTargets) {\n    for (var i = 0; i < queuedTargets.length; i++) {\n      restoreStateOfTarget(queuedTargets[i]);\n    }\n  }\n}\n\n// Used as a way to call batchedUpdates when we don't have a reference to\n// the renderer. Such as when we're dispatching events or if third party\n// libraries need to call batchedUpdates. Eventually, this API will go away when\n// everything is batched by default. We'll then have a similar API to opt-out of\n// scheduled work and instead do synchronous work.\n\n// Defaults\nvar _batchedUpdates = function(fn, bookkeeping) {\n  return fn(bookkeeping);\n};\nvar _interactiveUpdates = function(fn, a, b) {\n  return fn(a, b);\n};\nvar _flushInteractiveUpdates = function() {};\n\nvar isBatching = false;\nfunction batchedUpdates(fn, bookkeeping) {\n  if (isBatching) {\n    // If we are currently inside another batch, we need to wait until it\n    // fully completes before restoring state.\n    return fn(bookkeeping);\n  }\n  isBatching = true;\n  try {\n    return _batchedUpdates(fn, bookkeeping);\n  } finally {\n    // Here we wait until all updates have propagated, which is important\n    // when using controlled components within layers:\n    // https://github.com/facebook/react/issues/1698\n    // Then we restore state of any controlled component.\n    isBatching = false;\n    var controlledComponentsHavePendingUpdates = needsStateRestore();\n    if (controlledComponentsHavePendingUpdates) {\n      // If a controlled event was fired, we may need to restore the state of\n      // the DOM node back to the controlled value. This is necessary when React\n      // bails out of the update without touching the DOM.\n      _flushInteractiveUpdates();\n      restoreStateIfNeeded();\n    }\n  }\n}\n\nvar injection$2 = {\n  injectRenderer: function(renderer) {\n    _batchedUpdates = renderer.batchedUpdates;\n    _interactiveUpdates = renderer.interactiveUpdates;\n    _flushInteractiveUpdates = renderer.flushInteractiveUpdates;\n  }\n};\n\n/**\n * Keeps track of allocating and associating native \"tags\" which are numeric,\n * unique view IDs. All the native tags are negative numbers, to avoid\n * collisions, but in the JS we keep track of them as positive integers to store\n * them effectively in Arrays. So we must refer to them as \"inverses\" of the\n * native tags (that are * normally negative).\n *\n * It *must* be the case that every `rootNodeID` always maps to the exact same\n * `tag` forever. The easiest way to accomplish this is to never delete\n * anything from this table.\n * Why: Because `dangerouslyReplaceNodeWithMarkupByID` relies on being able to\n * unmount a component with a `rootNodeID`, then mount a new one in its place,\n */\nvar INITIAL_TAG_COUNT = 1;\nvar ReactNativeTagHandles = {\n  tagsStartAt: INITIAL_TAG_COUNT,\n  tagCount: INITIAL_TAG_COUNT,\n\n  allocateTag: function() {\n    // Skip over root IDs as those are reserved for native\n    while (this.reactTagIsNativeTopRootID(ReactNativeTagHandles.tagCount)) {\n      ReactNativeTagHandles.tagCount++;\n    }\n    var tag = ReactNativeTagHandles.tagCount;\n    ReactNativeTagHandles.tagCount++;\n    return tag;\n  },\n\n  assertRootTag: function(tag) {\n    invariant(\n      this.reactTagIsNativeTopRootID(tag),\n      \"Expect a native root tag, instead got %s\",\n      tag\n    );\n  },\n\n  reactTagIsNativeTopRootID: function(reactTag) {\n    // We reserve all tags that are 1 mod 10 for native root views\n    return reactTag % 10 === 1;\n  }\n};\n\n/**\n * Version of `ReactBrowserEventEmitter` that works on the receiving side of a\n * serialized worker boundary.\n */\n\n// Shared default empty native event - conserve memory.\nvar EMPTY_NATIVE_EVENT = {};\n\n/**\n * Selects a subsequence of `Touch`es, without destroying `touches`.\n *\n * @param {Array<Touch>} touches Deserialized touch objects.\n * @param {Array<number>} indices Indices by which to pull subsequence.\n * @return {Array<Touch>} Subsequence of touch objects.\n */\nvar touchSubsequence = function(touches, indices) {\n  var ret = [];\n  for (var i = 0; i < indices.length; i++) {\n    ret.push(touches[indices[i]]);\n  }\n  return ret;\n};\n\n/**\n * TODO: Pool all of this.\n *\n * Destroys `touches` by removing touch objects at indices `indices`. This is\n * to maintain compatibility with W3C touch \"end\" events, where the active\n * touches don't include the set that has just been \"ended\".\n *\n * @param {Array<Touch>} touches Deserialized touch objects.\n * @param {Array<number>} indices Indices to remove from `touches`.\n * @return {Array<Touch>} Subsequence of removed touch objects.\n */\nvar removeTouchesAtIndices = function(touches, indices) {\n  var rippedOut = [];\n  // use an unsafe downcast to alias to nullable elements,\n  // so we can delete and then compact.\n  var temp = touches;\n  for (var i = 0; i < indices.length; i++) {\n    var index = indices[i];\n    rippedOut.push(touches[index]);\n    temp[index] = null;\n  }\n  var fillAt = 0;\n  for (var j = 0; j < temp.length; j++) {\n    var cur = temp[j];\n    if (cur !== null) {\n      temp[fillAt++] = cur;\n    }\n  }\n  temp.length = fillAt;\n  return rippedOut;\n};\n\n/**\n * Internal version of `receiveEvent` in terms of normalized (non-tag)\n * `rootNodeID`.\n *\n * @see receiveEvent.\n *\n * @param {rootNodeID} rootNodeID React root node ID that event occurred on.\n * @param {TopLevelType} topLevelType Top level type of event.\n * @param {?object} nativeEventParam Object passed from native.\n */\nfunction _receiveRootNodeIDEvent(rootNodeID, topLevelType, nativeEventParam) {\n  var nativeEvent = nativeEventParam || EMPTY_NATIVE_EVENT;\n  var inst = getInstanceFromTag(rootNodeID);\n  batchedUpdates(function() {\n    runExtractedEventsInBatch(\n      topLevelType,\n      inst,\n      nativeEvent,\n      nativeEvent.target\n    );\n  });\n  // React Native doesn't use ReactControlledComponent but if it did, here's\n  // where it would do it.\n}\n\n/**\n * Publicly exposed method on module for native objc to invoke when a top\n * level event is extracted.\n * @param {rootNodeID} rootNodeID React root node ID that event occurred on.\n * @param {TopLevelType} topLevelType Top level type of event.\n * @param {object} nativeEventParam Object passed from native.\n */\nfunction receiveEvent(rootNodeID, topLevelType, nativeEventParam) {\n  _receiveRootNodeIDEvent(rootNodeID, topLevelType, nativeEventParam);\n}\n\n/**\n * Simple multi-wrapper around `receiveEvent` that is intended to receive an\n * efficient representation of `Touch` objects, and other information that\n * can be used to construct W3C compliant `Event` and `Touch` lists.\n *\n * This may create dispatch behavior that differs than web touch handling. We\n * loop through each of the changed touches and receive it as a single event.\n * So two `touchStart`/`touchMove`s that occur simultaneously are received as\n * two separate touch event dispatches - when they arguably should be one.\n *\n * This implementation reuses the `Touch` objects themselves as the `Event`s\n * since we dispatch an event for each touch (though that might not be spec\n * compliant). The main purpose of reusing them is to save allocations.\n *\n * TODO: Dispatch multiple changed touches in one event. The bubble path\n * could be the first common ancestor of all the `changedTouches`.\n *\n * One difference between this behavior and W3C spec: cancelled touches will\n * not appear in `.touches`, or in any future `.touches`, though they may\n * still be \"actively touching the surface\".\n *\n * Web desktop polyfills only need to construct a fake touch event with\n * identifier 0, also abandoning traditional click handlers.\n */\nfunction receiveTouches(eventTopLevelType, touches, changedIndices) {\n  var changedTouches =\n    eventTopLevelType === \"topTouchEnd\" ||\n    eventTopLevelType === \"topTouchCancel\"\n      ? removeTouchesAtIndices(touches, changedIndices)\n      : touchSubsequence(touches, changedIndices);\n\n  for (var jj = 0; jj < changedTouches.length; jj++) {\n    var touch = changedTouches[jj];\n    // Touch objects can fulfill the role of `DOM` `Event` objects if we set\n    // the `changedTouches`/`touches`. This saves allocations.\n    touch.changedTouches = changedTouches;\n    touch.touches = touches;\n    var nativeEvent = touch;\n    var rootNodeID = null;\n    var target = nativeEvent.target;\n    if (target !== null && target !== undefined) {\n      if (target < ReactNativeTagHandles.tagsStartAt) {\n        {\n          warning(\n            false,\n            \"A view is reporting that a touch occurred on tag zero.\"\n          );\n        }\n      } else {\n        rootNodeID = target;\n      }\n    }\n    // $FlowFixMe Shouldn't we *not* call it if rootNodeID is null?\n    _receiveRootNodeIDEvent(rootNodeID, eventTopLevelType, nativeEvent);\n  }\n}\n\nvar ReactNativeEventEmitter = Object.freeze({\n  getListener: getListener,\n  registrationNames: registrationNameModules,\n  _receiveRootNodeIDEvent: _receiveRootNodeIDEvent,\n  receiveEvent: receiveEvent,\n  receiveTouches: receiveTouches\n});\n\n// Module provided by RN:\n/**\n * Register the event emitter with the native bridge\n */\nRCTEventEmitter.register(ReactNativeEventEmitter);\n\n// The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n// nor polyfill, then a plain number is used for performance.\nvar hasSymbol = typeof Symbol === \"function\" && Symbol[\"for\"];\n\nvar REACT_ELEMENT_TYPE = hasSymbol ? Symbol[\"for\"](\"react.element\") : 0xeac7;\nvar REACT_CALL_TYPE = hasSymbol ? Symbol[\"for\"](\"react.call\") : 0xeac8;\nvar REACT_RETURN_TYPE = hasSymbol ? Symbol[\"for\"](\"react.return\") : 0xeac9;\nvar REACT_PORTAL_TYPE = hasSymbol ? Symbol[\"for\"](\"react.portal\") : 0xeaca;\nvar REACT_FRAGMENT_TYPE = hasSymbol ? Symbol[\"for\"](\"react.fragment\") : 0xeacb;\nvar REACT_STRICT_MODE_TYPE = hasSymbol\n  ? Symbol[\"for\"](\"react.strict_mode\")\n  : 0xeacc;\nvar REACT_PROVIDER_TYPE = hasSymbol ? Symbol[\"for\"](\"react.provider\") : 0xeacd;\nvar REACT_CONTEXT_TYPE = hasSymbol ? Symbol[\"for\"](\"react.context\") : 0xeace;\nvar REACT_ASYNC_MODE_TYPE = hasSymbol\n  ? Symbol[\"for\"](\"react.async_mode\")\n  : 0xeacf;\n\nvar MAYBE_ITERATOR_SYMBOL = typeof Symbol === \"function\" && Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = \"@@iterator\";\n\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable === \"undefined\") {\n    return null;\n  }\n  var maybeIterator =\n    (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||\n    maybeIterable[FAUX_ITERATOR_SYMBOL];\n  if (typeof maybeIterator === \"function\") {\n    return maybeIterator;\n  }\n  return null;\n}\n\nfunction createPortal(\n  children,\n  containerInfo,\n  // TODO: figure out the API for cross-renderer implementation.\n  implementation\n) {\n  var key =\n    arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n  return {\n    // This tag allow us to uniquely identify this as a React Portal\n    $$typeof: REACT_PORTAL_TYPE,\n    key: key == null ? null : \"\" + key,\n    children: children,\n    containerInfo: containerInfo,\n    implementation: implementation\n  };\n}\n\nvar TouchHistoryMath = {\n  /**\n   * This code is optimized and not intended to look beautiful. This allows\n   * computing of touch centroids that have moved after `touchesChangedAfter`\n   * timeStamp. You can compute the current centroid involving all touches\n   * moves after `touchesChangedAfter`, or you can compute the previous\n   * centroid of all touches that were moved after `touchesChangedAfter`.\n   *\n   * @param {TouchHistoryMath} touchHistory Standard Responder touch track\n   * data.\n   * @param {number} touchesChangedAfter timeStamp after which moved touches\n   * are considered \"actively moving\" - not just \"active\".\n   * @param {boolean} isXAxis Consider `x` dimension vs. `y` dimension.\n   * @param {boolean} ofCurrent Compute current centroid for actively moving\n   * touches vs. previous centroid of now actively moving touches.\n   * @return {number} value of centroid in specified dimension.\n   */\n  centroidDimension: function(\n    touchHistory,\n    touchesChangedAfter,\n    isXAxis,\n    ofCurrent\n  ) {\n    var touchBank = touchHistory.touchBank;\n    var total = 0;\n    var count = 0;\n\n    var oneTouchData =\n      touchHistory.numberActiveTouches === 1\n        ? touchHistory.touchBank[touchHistory.indexOfSingleActiveTouch]\n        : null;\n\n    if (oneTouchData !== null) {\n      if (\n        oneTouchData.touchActive &&\n        oneTouchData.currentTimeStamp > touchesChangedAfter\n      ) {\n        total +=\n          ofCurrent && isXAxis\n            ? oneTouchData.currentPageX\n            : ofCurrent && !isXAxis\n              ? oneTouchData.currentPageY\n              : !ofCurrent && isXAxis\n                ? oneTouchData.previousPageX\n                : oneTouchData.previousPageY;\n        count = 1;\n      }\n    } else {\n      for (var i = 0; i < touchBank.length; i++) {\n        var touchTrack = touchBank[i];\n        if (\n          touchTrack !== null &&\n          touchTrack !== undefined &&\n          touchTrack.touchActive &&\n          touchTrack.currentTimeStamp >= touchesChangedAfter\n        ) {\n          var toAdd = void 0; // Yuck, program temporarily in invalid state.\n          if (ofCurrent && isXAxis) {\n            toAdd = touchTrack.currentPageX;\n          } else if (ofCurrent && !isXAxis) {\n            toAdd = touchTrack.currentPageY;\n          } else if (!ofCurrent && isXAxis) {\n            toAdd = touchTrack.previousPageX;\n          } else {\n            toAdd = touchTrack.previousPageY;\n          }\n          total += toAdd;\n          count++;\n        }\n      }\n    }\n    return count > 0 ? total / count : TouchHistoryMath.noCentroid;\n  },\n\n  currentCentroidXOfTouchesChangedAfter: function(\n    touchHistory,\n    touchesChangedAfter\n  ) {\n    return TouchHistoryMath.centroidDimension(\n      touchHistory,\n      touchesChangedAfter,\n      true, // isXAxis\n      true\n    );\n  },\n\n  currentCentroidYOfTouchesChangedAfter: function(\n    touchHistory,\n    touchesChangedAfter\n  ) {\n    return TouchHistoryMath.centroidDimension(\n      touchHistory,\n      touchesChangedAfter,\n      false, // isXAxis\n      true\n    );\n  },\n\n  previousCentroidXOfTouchesChangedAfter: function(\n    touchHistory,\n    touchesChangedAfter\n  ) {\n    return TouchHistoryMath.centroidDimension(\n      touchHistory,\n      touchesChangedAfter,\n      true, // isXAxis\n      false\n    );\n  },\n\n  previousCentroidYOfTouchesChangedAfter: function(\n    touchHistory,\n    touchesChangedAfter\n  ) {\n    return TouchHistoryMath.centroidDimension(\n      touchHistory,\n      touchesChangedAfter,\n      false, // isXAxis\n      false\n    );\n  },\n\n  currentCentroidX: function(touchHistory) {\n    return TouchHistoryMath.centroidDimension(\n      touchHistory,\n      0, // touchesChangedAfter\n      true, // isXAxis\n      true\n    );\n  },\n\n  currentCentroidY: function(touchHistory) {\n    return TouchHistoryMath.centroidDimension(\n      touchHistory,\n      0, // touchesChangedAfter\n      false, // isXAxis\n      true\n    );\n  },\n\n  noCentroid: -1\n};\n\n// TODO: this is special because it gets imported during build.\n\nvar ReactVersion = \"16.3.0-alpha.1\";\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar objects = {};\nvar uniqueID = 1;\nvar emptyObject$2 = {};\n\nvar ReactNativePropRegistry = (function() {\n  function ReactNativePropRegistry() {\n    _classCallCheck(this, ReactNativePropRegistry);\n  }\n\n  ReactNativePropRegistry.register = function register(object) {\n    var id = ++uniqueID;\n    {\n      Object.freeze(object);\n    }\n    objects[id] = object;\n    return id;\n  };\n\n  ReactNativePropRegistry.getByID = function getByID(id) {\n    if (!id) {\n      // Used in the style={[condition && id]} pattern,\n      // we want it to be a no-op when the value is false or null\n      return emptyObject$2;\n    }\n\n    var object = objects[id];\n    if (!object) {\n      console.warn(\"Invalid style with id `\" + id + \"`. Skipping ...\");\n      return emptyObject$2;\n    }\n    return object;\n  };\n\n  return ReactNativePropRegistry;\n})();\n\n// Modules provided by RN:\nvar emptyObject$1 = {};\n\n/**\n * Create a payload that contains all the updates between two sets of props.\n *\n * These helpers are all encapsulated into a single module, because they use\n * mutation as a performance optimization which leads to subtle shared\n * dependencies between the code paths. To avoid this mutable state leaking\n * across modules, I've kept them isolated to this module.\n */\n\n// Tracks removed keys\nvar removedKeys = null;\nvar removedKeyCount = 0;\n\nfunction defaultDiffer(prevProp, nextProp) {\n  if (typeof nextProp !== \"object\" || nextProp === null) {\n    // Scalars have already been checked for equality\n    return true;\n  } else {\n    // For objects and arrays, the default diffing algorithm is a deep compare\n    return deepDiffer(prevProp, nextProp);\n  }\n}\n\nfunction resolveObject(idOrObject) {\n  if (typeof idOrObject === \"number\") {\n    return ReactNativePropRegistry.getByID(idOrObject);\n  }\n  return idOrObject;\n}\n\nfunction restoreDeletedValuesInNestedArray(\n  updatePayload,\n  node,\n  validAttributes\n) {\n  if (Array.isArray(node)) {\n    var i = node.length;\n    while (i-- && removedKeyCount > 0) {\n      restoreDeletedValuesInNestedArray(\n        updatePayload,\n        node[i],\n        validAttributes\n      );\n    }\n  } else if (node && removedKeyCount > 0) {\n    var obj = resolveObject(node);\n    for (var propKey in removedKeys) {\n      if (!removedKeys[propKey]) {\n        continue;\n      }\n      var _nextProp = obj[propKey];\n      if (_nextProp === undefined) {\n        continue;\n      }\n\n      var attributeConfig = validAttributes[propKey];\n      if (!attributeConfig) {\n        continue; // not a valid native prop\n      }\n\n      if (typeof _nextProp === \"function\") {\n        _nextProp = true;\n      }\n      if (typeof _nextProp === \"undefined\") {\n        _nextProp = null;\n      }\n\n      if (typeof attributeConfig !== \"object\") {\n        // case: !Object is the default case\n        updatePayload[propKey] = _nextProp;\n      } else if (\n        typeof attributeConfig.diff === \"function\" ||\n        typeof attributeConfig.process === \"function\"\n      ) {\n        // case: CustomAttributeConfiguration\n        var nextValue =\n          typeof attributeConfig.process === \"function\"\n            ? attributeConfig.process(_nextProp)\n            : _nextProp;\n        updatePayload[propKey] = nextValue;\n      }\n      removedKeys[propKey] = false;\n      removedKeyCount--;\n    }\n  }\n}\n\nfunction diffNestedArrayProperty(\n  updatePayload,\n  prevArray,\n  nextArray,\n  validAttributes\n) {\n  var minLength =\n    prevArray.length < nextArray.length ? prevArray.length : nextArray.length;\n  var i = void 0;\n  for (i = 0; i < minLength; i++) {\n    // Diff any items in the array in the forward direction. Repeated keys\n    // will be overwritten by later values.\n    updatePayload = diffNestedProperty(\n      updatePayload,\n      prevArray[i],\n      nextArray[i],\n      validAttributes\n    );\n  }\n  for (; i < prevArray.length; i++) {\n    // Clear out all remaining properties.\n    updatePayload = clearNestedProperty(\n      updatePayload,\n      prevArray[i],\n      validAttributes\n    );\n  }\n  for (; i < nextArray.length; i++) {\n    // Add all remaining properties.\n    updatePayload = addNestedProperty(\n      updatePayload,\n      nextArray[i],\n      validAttributes\n    );\n  }\n  return updatePayload;\n}\n\nfunction diffNestedProperty(\n  updatePayload,\n  prevProp,\n  nextProp,\n  validAttributes\n) {\n  if (!updatePayload && prevProp === nextProp) {\n    // If no properties have been added, then we can bail out quickly on object\n    // equality.\n    return updatePayload;\n  }\n\n  if (!prevProp || !nextProp) {\n    if (nextProp) {\n      return addNestedProperty(updatePayload, nextProp, validAttributes);\n    }\n    if (prevProp) {\n      return clearNestedProperty(updatePayload, prevProp, validAttributes);\n    }\n    return updatePayload;\n  }\n\n  if (!Array.isArray(prevProp) && !Array.isArray(nextProp)) {\n    // Both are leaves, we can diff the leaves.\n    return diffProperties(\n      updatePayload,\n      resolveObject(prevProp),\n      resolveObject(nextProp),\n      validAttributes\n    );\n  }\n\n  if (Array.isArray(prevProp) && Array.isArray(nextProp)) {\n    // Both are arrays, we can diff the arrays.\n    return diffNestedArrayProperty(\n      updatePayload,\n      prevProp,\n      nextProp,\n      validAttributes\n    );\n  }\n\n  if (Array.isArray(prevProp)) {\n    return diffProperties(\n      updatePayload,\n      // $FlowFixMe - We know that this is always an object when the input is.\n      flattenStyle(prevProp),\n      // $FlowFixMe - We know that this isn't an array because of above flow.\n      resolveObject(nextProp),\n      validAttributes\n    );\n  }\n\n  return diffProperties(\n    updatePayload,\n    resolveObject(prevProp),\n    // $FlowFixMe - We know that this is always an object when the input is.\n    flattenStyle(nextProp),\n    validAttributes\n  );\n}\n\n/**\n * addNestedProperty takes a single set of props and valid attribute\n * attribute configurations. It processes each prop and adds it to the\n * updatePayload.\n */\nfunction addNestedProperty(updatePayload, nextProp, validAttributes) {\n  if (!nextProp) {\n    return updatePayload;\n  }\n\n  if (!Array.isArray(nextProp)) {\n    // Add each property of the leaf.\n    return addProperties(\n      updatePayload,\n      resolveObject(nextProp),\n      validAttributes\n    );\n  }\n\n  for (var i = 0; i < nextProp.length; i++) {\n    // Add all the properties of the array.\n    updatePayload = addNestedProperty(\n      updatePayload,\n      nextProp[i],\n      validAttributes\n    );\n  }\n\n  return updatePayload;\n}\n\n/**\n * clearNestedProperty takes a single set of props and valid attributes. It\n * adds a null sentinel to the updatePayload, for each prop key.\n */\nfunction clearNestedProperty(updatePayload, prevProp, validAttributes) {\n  if (!prevProp) {\n    return updatePayload;\n  }\n\n  if (!Array.isArray(prevProp)) {\n    // Add each property of the leaf.\n    return clearProperties(\n      updatePayload,\n      resolveObject(prevProp),\n      validAttributes\n    );\n  }\n\n  for (var i = 0; i < prevProp.length; i++) {\n    // Add all the properties of the array.\n    updatePayload = clearNestedProperty(\n      updatePayload,\n      prevProp[i],\n      validAttributes\n    );\n  }\n  return updatePayload;\n}\n\n/**\n * diffProperties takes two sets of props and a set of valid attributes\n * and write to updatePayload the values that changed or were deleted.\n * If no updatePayload is provided, a new one is created and returned if\n * anything changed.\n */\nfunction diffProperties(updatePayload, prevProps, nextProps, validAttributes) {\n  var attributeConfig = void 0;\n  var nextProp = void 0;\n  var prevProp = void 0;\n\n  for (var propKey in nextProps) {\n    attributeConfig = validAttributes[propKey];\n    if (!attributeConfig) {\n      continue; // not a valid native prop\n    }\n\n    prevProp = prevProps[propKey];\n    nextProp = nextProps[propKey];\n\n    // functions are converted to booleans as markers that the associated\n    // events should be sent from native.\n    if (typeof nextProp === \"function\") {\n      nextProp = true;\n      // If nextProp is not a function, then don't bother changing prevProp\n      // since nextProp will win and go into the updatePayload regardless.\n      if (typeof prevProp === \"function\") {\n        prevProp = true;\n      }\n    }\n\n    // An explicit value of undefined is treated as a null because it overrides\n    // any other preceding value.\n    if (typeof nextProp === \"undefined\") {\n      nextProp = null;\n      if (typeof prevProp === \"undefined\") {\n        prevProp = null;\n      }\n    }\n\n    if (removedKeys) {\n      removedKeys[propKey] = false;\n    }\n\n    if (updatePayload && updatePayload[propKey] !== undefined) {\n      // Something else already triggered an update to this key because another\n      // value diffed. Since we're now later in the nested arrays our value is\n      // more important so we need to calculate it and override the existing\n      // value. It doesn't matter if nothing changed, we'll set it anyway.\n\n      // Pattern match on: attributeConfig\n      if (typeof attributeConfig !== \"object\") {\n        // case: !Object is the default case\n        updatePayload[propKey] = nextProp;\n      } else if (\n        typeof attributeConfig.diff === \"function\" ||\n        typeof attributeConfig.process === \"function\"\n      ) {\n        // case: CustomAttributeConfiguration\n        var nextValue =\n          typeof attributeConfig.process === \"function\"\n            ? attributeConfig.process(nextProp)\n            : nextProp;\n        updatePayload[propKey] = nextValue;\n      }\n      continue;\n    }\n\n    if (prevProp === nextProp) {\n      continue; // nothing changed\n    }\n\n    // Pattern match on: attributeConfig\n    if (typeof attributeConfig !== \"object\") {\n      // case: !Object is the default case\n      if (defaultDiffer(prevProp, nextProp)) {\n        // a normal leaf has changed\n        (updatePayload || (updatePayload = {}))[propKey] = nextProp;\n      }\n    } else if (\n      typeof attributeConfig.diff === \"function\" ||\n      typeof attributeConfig.process === \"function\"\n    ) {\n      // case: CustomAttributeConfiguration\n      var shouldUpdate =\n        prevProp === undefined ||\n        (typeof attributeConfig.diff === \"function\"\n          ? attributeConfig.diff(prevProp, nextProp)\n          : defaultDiffer(prevProp, nextProp));\n      if (shouldUpdate) {\n        var _nextValue =\n          typeof attributeConfig.process === \"function\"\n            ? attributeConfig.process(nextProp)\n            : nextProp;\n        (updatePayload || (updatePayload = {}))[propKey] = _nextValue;\n      }\n    } else {\n      // default: fallthrough case when nested properties are defined\n      removedKeys = null;\n      removedKeyCount = 0;\n      // We think that attributeConfig is not CustomAttributeConfiguration at\n      // this point so we assume it must be AttributeConfiguration.\n      updatePayload = diffNestedProperty(\n        updatePayload,\n        prevProp,\n        nextProp,\n        attributeConfig\n      );\n      if (removedKeyCount > 0 && updatePayload) {\n        restoreDeletedValuesInNestedArray(\n          updatePayload,\n          nextProp,\n          attributeConfig\n        );\n        removedKeys = null;\n      }\n    }\n  }\n\n  // Also iterate through all the previous props to catch any that have been\n  // removed and make sure native gets the signal so it can reset them to the\n  // default.\n  for (var _propKey in prevProps) {\n    if (nextProps[_propKey] !== undefined) {\n      continue; // we've already covered this key in the previous pass\n    }\n    attributeConfig = validAttributes[_propKey];\n    if (!attributeConfig) {\n      continue; // not a valid native prop\n    }\n\n    if (updatePayload && updatePayload[_propKey] !== undefined) {\n      // This was already updated to a diff result earlier.\n      continue;\n    }\n\n    prevProp = prevProps[_propKey];\n    if (prevProp === undefined) {\n      continue; // was already empty anyway\n    }\n    // Pattern match on: attributeConfig\n    if (\n      typeof attributeConfig !== \"object\" ||\n      typeof attributeConfig.diff === \"function\" ||\n      typeof attributeConfig.process === \"function\"\n    ) {\n      // case: CustomAttributeConfiguration | !Object\n      // Flag the leaf property for removal by sending a sentinel.\n      (updatePayload || (updatePayload = {}))[_propKey] = null;\n      if (!removedKeys) {\n        removedKeys = {};\n      }\n      if (!removedKeys[_propKey]) {\n        removedKeys[_propKey] = true;\n        removedKeyCount++;\n      }\n    } else {\n      // default:\n      // This is a nested attribute configuration where all the properties\n      // were removed so we need to go through and clear out all of them.\n      updatePayload = clearNestedProperty(\n        updatePayload,\n        prevProp,\n        attributeConfig\n      );\n    }\n  }\n  return updatePayload;\n}\n\n/**\n * addProperties adds all the valid props to the payload after being processed.\n */\nfunction addProperties(updatePayload, props, validAttributes) {\n  // TODO: Fast path\n  return diffProperties(updatePayload, emptyObject$1, props, validAttributes);\n}\n\n/**\n * clearProperties clears all the previous props by adding a null sentinel\n * to the payload for each valid key.\n */\nfunction clearProperties(updatePayload, prevProps, validAttributes) {\n  // TODO: Fast path\n  return diffProperties(\n    updatePayload,\n    prevProps,\n    emptyObject$1,\n    validAttributes\n  );\n}\n\nfunction create(props, validAttributes) {\n  return addProperties(\n    null, // updatePayload\n    props,\n    validAttributes\n  );\n}\n\nfunction diff(prevProps, nextProps, validAttributes) {\n  return diffProperties(\n    null, // updatePayload\n    prevProps,\n    nextProps,\n    validAttributes\n  );\n}\n\n/**\n * In the future, we should cleanup callbacks by cancelling them instead of\n * using this.\n */\nfunction mountSafeCallback(context, callback) {\n  return function() {\n    if (!callback) {\n      return undefined;\n    }\n    if (typeof context.__isMounted === \"boolean\") {\n      // TODO(gaearon): this is gross and should be removed.\n      // It is currently necessary because View uses createClass,\n      // and so any measure() calls on View (which are done by React\n      // DevTools) trigger the isMounted() deprecation warning.\n      if (!context.__isMounted) {\n        return undefined;\n      }\n      // The else branch is important so that we don't\n      // trigger the deprecation warning by calling isMounted.\n    } else if (typeof context.isMounted === \"function\") {\n      if (!context.isMounted()) {\n        return undefined;\n      }\n    }\n    return callback.apply(context, arguments);\n  };\n}\n\nfunction throwOnStylesProp(component, props) {\n  if (props.styles !== undefined) {\n    var owner = component._owner || null;\n    var name = component.constructor.displayName;\n    var msg =\n      \"`styles` is not a supported property of `\" +\n      name +\n      \"`, did \" +\n      \"you mean `style` (singular)?\";\n    if (owner && owner.constructor && owner.constructor.displayName) {\n      msg +=\n        \"\\n\\nCheck the `\" +\n        owner.constructor.displayName +\n        \"` parent \" +\n        \" component.\";\n    }\n    throw new Error(msg);\n  }\n}\n\nfunction warnForStyleProps(props, validAttributes) {\n  for (var key in validAttributes.style) {\n    if (!(validAttributes[key] || props[key] === undefined)) {\n      console.error(\n        \"You are setting the style `{ \" +\n          key +\n          \": ... }` as a prop. You \" +\n          \"should nest it in a style object. \" +\n          \"E.g. `{ style: { \" +\n          key +\n          \": ... } }`\"\n      );\n    }\n  }\n}\n\n/**\n * `ReactInstanceMap` maintains a mapping from a public facing stateful\n * instance (key) and the internal representation (value). This allows public\n * methods to accept the user facing instance as an argument and map them back\n * to internal methods.\n *\n * Note that this module is currently shared and assumed to be stateless.\n * If this becomes an actual Map, that will break.\n */\n\n/**\n * This API should be called `delete` but we'd have to make sure to always\n * transform these to strings for IE support. When this transform is fully\n * supported we can rename it.\n */\n\nfunction get(key) {\n  return key._reactInternalFiber;\n}\n\nfunction set(key, value) {\n  key._reactInternalFiber = value;\n}\n\nvar ReactInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nvar ReactCurrentOwner = ReactInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame = ReactInternals.ReactDebugCurrentFrame;\n\nfunction getComponentName(fiber) {\n  var type = fiber.type;\n\n  if (typeof type === \"function\") {\n    return type.displayName || type.name;\n  }\n  if (typeof type === \"string\") {\n    return type;\n  }\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return \"ReactFragment\";\n    case REACT_PORTAL_TYPE:\n      return \"ReactPortal\";\n    case REACT_CALL_TYPE:\n      return \"ReactCall\";\n    case REACT_RETURN_TYPE:\n      return \"ReactReturn\";\n  }\n  return null;\n}\n\n// TODO: Share this module between Fabric and React Native renderers\n// so that both can be used in the same tree.\n\nvar findHostInstance = function(fiber) {\n  return null;\n};\n\nvar findHostInstanceFabric = function(fiber) {\n  return null;\n};\n\nfunction injectFindHostInstance(impl) {\n  findHostInstance = impl;\n}\n\n/**\n * ReactNative vs ReactWeb\n * -----------------------\n * React treats some pieces of data opaquely. This means that the information\n * is first class (it can be passed around), but cannot be inspected. This\n * allows us to build infrastructure that reasons about resources, without\n * making assumptions about the nature of those resources, and this allows that\n * infra to be shared across multiple platforms, where the resources are very\n * different. General infra (such as `ReactMultiChild`) reasons opaquely about\n * the data, but platform specific code (such as `ReactNativeBaseComponent`) can\n * make assumptions about the data.\n *\n *\n * `rootNodeID`, uniquely identifies a position in the generated native view\n * tree. Many layers of composite components (created with `React.createClass`)\n * can all share the same `rootNodeID`.\n *\n * `nodeHandle`: A sufficiently unambiguous way to refer to a lower level\n * resource (dom node, native view etc). The `rootNodeID` is sufficient for web\n * `nodeHandle`s, because the position in a tree is always enough to uniquely\n * identify a DOM node (we never have nodes in some bank outside of the\n * document). The same would be true for `ReactNative`, but we must maintain a\n * mapping that we can send efficiently serializable\n * strings across native boundaries.\n *\n * Opaque name      TodaysWebReact   FutureWebWorkerReact   ReactNative\n * ----------------------------------------------------------------------------\n * nodeHandle       N/A              rootNodeID             tag\n */\n\n// TODO (bvaughn) Rename the findNodeHandle module to something more descriptive\n// eg findInternalHostInstance. This will reduce the likelihood of someone\n// accidentally deep-requiring this version.\nfunction findNodeHandle(componentOrHandle) {\n  {\n    var owner = ReactCurrentOwner.current;\n    if (owner !== null && owner.stateNode !== null) {\n      warning(\n        owner.stateNode._warnedAboutRefsInRender,\n        \"%s is accessing findNodeHandle inside its render(). \" +\n          \"render() should be a pure function of props and state. It should \" +\n          \"never access something that requires stale data from the previous \" +\n          \"render, such as refs. Move this logic to componentDidMount and \" +\n          \"componentDidUpdate instead.\",\n        getComponentName(owner) || \"A component\"\n      );\n\n      owner.stateNode._warnedAboutRefsInRender = true;\n    }\n  }\n  if (componentOrHandle == null) {\n    return null;\n  }\n  if (typeof componentOrHandle === \"number\") {\n    // Already a node handle\n    return componentOrHandle;\n  }\n\n  var component = componentOrHandle;\n\n  // TODO (balpert): Wrap iOS native components in a composite wrapper, then\n  // ReactInstanceMap.get here will always succeed for mounted components\n  var internalInstance = get(component);\n  if (internalInstance) {\n    return (\n      findHostInstance(internalInstance) ||\n      findHostInstanceFabric(internalInstance)\n    );\n  } else {\n    if (component) {\n      return component;\n    } else {\n      invariant(\n        // Native\n        (typeof component === \"object\" && \"_nativeTag\" in component) ||\n          // Composite\n          (component.render != null && typeof component.render === \"function\"),\n        \"findNodeHandle(...): Argument is not a component \" +\n          \"(type: %s, keys: %s)\",\n        typeof component,\n        Object.keys(component)\n      );\n      invariant(\n        false,\n        \"findNodeHandle(...): Unable to find node handle for unmounted \" +\n          \"component.\"\n      );\n    }\n  }\n}\n\n/**\n * External users of findNodeHandle() expect the host tag number return type.\n * The injected findNodeHandle() strategy returns the instance wrapper though.\n * See NativeMethodsMixin#setNativeProps for more info on why this is done.\n */\nfunction findNumericNodeHandleFiber(componentOrHandle) {\n  var instance = findNodeHandle(componentOrHandle);\n  if (instance == null || typeof instance === \"number\") {\n    return instance;\n  }\n  return instance._nativeTag;\n}\n\n// Modules provided by RN:\n/**\n * `NativeMethodsMixin` provides methods to access the underlying native\n * component directly. This can be useful in cases when you want to focus\n * a view or measure its on-screen dimensions, for example.\n *\n * The methods described here are available on most of the default components\n * provided by React Native. Note, however, that they are *not* available on\n * composite components that aren't directly backed by a native view. This will\n * generally include most components that you define in your own app. For more\n * information, see [Direct\n * Manipulation](docs/direct-manipulation.html).\n *\n * Note the Flow $Exact<> syntax is required to support mixins.\n * React createClass mixins can only be used with exact types.\n */\nvar NativeMethodsMixin = {\n  /**\n   * Determines the location on screen, width, and height of the given view and\n   * returns the values via an async callback. If successful, the callback will\n   * be called with the following arguments:\n   *\n   *  - x\n   *  - y\n   *  - width\n   *  - height\n   *  - pageX\n   *  - pageY\n   *\n   * Note that these measurements are not available until after the rendering\n   * has been completed in native. If you need the measurements as soon as\n   * possible, consider using the [`onLayout`\n   * prop](docs/view.html#onlayout) instead.\n   */\n  measure: function(callback) {\n    UIManager.measure(\n      findNumericNodeHandleFiber(this),\n      mountSafeCallback(this, callback)\n    );\n  },\n\n  /**\n   * Determines the location of the given view in the window and returns the\n   * values via an async callback. If the React root view is embedded in\n   * another native view, this will give you the absolute coordinates. If\n   * successful, the callback will be called with the following\n   * arguments:\n   *\n   *  - x\n   *  - y\n   *  - width\n   *  - height\n   *\n   * Note that these measurements are not available until after the rendering\n   * has been completed in native.\n   */\n  measureInWindow: function(callback) {\n    UIManager.measureInWindow(\n      findNumericNodeHandleFiber(this),\n      mountSafeCallback(this, callback)\n    );\n  },\n\n  /**\n   * Like [`measure()`](#measure), but measures the view relative an ancestor,\n   * specified as `relativeToNativeNode`. This means that the returned x, y\n   * are relative to the origin x, y of the ancestor view.\n   *\n   * As always, to obtain a native node handle for a component, you can use\n   * `findNumericNodeHandle(component)`.\n   */\n  measureLayout: function(\n    relativeToNativeNode,\n    onSuccess,\n    onFail /* currently unused */\n  ) {\n    UIManager.measureLayout(\n      findNumericNodeHandleFiber(this),\n      relativeToNativeNode,\n      mountSafeCallback(this, onFail),\n      mountSafeCallback(this, onSuccess)\n    );\n  },\n\n  /**\n   * This function sends props straight to native. They will not participate in\n   * future diff process - this means that if you do not include them in the\n   * next render, they will remain active (see [Direct\n   * Manipulation](docs/direct-manipulation.html)).\n   */\n  setNativeProps: function(nativeProps) {\n    // Class components don't have viewConfig -> validateAttributes.\n    // Nor does it make sense to set native props on a non-native component.\n    // Instead, find the nearest host component and set props on it.\n    // Use findNodeHandle() rather than findNumericNodeHandle() because\n    // We want the instance/wrapper (not the native tag).\n    var maybeInstance = void 0;\n\n    // Fiber errors if findNodeHandle is called for an umounted component.\n    // Tests using ReactTestRenderer will trigger this case indirectly.\n    // Mimicking stack behavior, we should silently ignore this case.\n    // TODO Fix ReactTestRenderer so we can remove this try/catch.\n    try {\n      maybeInstance = findNodeHandle(this);\n    } catch (error) {}\n\n    // If there is no host component beneath this we should fail silently.\n    // This is not an error; it could mean a class component rendered null.\n    if (maybeInstance == null) {\n      return;\n    }\n\n    var viewConfig = maybeInstance.viewConfig;\n\n    {\n      warnForStyleProps(nativeProps, viewConfig.validAttributes);\n    }\n\n    var updatePayload = create(nativeProps, viewConfig.validAttributes);\n\n    // Avoid the overhead of bridge calls if there's no update.\n    // This is an expensive no-op for Android, and causes an unnecessary\n    // view invalidation for certain components (eg RCTTextInput) on iOS.\n    if (updatePayload != null) {\n      UIManager.updateView(\n        maybeInstance._nativeTag,\n        viewConfig.uiViewClassName,\n        updatePayload\n      );\n    }\n  },\n\n  /**\n   * Requests focus for the given input or view. The exact behavior triggered\n   * will depend on the platform and type of view.\n   */\n  focus: function() {\n    TextInputState.focusTextInput(findNumericNodeHandleFiber(this));\n  },\n\n  /**\n   * Removes focus from an input or view. This is the opposite of `focus()`.\n   */\n  blur: function() {\n    TextInputState.blurTextInput(findNumericNodeHandleFiber(this));\n  }\n};\n\n{\n  // hide this from Flow since we can't define these properties outside of\n  // true without actually implementing them (setting them to undefined\n  // isn't allowed by ReactClass)\n  var NativeMethodsMixin_DEV = NativeMethodsMixin;\n  invariant(\n    !NativeMethodsMixin_DEV.componentWillMount &&\n      !NativeMethodsMixin_DEV.componentWillReceiveProps &&\n      !NativeMethodsMixin_DEV.UNSAFE_componentWillMount &&\n      !NativeMethodsMixin_DEV.UNSAFE_componentWillReceiveProps,\n    \"Do not override existing functions.\"\n  );\n  // TODO (bvaughn) Remove cWM and cWRP in a future version of React Native,\n  // Once these lifecycles have been remove from the reconciler.\n  NativeMethodsMixin_DEV.componentWillMount = function() {\n    throwOnStylesProp(this, this.props);\n  };\n  NativeMethodsMixin_DEV.componentWillReceiveProps = function(newProps) {\n    throwOnStylesProp(this, newProps);\n  };\n  NativeMethodsMixin_DEV.UNSAFE_componentWillMount = function() {\n    throwOnStylesProp(this, this.props);\n  };\n  NativeMethodsMixin_DEV.UNSAFE_componentWillReceiveProps = function(newProps) {\n    throwOnStylesProp(this, newProps);\n  };\n\n  // React may warn about cWM/cWRP/cWU methods being deprecated.\n  // Add a flag to suppress these warnings for this special case.\n  // TODO (bvaughn) Remove this flag once the above methods have been removed.\n  NativeMethodsMixin_DEV.componentWillMount.__suppressDeprecationWarning = true;\n  NativeMethodsMixin_DEV.componentWillReceiveProps.__suppressDeprecationWarning = true;\n}\n\nfunction _classCallCheck$1(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\n      \"this hasn't been initialised - super() hasn't been called\"\n    );\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\")\n    ? call\n    : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\n      \"Super expression must either be null or a function, not \" +\n        typeof superClass\n    );\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass)\n    Object.setPrototypeOf\n      ? Object.setPrototypeOf(subClass, superClass)\n      : (subClass.__proto__ = superClass);\n}\n\n// Modules provided by RN:\n/**\n * Superclass that provides methods to access the underlying native component.\n * This can be useful when you want to focus a view or measure its dimensions.\n *\n * Methods implemented by this class are available on most default components\n * provided by React Native. However, they are *not* available on composite\n * components that are not directly backed by a native view. For more\n * information, see [Direct Manipulation](docs/direct-manipulation.html).\n *\n * @abstract\n */\n\nvar ReactNativeComponent = (function(_React$Component) {\n  _inherits(ReactNativeComponent, _React$Component);\n\n  function ReactNativeComponent() {\n    _classCallCheck$1(this, ReactNativeComponent);\n\n    return _possibleConstructorReturn(\n      this,\n      _React$Component.apply(this, arguments)\n    );\n  }\n\n  /**\n   * Removes focus. This is the opposite of `focus()`.\n   */\n\n  /**\n   * Due to bugs in Flow's handling of React.createClass, some fields already\n   * declared in the base class need to be redeclared below.\n   */\n  ReactNativeComponent.prototype.blur = function blur() {\n    TextInputState.blurTextInput(findNumericNodeHandleFiber(this));\n  };\n\n  /**\n   * Requests focus. The exact behavior depends on the platform and view.\n   */\n\n  ReactNativeComponent.prototype.focus = function focus() {\n    TextInputState.focusTextInput(findNumericNodeHandleFiber(this));\n  };\n\n  /**\n   * Measures the on-screen location and dimensions. If successful, the callback\n   * will be called asynchronously with the following arguments:\n   *\n   *  - x\n   *  - y\n   *  - width\n   *  - height\n   *  - pageX\n   *  - pageY\n   *\n   * These values are not available until after natives rendering completes. If\n   * you need the measurements as soon as possible, consider using the\n   * [`onLayout` prop](docs/view.html#onlayout) instead.\n   */\n\n  ReactNativeComponent.prototype.measure = function measure(callback) {\n    UIManager.measure(\n      findNumericNodeHandleFiber(this),\n      mountSafeCallback(this, callback)\n    );\n  };\n\n  /**\n   * Measures the on-screen location and dimensions. Even if the React Native\n   * root view is embedded within another native view, this method will give you\n   * the absolute coordinates measured from the window. If successful, the\n   * callback will be called asynchronously with the following arguments:\n   *\n   *  - x\n   *  - y\n   *  - width\n   *  - height\n   *\n   * These values are not available until after natives rendering completes.\n   */\n\n  ReactNativeComponent.prototype.measureInWindow = function measureInWindow(\n    callback\n  ) {\n    UIManager.measureInWindow(\n      findNumericNodeHandleFiber(this),\n      mountSafeCallback(this, callback)\n    );\n  };\n\n  /**\n   * Similar to [`measure()`](#measure), but the resulting location will be\n   * relative to the supplied ancestor's location.\n   *\n   * Obtain a native node handle with `ReactNative.findNodeHandle(component)`.\n   */\n\n  ReactNativeComponent.prototype.measureLayout = function measureLayout(\n    relativeToNativeNode,\n    onSuccess,\n    onFail /* currently unused */\n  ) {\n    UIManager.measureLayout(\n      findNumericNodeHandleFiber(this),\n      relativeToNativeNode,\n      mountSafeCallback(this, onFail),\n      mountSafeCallback(this, onSuccess)\n    );\n  };\n\n  /**\n   * This function sends props straight to native. They will not participate in\n   * future diff process - this means that if you do not include them in the\n   * next render, they will remain active (see [Direct\n   * Manipulation](docs/direct-manipulation.html)).\n   */\n\n  ReactNativeComponent.prototype.setNativeProps = function setNativeProps(\n    nativeProps\n  ) {\n    // Class components don't have viewConfig -> validateAttributes.\n    // Nor does it make sense to set native props on a non-native component.\n    // Instead, find the nearest host component and set props on it.\n    // Use findNodeHandle() rather than ReactNative.findNodeHandle() because\n    // We want the instance/wrapper (not the native tag).\n    var maybeInstance = void 0;\n\n    // Fiber errors if findNodeHandle is called for an umounted component.\n    // Tests using ReactTestRenderer will trigger this case indirectly.\n    // Mimicking stack behavior, we should silently ignore this case.\n    // TODO Fix ReactTestRenderer so we can remove this try/catch.\n    try {\n      maybeInstance = findNodeHandle(this);\n    } catch (error) {}\n\n    // If there is no host component beneath this we should fail silently.\n    // This is not an error; it could mean a class component rendered null.\n    if (maybeInstance == null) {\n      return;\n    }\n\n    var viewConfig =\n      maybeInstance.viewConfig || maybeInstance.canonical.viewConfig;\n\n    var updatePayload = create(nativeProps, viewConfig.validAttributes);\n\n    // Avoid the overhead of bridge calls if there's no update.\n    // This is an expensive no-op for Android, and causes an unnecessary\n    // view invalidation for certain components (eg RCTTextInput) on iOS.\n    if (updatePayload != null) {\n      UIManager.updateView(\n        maybeInstance._nativeTag,\n        viewConfig.uiViewClassName,\n        updatePayload\n      );\n    }\n  };\n\n  return ReactNativeComponent;\n})(React.Component);\n\n// Don't change these two values. They're used by React Dev Tools.\nvar NoEffect = /*              */ 0;\nvar PerformedWork = /*         */ 1;\n\n// You can change the rest (and add more).\nvar Placement = /*             */ 2;\nvar Update = /*                */ 4;\nvar PlacementAndUpdate = /*    */ 6;\nvar Deletion = /*              */ 8;\nvar ContentReset = /*          */ 16;\nvar Callback = /*              */ 32;\nvar DidCapture = /*            */ 64;\nvar Ref = /*                   */ 128;\nvar ErrLog = /*                */ 256;\n\n// Union of all host effects\nvar HostEffectMask = /*        */ 511;\n\nvar Incomplete = /*            */ 512;\nvar ShouldCapture = /*         */ 1024;\n\nvar MOUNTING = 1;\nvar MOUNTED = 2;\nvar UNMOUNTED = 3;\n\nfunction isFiberMountedImpl(fiber) {\n  var node = fiber;\n  if (!fiber.alternate) {\n    // If there is no alternate, this might be a new tree that isn't inserted\n    // yet. If it is, then it will have a pending insertion effect on it.\n    if ((node.effectTag & Placement) !== NoEffect) {\n      return MOUNTING;\n    }\n    while (node[\"return\"]) {\n      node = node[\"return\"];\n      if ((node.effectTag & Placement) !== NoEffect) {\n        return MOUNTING;\n      }\n    }\n  } else {\n    while (node[\"return\"]) {\n      node = node[\"return\"];\n    }\n  }\n  if (node.tag === HostRoot) {\n    // TODO: Check if this was a nested HostRoot when used with\n    // renderContainerIntoSubtree.\n    return MOUNTED;\n  }\n  // If we didn't hit the root, that means that we're in an disconnected tree\n  // that has been unmounted.\n  return UNMOUNTED;\n}\n\nfunction isFiberMounted(fiber) {\n  return isFiberMountedImpl(fiber) === MOUNTED;\n}\n\nfunction isMounted(component) {\n  {\n    var owner = ReactCurrentOwner.current;\n    if (owner !== null && owner.tag === ClassComponent) {\n      var ownerFiber = owner;\n      var instance = ownerFiber.stateNode;\n      warning(\n        instance._warnedAboutRefsInRender,\n        \"%s is accessing isMounted inside its render() function. \" +\n          \"render() should be a pure function of props and state. It should \" +\n          \"never access something that requires stale data from the previous \" +\n          \"render, such as refs. Move this logic to componentDidMount and \" +\n          \"componentDidUpdate instead.\",\n        getComponentName(ownerFiber) || \"A component\"\n      );\n      instance._warnedAboutRefsInRender = true;\n    }\n  }\n\n  var fiber = get(component);\n  if (!fiber) {\n    return false;\n  }\n  return isFiberMountedImpl(fiber) === MOUNTED;\n}\n\nfunction assertIsMounted(fiber) {\n  invariant(\n    isFiberMountedImpl(fiber) === MOUNTED,\n    \"Unable to find node on an unmounted component.\"\n  );\n}\n\nfunction findCurrentFiberUsingSlowPath(fiber) {\n  var alternate = fiber.alternate;\n  if (!alternate) {\n    // If there is no alternate, then we only need to check if it is mounted.\n    var state = isFiberMountedImpl(fiber);\n    invariant(\n      state !== UNMOUNTED,\n      \"Unable to find node on an unmounted component.\"\n    );\n    if (state === MOUNTING) {\n      return null;\n    }\n    return fiber;\n  }\n  // If we have two possible branches, we'll walk backwards up to the root\n  // to see what path the root points to. On the way we may hit one of the\n  // special cases and we'll deal with them.\n  var a = fiber;\n  var b = alternate;\n  while (true) {\n    var parentA = a[\"return\"];\n    var parentB = parentA ? parentA.alternate : null;\n    if (!parentA || !parentB) {\n      // We're at the root.\n      break;\n    }\n\n    // If both copies of the parent fiber point to the same child, we can\n    // assume that the child is current. This happens when we bailout on low\n    // priority: the bailed out fiber's child reuses the current child.\n    if (parentA.child === parentB.child) {\n      var child = parentA.child;\n      while (child) {\n        if (child === a) {\n          // We've determined that A is the current branch.\n          assertIsMounted(parentA);\n          return fiber;\n        }\n        if (child === b) {\n          // We've determined that B is the current branch.\n          assertIsMounted(parentA);\n          return alternate;\n        }\n        child = child.sibling;\n      }\n      // We should never have an alternate for any mounting node. So the only\n      // way this could possibly happen is if this was unmounted, if at all.\n      invariant(false, \"Unable to find node on an unmounted component.\");\n    }\n\n    if (a[\"return\"] !== b[\"return\"]) {\n      // The return pointer of A and the return pointer of B point to different\n      // fibers. We assume that return pointers never criss-cross, so A must\n      // belong to the child set of A.return, and B must belong to the child\n      // set of B.return.\n      a = parentA;\n      b = parentB;\n    } else {\n      // The return pointers point to the same fiber. We'll have to use the\n      // default, slow path: scan the child sets of each parent alternate to see\n      // which child belongs to which set.\n      //\n      // Search parent A's child set\n      var didFindChild = false;\n      var _child = parentA.child;\n      while (_child) {\n        if (_child === a) {\n          didFindChild = true;\n          a = parentA;\n          b = parentB;\n          break;\n        }\n        if (_child === b) {\n          didFindChild = true;\n          b = parentA;\n          a = parentB;\n          break;\n        }\n        _child = _child.sibling;\n      }\n      if (!didFindChild) {\n        // Search parent B's child set\n        _child = parentB.child;\n        while (_child) {\n          if (_child === a) {\n            didFindChild = true;\n            a = parentB;\n            b = parentA;\n            break;\n          }\n          if (_child === b) {\n            didFindChild = true;\n            b = parentB;\n            a = parentA;\n            break;\n          }\n          _child = _child.sibling;\n        }\n        invariant(\n          didFindChild,\n          \"Child was not found in either parent set. This indicates a bug \" +\n            \"in React related to the return pointer. Please file an issue.\"\n        );\n      }\n    }\n\n    invariant(\n      a.alternate === b,\n      \"Return fibers should always be each others' alternates. \" +\n        \"This error is likely caused by a bug in React. Please file an issue.\"\n    );\n  }\n  // If the root is not a host container, we're in a disconnected tree. I.e.\n  // unmounted.\n  invariant(\n    a.tag === HostRoot,\n    \"Unable to find node on an unmounted component.\"\n  );\n  if (a.stateNode.current === a) {\n    // We've determined that A is the current branch.\n    return fiber;\n  }\n  // Otherwise B has to be current branch.\n  return alternate;\n}\n\nfunction findCurrentHostFiber(parent) {\n  var currentParent = findCurrentFiberUsingSlowPath(parent);\n  if (!currentParent) {\n    return null;\n  }\n\n  // Next we'll drill down this component to find the first HostComponent/Text.\n  var node = currentParent;\n  while (true) {\n    if (node.tag === HostComponent || node.tag === HostText) {\n      return node;\n    } else if (node.child) {\n      node.child[\"return\"] = node;\n      node = node.child;\n      continue;\n    }\n    if (node === currentParent) {\n      return null;\n    }\n    while (!node.sibling) {\n      if (!node[\"return\"] || node[\"return\"] === currentParent) {\n        return null;\n      }\n      node = node[\"return\"];\n    }\n    node.sibling[\"return\"] = node[\"return\"];\n    node = node.sibling;\n  }\n  // Flow needs the return null here, but ESLint complains about it.\n  // eslint-disable-next-line no-unreachable\n  return null;\n}\n\nfunction findCurrentHostFiberWithNoPortals(parent) {\n  var currentParent = findCurrentFiberUsingSlowPath(parent);\n  if (!currentParent) {\n    return null;\n  }\n\n  // Next we'll drill down this component to find the first HostComponent/Text.\n  var node = currentParent;\n  while (true) {\n    if (node.tag === HostComponent || node.tag === HostText) {\n      return node;\n    } else if (node.child && node.tag !== HostPortal) {\n      node.child[\"return\"] = node;\n      node = node.child;\n      continue;\n    }\n    if (node === currentParent) {\n      return null;\n    }\n    while (!node.sibling) {\n      if (!node[\"return\"] || node[\"return\"] === currentParent) {\n        return null;\n      }\n      node = node[\"return\"];\n    }\n    node.sibling[\"return\"] = node[\"return\"];\n    node = node.sibling;\n  }\n  // Flow needs the return null here, but ESLint complains about it.\n  // eslint-disable-next-line no-unreachable\n  return null;\n}\n\nvar valueStack = [];\n\nvar fiberStack = void 0;\n\n{\n  fiberStack = [];\n}\n\nvar index = -1;\n\nfunction createCursor(defaultValue) {\n  return {\n    current: defaultValue\n  };\n}\n\nfunction pop(cursor, fiber) {\n  if (index < 0) {\n    {\n      warning(false, \"Unexpected pop.\");\n    }\n    return;\n  }\n\n  {\n    if (fiber !== fiberStack[index]) {\n      warning(false, \"Unexpected Fiber popped.\");\n    }\n  }\n\n  cursor.current = valueStack[index];\n\n  valueStack[index] = null;\n\n  {\n    fiberStack[index] = null;\n  }\n\n  index--;\n}\n\nfunction push(cursor, value, fiber) {\n  index++;\n\n  valueStack[index] = cursor.current;\n\n  {\n    fiberStack[index] = fiber;\n  }\n\n  cursor.current = value;\n}\n\nfunction reset() {\n  while (index > -1) {\n    valueStack[index] = null;\n\n    {\n      fiberStack[index] = null;\n    }\n\n    index--;\n  }\n}\n\nvar describeComponentFrame = function(name, source, ownerName) {\n  return (\n    \"\\n    in \" +\n    (name || \"Unknown\") +\n    (source\n      ? \" (at \" +\n        source.fileName.replace(/^.*[\\\\\\/]/, \"\") +\n        \":\" +\n        source.lineNumber +\n        \")\"\n      : ownerName ? \" (created by \" + ownerName + \")\" : \"\")\n  );\n};\n\nfunction describeFiber(fiber) {\n  switch (fiber.tag) {\n    case IndeterminateComponent:\n    case FunctionalComponent:\n    case ClassComponent:\n    case HostComponent:\n      var owner = fiber._debugOwner;\n      var source = fiber._debugSource;\n      var name = getComponentName(fiber);\n      var ownerName = null;\n      if (owner) {\n        ownerName = getComponentName(owner);\n      }\n      return describeComponentFrame(name, source, ownerName);\n    default:\n      return \"\";\n  }\n}\n\n// This function can only be called with a work-in-progress fiber and\n// only during begin or complete phase. Do not call it under any other\n// circumstances.\nfunction getStackAddendumByWorkInProgressFiber(workInProgress) {\n  var info = \"\";\n  var node = workInProgress;\n  do {\n    info += describeFiber(node);\n    // Otherwise this return pointer might point to the wrong tree:\n    node = node[\"return\"];\n  } while (node);\n  return info;\n}\n\nfunction getCurrentFiberOwnerName() {\n  {\n    var fiber = ReactDebugCurrentFiber.current;\n    if (fiber === null) {\n      return null;\n    }\n    var owner = fiber._debugOwner;\n    if (owner !== null && typeof owner !== \"undefined\") {\n      return getComponentName(owner);\n    }\n  }\n  return null;\n}\n\nfunction getCurrentFiberStackAddendum() {\n  {\n    var fiber = ReactDebugCurrentFiber.current;\n    if (fiber === null) {\n      return null;\n    }\n    // Safe because if current fiber exists, we are reconciling,\n    // and it is guaranteed to be the work-in-progress version.\n    return getStackAddendumByWorkInProgressFiber(fiber);\n  }\n  return null;\n}\n\nfunction resetCurrentFiber() {\n  ReactDebugCurrentFrame.getCurrentStack = null;\n  ReactDebugCurrentFiber.current = null;\n  ReactDebugCurrentFiber.phase = null;\n}\n\nfunction setCurrentFiber(fiber) {\n  ReactDebugCurrentFrame.getCurrentStack = getCurrentFiberStackAddendum;\n  ReactDebugCurrentFiber.current = fiber;\n  ReactDebugCurrentFiber.phase = null;\n}\n\nfunction setCurrentPhase(phase) {\n  ReactDebugCurrentFiber.phase = phase;\n}\n\nvar ReactDebugCurrentFiber = {\n  current: null,\n  phase: null,\n  resetCurrentFiber: resetCurrentFiber,\n  setCurrentFiber: setCurrentFiber,\n  setCurrentPhase: setCurrentPhase,\n  getCurrentFiberOwnerName: getCurrentFiberOwnerName,\n  getCurrentFiberStackAddendum: getCurrentFiberStackAddendum\n};\n\n// Re-export dynamic flags from the fbsource version.\nvar _require = require(\"ReactFeatureFlags\");\n\nvar enableGetDerivedStateFromCatch = _require.enableGetDerivedStateFromCatch;\nvar debugRenderPhaseSideEffects = _require.debugRenderPhaseSideEffects;\nvar debugRenderPhaseSideEffectsForStrictMode =\n  _require.debugRenderPhaseSideEffectsForStrictMode;\nvar warnAboutDeprecatedLifecycles = _require.warnAboutDeprecatedLifecycles;\nvar replayFailedUnitOfWorkWithInvokeGuardedCallback =\n  _require.replayFailedUnitOfWorkWithInvokeGuardedCallback;\n\nvar enableUserTimingAPI = true;\nvar enableMutatingReconciler = true;\nvar enableNoopReconciler = false;\nvar enablePersistentReconciler = false;\n\n// Only used in www builds.\n\n// Prefix measurements so that it's possible to filter them.\n// Longer prefixes are hard to read in DevTools.\nvar reactEmoji = \"\\u269B\";\nvar warningEmoji = \"\\u26D4\";\nvar supportsUserTiming =\n  typeof performance !== \"undefined\" &&\n  typeof performance.mark === \"function\" &&\n  typeof performance.clearMarks === \"function\" &&\n  typeof performance.measure === \"function\" &&\n  typeof performance.clearMeasures === \"function\";\n\n// Keep track of current fiber so that we know the path to unwind on pause.\n// TODO: this looks the same as nextUnitOfWork in scheduler. Can we unify them?\nvar currentFiber = null;\n// If we're in the middle of user code, which fiber and method is it?\n// Reusing `currentFiber` would be confusing for this because user code fiber\n// can change during commit phase too, but we don't need to unwind it (since\n// lifecycles in the commit phase don't resemble a tree).\nvar currentPhase = null;\nvar currentPhaseFiber = null;\n// Did lifecycle hook schedule an update? This is often a performance problem,\n// so we will keep track of it, and include it in the report.\n// Track commits caused by cascading updates.\nvar isCommitting = false;\nvar hasScheduledUpdateInCurrentCommit = false;\nvar hasScheduledUpdateInCurrentPhase = false;\nvar commitCountInCurrentWorkLoop = 0;\nvar effectCountInCurrentCommit = 0;\nvar isWaitingForCallback = false;\n// During commits, we only show a measurement once per method name\n// to avoid stretch the commit phase with measurement overhead.\nvar labelsInCurrentCommit = new Set();\n\nvar formatMarkName = function(markName) {\n  return reactEmoji + \" \" + markName;\n};\n\nvar formatLabel = function(label, warning$$1) {\n  var prefix = warning$$1 ? warningEmoji + \" \" : reactEmoji + \" \";\n  var suffix = warning$$1 ? \" Warning: \" + warning$$1 : \"\";\n  return \"\" + prefix + label + suffix;\n};\n\nvar beginMark = function(markName) {\n  performance.mark(formatMarkName(markName));\n};\n\nvar clearMark = function(markName) {\n  performance.clearMarks(formatMarkName(markName));\n};\n\nvar endMark = function(label, markName, warning$$1) {\n  var formattedMarkName = formatMarkName(markName);\n  var formattedLabel = formatLabel(label, warning$$1);\n  try {\n    performance.measure(formattedLabel, formattedMarkName);\n  } catch (err) {}\n  // If previous mark was missing for some reason, this will throw.\n  // This could only happen if React crashed in an unexpected place earlier.\n  // Don't pile on with more errors.\n\n  // Clear marks immediately to avoid growing buffer.\n  performance.clearMarks(formattedMarkName);\n  performance.clearMeasures(formattedLabel);\n};\n\nvar getFiberMarkName = function(label, debugID) {\n  return label + \" (#\" + debugID + \")\";\n};\n\nvar getFiberLabel = function(componentName, isMounted, phase) {\n  if (phase === null) {\n    // These are composite component total time measurements.\n    return componentName + \" [\" + (isMounted ? \"update\" : \"mount\") + \"]\";\n  } else {\n    // Composite component methods.\n    return componentName + \".\" + phase;\n  }\n};\n\nvar beginFiberMark = function(fiber, phase) {\n  var componentName = getComponentName(fiber) || \"Unknown\";\n  var debugID = fiber._debugID;\n  var isMounted = fiber.alternate !== null;\n  var label = getFiberLabel(componentName, isMounted, phase);\n\n  if (isCommitting && labelsInCurrentCommit.has(label)) {\n    // During the commit phase, we don't show duplicate labels because\n    // there is a fixed overhead for every measurement, and we don't\n    // want to stretch the commit phase beyond necessary.\n    return false;\n  }\n  labelsInCurrentCommit.add(label);\n\n  var markName = getFiberMarkName(label, debugID);\n  beginMark(markName);\n  return true;\n};\n\nvar clearFiberMark = function(fiber, phase) {\n  var componentName = getComponentName(fiber) || \"Unknown\";\n  var debugID = fiber._debugID;\n  var isMounted = fiber.alternate !== null;\n  var label = getFiberLabel(componentName, isMounted, phase);\n  var markName = getFiberMarkName(label, debugID);\n  clearMark(markName);\n};\n\nvar endFiberMark = function(fiber, phase, warning$$1) {\n  var componentName = getComponentName(fiber) || \"Unknown\";\n  var debugID = fiber._debugID;\n  var isMounted = fiber.alternate !== null;\n  var label = getFiberLabel(componentName, isMounted, phase);\n  var markName = getFiberMarkName(label, debugID);\n  endMark(label, markName, warning$$1);\n};\n\nvar shouldIgnoreFiber = function(fiber) {\n  // Host components should be skipped in the timeline.\n  // We could check typeof fiber.type, but does this work with RN?\n  switch (fiber.tag) {\n    case HostRoot:\n    case HostComponent:\n    case HostText:\n    case HostPortal:\n    case CallComponent:\n    case ReturnComponent:\n    case Fragment:\n    case ContextProvider:\n    case ContextConsumer:\n      return true;\n    default:\n      return false;\n  }\n};\n\nvar clearPendingPhaseMeasurement = function() {\n  if (currentPhase !== null && currentPhaseFiber !== null) {\n    clearFiberMark(currentPhaseFiber, currentPhase);\n  }\n  currentPhaseFiber = null;\n  currentPhase = null;\n  hasScheduledUpdateInCurrentPhase = false;\n};\n\nvar pauseTimers = function() {\n  // Stops all currently active measurements so that they can be resumed\n  // if we continue in a later deferred loop from the same unit of work.\n  var fiber = currentFiber;\n  while (fiber) {\n    if (fiber._debugIsCurrentlyTiming) {\n      endFiberMark(fiber, null, null);\n    }\n    fiber = fiber[\"return\"];\n  }\n};\n\nvar resumeTimersRecursively = function(fiber) {\n  if (fiber[\"return\"] !== null) {\n    resumeTimersRecursively(fiber[\"return\"]);\n  }\n  if (fiber._debugIsCurrentlyTiming) {\n    beginFiberMark(fiber, null);\n  }\n};\n\nvar resumeTimers = function() {\n  // Resumes all measurements that were active during the last deferred loop.\n  if (currentFiber !== null) {\n    resumeTimersRecursively(currentFiber);\n  }\n};\n\nfunction recordEffect() {\n  if (enableUserTimingAPI) {\n    effectCountInCurrentCommit++;\n  }\n}\n\nfunction recordScheduleUpdate() {\n  if (enableUserTimingAPI) {\n    if (isCommitting) {\n      hasScheduledUpdateInCurrentCommit = true;\n    }\n    if (\n      currentPhase !== null &&\n      currentPhase !== \"componentWillMount\" &&\n      currentPhase !== \"componentWillReceiveProps\"\n    ) {\n      hasScheduledUpdateInCurrentPhase = true;\n    }\n  }\n}\n\nfunction startRequestCallbackTimer() {\n  if (enableUserTimingAPI) {\n    if (supportsUserTiming && !isWaitingForCallback) {\n      isWaitingForCallback = true;\n      beginMark(\"(Waiting for async callback...)\");\n    }\n  }\n}\n\nfunction stopRequestCallbackTimer(didExpire) {\n  if (enableUserTimingAPI) {\n    if (supportsUserTiming) {\n      isWaitingForCallback = false;\n      var warning$$1 = didExpire ? \"React was blocked by main thread\" : null;\n      endMark(\n        \"(Waiting for async callback...)\",\n        \"(Waiting for async callback...)\",\n        warning$$1\n      );\n    }\n  }\n}\n\nfunction startWorkTimer(fiber) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n      return;\n    }\n    // If we pause, this is the fiber to unwind from.\n    currentFiber = fiber;\n    if (!beginFiberMark(fiber, null)) {\n      return;\n    }\n    fiber._debugIsCurrentlyTiming = true;\n  }\n}\n\nfunction cancelWorkTimer(fiber) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n      return;\n    }\n    // Remember we shouldn't complete measurement for this fiber.\n    // Otherwise flamechart will be deep even for small updates.\n    fiber._debugIsCurrentlyTiming = false;\n    clearFiberMark(fiber, null);\n  }\n}\n\nfunction stopWorkTimer(fiber) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n      return;\n    }\n    // If we pause, its parent is the fiber to unwind from.\n    currentFiber = fiber[\"return\"];\n    if (!fiber._debugIsCurrentlyTiming) {\n      return;\n    }\n    fiber._debugIsCurrentlyTiming = false;\n    endFiberMark(fiber, null, null);\n  }\n}\n\nfunction stopFailedWorkTimer(fiber) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n      return;\n    }\n    // If we pause, its parent is the fiber to unwind from.\n    currentFiber = fiber[\"return\"];\n    if (!fiber._debugIsCurrentlyTiming) {\n      return;\n    }\n    fiber._debugIsCurrentlyTiming = false;\n    var warning$$1 = \"An error was thrown inside this error boundary\";\n    endFiberMark(fiber, null, warning$$1);\n  }\n}\n\nfunction startPhaseTimer(fiber, phase) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    clearPendingPhaseMeasurement();\n    if (!beginFiberMark(fiber, phase)) {\n      return;\n    }\n    currentPhaseFiber = fiber;\n    currentPhase = phase;\n  }\n}\n\nfunction stopPhaseTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    if (currentPhase !== null && currentPhaseFiber !== null) {\n      var warning$$1 = hasScheduledUpdateInCurrentPhase\n        ? \"Scheduled a cascading update\"\n        : null;\n      endFiberMark(currentPhaseFiber, currentPhase, warning$$1);\n    }\n    currentPhase = null;\n    currentPhaseFiber = null;\n  }\n}\n\nfunction startWorkLoopTimer(nextUnitOfWork) {\n  if (enableUserTimingAPI) {\n    currentFiber = nextUnitOfWork;\n    if (!supportsUserTiming) {\n      return;\n    }\n    commitCountInCurrentWorkLoop = 0;\n    // This is top level call.\n    // Any other measurements are performed within.\n    beginMark(\"(React Tree Reconciliation)\");\n    // Resume any measurements that were in progress during the last loop.\n    resumeTimers();\n  }\n}\n\nfunction stopWorkLoopTimer(interruptedBy) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    var warning$$1 = null;\n    if (interruptedBy !== null) {\n      if (interruptedBy.tag === HostRoot) {\n        warning$$1 = \"A top-level update interrupted the previous render\";\n      } else {\n        var componentName = getComponentName(interruptedBy) || \"Unknown\";\n        warning$$1 =\n          \"An update to \" + componentName + \" interrupted the previous render\";\n      }\n    } else if (commitCountInCurrentWorkLoop > 1) {\n      warning$$1 = \"There were cascading updates\";\n    }\n    commitCountInCurrentWorkLoop = 0;\n    // Pause any measurements until the next loop.\n    pauseTimers();\n    endMark(\n      \"(React Tree Reconciliation)\",\n      \"(React Tree Reconciliation)\",\n      warning$$1\n    );\n  }\n}\n\nfunction startCommitTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    isCommitting = true;\n    hasScheduledUpdateInCurrentCommit = false;\n    labelsInCurrentCommit.clear();\n    beginMark(\"(Committing Changes)\");\n  }\n}\n\nfunction stopCommitTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n\n    var warning$$1 = null;\n    if (hasScheduledUpdateInCurrentCommit) {\n      warning$$1 = \"Lifecycle hook scheduled a cascading update\";\n    } else if (commitCountInCurrentWorkLoop > 0) {\n      warning$$1 = \"Caused by a cascading update in earlier commit\";\n    }\n    hasScheduledUpdateInCurrentCommit = false;\n    commitCountInCurrentWorkLoop++;\n    isCommitting = false;\n    labelsInCurrentCommit.clear();\n\n    endMark(\"(Committing Changes)\", \"(Committing Changes)\", warning$$1);\n  }\n}\n\nfunction startCommitHostEffectsTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    effectCountInCurrentCommit = 0;\n    beginMark(\"(Committing Host Effects)\");\n  }\n}\n\nfunction stopCommitHostEffectsTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    var count = effectCountInCurrentCommit;\n    effectCountInCurrentCommit = 0;\n    endMark(\n      \"(Committing Host Effects: \" + count + \" Total)\",\n      \"(Committing Host Effects)\",\n      null\n    );\n  }\n}\n\nfunction startCommitLifeCyclesTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    effectCountInCurrentCommit = 0;\n    beginMark(\"(Calling Lifecycle Methods)\");\n  }\n}\n\nfunction stopCommitLifeCyclesTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    var count = effectCountInCurrentCommit;\n    effectCountInCurrentCommit = 0;\n    endMark(\n      \"(Calling Lifecycle Methods: \" + count + \" Total)\",\n      \"(Calling Lifecycle Methods)\",\n      null\n    );\n  }\n}\n\nvar warnedAboutMissingGetChildContext = void 0;\n\n{\n  warnedAboutMissingGetChildContext = {};\n}\n\n// A cursor to the current merged context object on the stack.\nvar contextStackCursor = createCursor(emptyObject);\n// A cursor to a boolean indicating whether the context has changed.\nvar didPerformWorkStackCursor = createCursor(false);\n// Keep track of the previous context object that was on the stack.\n// We use this to get access to the parent context after we have already\n// pushed the next context provider, and now need to merge their contexts.\nvar previousContext = emptyObject;\n\nfunction getUnmaskedContext(workInProgress) {\n  var hasOwnContext = isContextProvider(workInProgress);\n  if (hasOwnContext) {\n    // If the fiber is a context provider itself, when we read its context\n    // we have already pushed its own child context on the stack. A context\n    // provider should not \"see\" its own child context. Therefore we read the\n    // previous (parent) context instead for a context provider.\n    return previousContext;\n  }\n  return contextStackCursor.current;\n}\n\nfunction cacheContext(workInProgress, unmaskedContext, maskedContext) {\n  var instance = workInProgress.stateNode;\n  instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;\n  instance.__reactInternalMemoizedMaskedChildContext = maskedContext;\n}\n\nfunction getMaskedContext(workInProgress, unmaskedContext) {\n  var type = workInProgress.type;\n  var contextTypes = type.contextTypes;\n  if (!contextTypes) {\n    return emptyObject;\n  }\n\n  // Avoid recreating masked context unless unmasked context has changed.\n  // Failing to do this will result in unnecessary calls to componentWillReceiveProps.\n  // This may trigger infinite loops if componentWillReceiveProps calls setState.\n  var instance = workInProgress.stateNode;\n  if (\n    instance &&\n    instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext\n  ) {\n    return instance.__reactInternalMemoizedMaskedChildContext;\n  }\n\n  var context = {};\n  for (var key in contextTypes) {\n    context[key] = unmaskedContext[key];\n  }\n\n  {\n    var name = getComponentName(workInProgress) || \"Unknown\";\n    checkPropTypes(\n      contextTypes,\n      context,\n      \"context\",\n      name,\n      ReactDebugCurrentFiber.getCurrentFiberStackAddendum\n    );\n  }\n\n  // Cache unmasked context so we can avoid recreating masked context unless necessary.\n  // Context is created before the class component is instantiated so check for instance.\n  if (instance) {\n    cacheContext(workInProgress, unmaskedContext, context);\n  }\n\n  return context;\n}\n\nfunction hasContextChanged() {\n  return didPerformWorkStackCursor.current;\n}\n\nfunction isContextConsumer(fiber) {\n  return fiber.tag === ClassComponent && fiber.type.contextTypes != null;\n}\n\nfunction isContextProvider(fiber) {\n  return fiber.tag === ClassComponent && fiber.type.childContextTypes != null;\n}\n\nfunction popContextProvider(fiber) {\n  if (!isContextProvider(fiber)) {\n    return;\n  }\n\n  pop(didPerformWorkStackCursor, fiber);\n  pop(contextStackCursor, fiber);\n}\n\nfunction popTopLevelContextObject(fiber) {\n  pop(didPerformWorkStackCursor, fiber);\n  pop(contextStackCursor, fiber);\n}\n\nfunction pushTopLevelContextObject(fiber, context, didChange) {\n  invariant(\n    contextStackCursor.cursor == null,\n    \"Unexpected context found on stack. \" +\n      \"This error is likely caused by a bug in React. Please file an issue.\"\n  );\n\n  push(contextStackCursor, context, fiber);\n  push(didPerformWorkStackCursor, didChange, fiber);\n}\n\nfunction processChildContext(fiber, parentContext) {\n  var instance = fiber.stateNode;\n  var childContextTypes = fiber.type.childContextTypes;\n\n  // TODO (bvaughn) Replace this behavior with an invariant() in the future.\n  // It has only been added in Fiber to match the (unintentional) behavior in Stack.\n  if (typeof instance.getChildContext !== \"function\") {\n    {\n      var componentName = getComponentName(fiber) || \"Unknown\";\n\n      if (!warnedAboutMissingGetChildContext[componentName]) {\n        warnedAboutMissingGetChildContext[componentName] = true;\n        warning(\n          false,\n          \"%s.childContextTypes is specified but there is no getChildContext() method \" +\n            \"on the instance. You can either define getChildContext() on %s or remove \" +\n            \"childContextTypes from it.\",\n          componentName,\n          componentName\n        );\n      }\n    }\n    return parentContext;\n  }\n\n  var childContext = void 0;\n  {\n    ReactDebugCurrentFiber.setCurrentPhase(\"getChildContext\");\n  }\n  startPhaseTimer(fiber, \"getChildContext\");\n  childContext = instance.getChildContext();\n  stopPhaseTimer();\n  {\n    ReactDebugCurrentFiber.setCurrentPhase(null);\n  }\n  for (var contextKey in childContext) {\n    invariant(\n      contextKey in childContextTypes,\n      '%s.getChildContext(): key \"%s\" is not defined in childContextTypes.',\n      getComponentName(fiber) || \"Unknown\",\n      contextKey\n    );\n  }\n  {\n    var name = getComponentName(fiber) || \"Unknown\";\n    checkPropTypes(\n      childContextTypes,\n      childContext,\n      \"child context\",\n      name,\n      // In practice, there is one case in which we won't get a stack. It's when\n      // somebody calls unstable_renderSubtreeIntoContainer() and we process\n      // context from the parent component instance. The stack will be missing\n      // because it's outside of the reconciliation, and so the pointer has not\n      // been set. This is rare and doesn't matter. We'll also remove that API.\n      ReactDebugCurrentFiber.getCurrentFiberStackAddendum\n    );\n  }\n\n  return Object.assign({}, parentContext, childContext);\n}\n\nfunction pushContextProvider(workInProgress) {\n  if (!isContextProvider(workInProgress)) {\n    return false;\n  }\n\n  var instance = workInProgress.stateNode;\n  // We push the context as early as possible to ensure stack integrity.\n  // If the instance does not exist yet, we will push null at first,\n  // and replace it on the stack later when invalidating the context.\n  var memoizedMergedChildContext =\n    (instance && instance.__reactInternalMemoizedMergedChildContext) ||\n    emptyObject;\n\n  // Remember the parent context so we can merge with it later.\n  // Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.\n  previousContext = contextStackCursor.current;\n  push(contextStackCursor, memoizedMergedChildContext, workInProgress);\n  push(\n    didPerformWorkStackCursor,\n    didPerformWorkStackCursor.current,\n    workInProgress\n  );\n\n  return true;\n}\n\nfunction invalidateContextProvider(workInProgress, didChange) {\n  var instance = workInProgress.stateNode;\n  invariant(\n    instance,\n    \"Expected to have an instance by this point. \" +\n      \"This error is likely caused by a bug in React. Please file an issue.\"\n  );\n\n  if (didChange) {\n    // Merge parent and own context.\n    // Skip this if we're not updating due to sCU.\n    // This avoids unnecessarily recomputing memoized values.\n    var mergedContext = processChildContext(workInProgress, previousContext);\n    instance.__reactInternalMemoizedMergedChildContext = mergedContext;\n\n    // Replace the old (or empty) context with the new one.\n    // It is important to unwind the context in the reverse order.\n    pop(didPerformWorkStackCursor, workInProgress);\n    pop(contextStackCursor, workInProgress);\n    // Now push the new context and mark that it has changed.\n    push(contextStackCursor, mergedContext, workInProgress);\n    push(didPerformWorkStackCursor, didChange, workInProgress);\n  } else {\n    pop(didPerformWorkStackCursor, workInProgress);\n    push(didPerformWorkStackCursor, didChange, workInProgress);\n  }\n}\n\nfunction resetContext() {\n  previousContext = emptyObject;\n  contextStackCursor.current = emptyObject;\n  didPerformWorkStackCursor.current = false;\n}\n\nfunction findCurrentUnmaskedContext(fiber) {\n  // Currently this is only used with renderSubtreeIntoContainer; not sure if it\n  // makes sense elsewhere\n  invariant(\n    isFiberMounted(fiber) && fiber.tag === ClassComponent,\n    \"Expected subtree parent to be a mounted class component. \" +\n      \"This error is likely caused by a bug in React. Please file an issue.\"\n  );\n\n  var node = fiber;\n  while (node.tag !== HostRoot) {\n    if (isContextProvider(node)) {\n      return node.stateNode.__reactInternalMemoizedMergedChildContext;\n    }\n    var parent = node[\"return\"];\n    invariant(\n      parent,\n      \"Found unexpected detached subtree parent. \" +\n        \"This error is likely caused by a bug in React. Please file an issue.\"\n    );\n    node = parent;\n  }\n  return node.stateNode.context;\n}\n\n// Max 31 bit integer. The max integer size in V8 for 32-bit systems.\n// Math.pow(2, 30) - 1\n// 0b111111111111111111111111111111\nvar MAX_SIGNED_31_BIT_INT = 1073741823;\n\n// TODO: Use an opaque type once ESLint et al support the syntax\n\nvar NoWork = 0;\nvar Sync = 1;\nvar Never = MAX_SIGNED_31_BIT_INT;\n\nvar UNIT_SIZE = 10;\nvar MAGIC_NUMBER_OFFSET = 2;\n\n// 1 unit of expiration time represents 10ms.\nfunction msToExpirationTime(ms) {\n  // Always add an offset so that we don't clash with the magic number for NoWork.\n  return ((ms / UNIT_SIZE) | 0) + MAGIC_NUMBER_OFFSET;\n}\n\nfunction expirationTimeToMs(expirationTime) {\n  return (expirationTime - MAGIC_NUMBER_OFFSET) * UNIT_SIZE;\n}\n\nfunction ceiling(num, precision) {\n  return (((num / precision) | 0) + 1) * precision;\n}\n\nfunction computeExpirationBucket(currentTime, expirationInMs, bucketSizeMs) {\n  return ceiling(\n    currentTime + expirationInMs / UNIT_SIZE,\n    bucketSizeMs / UNIT_SIZE\n  );\n}\n\nvar NoContext = 0;\nvar AsyncMode = 1;\nvar StrictMode = 2;\n\nvar hasBadMapPolyfill = void 0;\n\n{\n  hasBadMapPolyfill = false;\n  try {\n    var nonExtensibleObject = Object.preventExtensions({});\n    var testMap = new Map([[nonExtensibleObject, null]]);\n    var testSet = new Set([nonExtensibleObject]);\n    // This is necessary for Rollup to not consider these unused.\n    // https://github.com/rollup/rollup/issues/1771\n    // TODO: we can remove these if Rollup fixes the bug.\n    testMap.set(0, 0);\n    testSet.add(0);\n  } catch (e) {\n    // TODO: Consider warning about bad polyfills\n    hasBadMapPolyfill = true;\n  }\n}\n\n// A Fiber is work on a Component that needs to be done or was done. There can\n// be more than one per component.\n\nvar debugCounter = void 0;\n\n{\n  debugCounter = 1;\n}\n\nfunction FiberNode(tag, pendingProps, key, mode) {\n  // Instance\n  this.tag = tag;\n  this.key = key;\n  this.type = null;\n  this.stateNode = null;\n\n  // Fiber\n  this[\"return\"] = null;\n  this.child = null;\n  this.sibling = null;\n  this.index = 0;\n\n  this.ref = null;\n\n  this.pendingProps = pendingProps;\n  this.memoizedProps = null;\n  this.updateQueue = null;\n  this.memoizedState = null;\n\n  this.mode = mode;\n\n  // Effects\n  this.effectTag = NoEffect;\n  this.nextEffect = null;\n\n  this.firstEffect = null;\n  this.lastEffect = null;\n\n  this.expirationTime = NoWork;\n\n  this.alternate = null;\n\n  {\n    this._debugID = debugCounter++;\n    this._debugSource = null;\n    this._debugOwner = null;\n    this._debugIsCurrentlyTiming = false;\n    if (!hasBadMapPolyfill && typeof Object.preventExtensions === \"function\") {\n      Object.preventExtensions(this);\n    }\n  }\n}\n\n// This is a constructor function, rather than a POJO constructor, still\n// please ensure we do the following:\n// 1) Nobody should add any instance methods on this. Instance methods can be\n//    more difficult to predict when they get optimized and they are almost\n//    never inlined properly in static compilers.\n// 2) Nobody should rely on `instanceof Fiber` for type testing. We should\n//    always know when it is a fiber.\n// 3) We might want to experiment with using numeric keys since they are easier\n//    to optimize in a non-JIT environment.\n// 4) We can easily go from a constructor to a createFiber object literal if that\n//    is faster.\n// 5) It should be easy to port this to a C struct and keep a C implementation\n//    compatible.\nvar createFiber = function(tag, pendingProps, key, mode) {\n  // $FlowFixMe: the shapes are exact here but Flow doesn't like constructors\n  return new FiberNode(tag, pendingProps, key, mode);\n};\n\nfunction shouldConstruct(Component) {\n  return !!(Component.prototype && Component.prototype.isReactComponent);\n}\n\n// This is used to create an alternate fiber to do work on.\nfunction createWorkInProgress(current, pendingProps, expirationTime) {\n  var workInProgress = current.alternate;\n  if (workInProgress === null) {\n    // We use a double buffering pooling technique because we know that we'll\n    // only ever need at most two versions of a tree. We pool the \"other\" unused\n    // node that we're free to reuse. This is lazily created to avoid allocating\n    // extra objects for things that are never updated. It also allow us to\n    // reclaim the extra memory if needed.\n    workInProgress = createFiber(\n      current.tag,\n      pendingProps,\n      current.key,\n      current.mode\n    );\n    workInProgress.type = current.type;\n    workInProgress.stateNode = current.stateNode;\n\n    {\n      // DEV-only fields\n      workInProgress._debugID = current._debugID;\n      workInProgress._debugSource = current._debugSource;\n      workInProgress._debugOwner = current._debugOwner;\n    }\n\n    workInProgress.alternate = current;\n    current.alternate = workInProgress;\n  } else {\n    workInProgress.pendingProps = pendingProps;\n\n    // We already have an alternate.\n    // Reset the effect tag.\n    workInProgress.effectTag = NoEffect;\n\n    // The effect list is no longer valid.\n    workInProgress.nextEffect = null;\n    workInProgress.firstEffect = null;\n    workInProgress.lastEffect = null;\n  }\n\n  workInProgress.expirationTime = expirationTime;\n\n  workInProgress.child = current.child;\n  workInProgress.memoizedProps = current.memoizedProps;\n  workInProgress.memoizedState = current.memoizedState;\n  workInProgress.updateQueue = current.updateQueue;\n\n  // These will be overridden during the parent's reconciliation\n  workInProgress.sibling = current.sibling;\n  workInProgress.index = current.index;\n  workInProgress.ref = current.ref;\n\n  return workInProgress;\n}\n\nfunction createHostRootFiber(isAsync) {\n  var mode = isAsync ? AsyncMode | StrictMode : NoContext;\n  return createFiber(HostRoot, null, null, mode);\n}\n\nfunction createFiberFromElement(element, mode, expirationTime) {\n  var owner = null;\n  {\n    owner = element._owner;\n  }\n\n  var fiber = void 0;\n  var type = element.type;\n  var key = element.key;\n  var pendingProps = element.props;\n\n  var fiberTag = void 0;\n  if (typeof type === \"function\") {\n    fiberTag = shouldConstruct(type) ? ClassComponent : IndeterminateComponent;\n  } else if (typeof type === \"string\") {\n    fiberTag = HostComponent;\n  } else {\n    switch (type) {\n      case REACT_FRAGMENT_TYPE:\n        return createFiberFromFragment(\n          pendingProps.children,\n          mode,\n          expirationTime,\n          key\n        );\n      case REACT_ASYNC_MODE_TYPE:\n        fiberTag = Mode;\n        mode |= AsyncMode | StrictMode;\n        break;\n      case REACT_STRICT_MODE_TYPE:\n        fiberTag = Mode;\n        mode |= StrictMode;\n        break;\n      case REACT_CALL_TYPE:\n        fiberTag = CallComponent;\n        break;\n      case REACT_RETURN_TYPE:\n        fiberTag = ReturnComponent;\n        break;\n      default: {\n        if (typeof type === \"object\" && type !== null) {\n          switch (type.$$typeof) {\n            case REACT_PROVIDER_TYPE:\n              fiberTag = ContextProvider;\n              break;\n            case REACT_CONTEXT_TYPE:\n              // This is a consumer\n              fiberTag = ContextConsumer;\n              break;\n            default:\n              if (typeof type.tag === \"number\") {\n                // Currently assumed to be a continuation and therefore is a\n                // fiber already.\n                // TODO: The yield system is currently broken for updates in\n                // some cases. The reified yield stores a fiber, but we don't\n                // know which fiber that is; the current or a workInProgress?\n                // When the continuation gets rendered here we don't know if we\n                // can reuse that fiber or if we need to clone it. There is\n                // probably a clever way to restructure this.\n                fiber = type;\n                fiber.pendingProps = pendingProps;\n                fiber.expirationTime = expirationTime;\n                return fiber;\n              } else {\n                throwOnInvalidElementType(type, owner);\n              }\n              break;\n          }\n        } else {\n          throwOnInvalidElementType(type, owner);\n        }\n      }\n    }\n  }\n\n  fiber = createFiber(fiberTag, pendingProps, key, mode);\n  fiber.type = type;\n  fiber.expirationTime = expirationTime;\n\n  {\n    fiber._debugSource = element._source;\n    fiber._debugOwner = element._owner;\n  }\n\n  return fiber;\n}\n\nfunction throwOnInvalidElementType(type, owner) {\n  var info = \"\";\n  {\n    if (\n      type === undefined ||\n      (typeof type === \"object\" &&\n        type !== null &&\n        Object.keys(type).length === 0)\n    ) {\n      info +=\n        \" You likely forgot to export your component from the file \" +\n        \"it's defined in, or you might have mixed up default and \" +\n        \"named imports.\";\n    }\n    var ownerName = owner ? getComponentName(owner) : null;\n    if (ownerName) {\n      info += \"\\n\\nCheck the render method of `\" + ownerName + \"`.\";\n    }\n  }\n  invariant(\n    false,\n    \"Element type is invalid: expected a string (for built-in \" +\n      \"components) or a class/function (for composite components) \" +\n      \"but got: %s.%s\",\n    type == null ? type : typeof type,\n    info\n  );\n}\n\nfunction createFiberFromFragment(elements, mode, expirationTime, key) {\n  var fiber = createFiber(Fragment, elements, key, mode);\n  fiber.expirationTime = expirationTime;\n  return fiber;\n}\n\nfunction createFiberFromText(content, mode, expirationTime) {\n  var fiber = createFiber(HostText, content, null, mode);\n  fiber.expirationTime = expirationTime;\n  return fiber;\n}\n\nfunction createFiberFromHostInstanceForDeletion() {\n  var fiber = createFiber(HostComponent, null, null, NoContext);\n  fiber.type = \"DELETED\";\n  return fiber;\n}\n\nfunction createFiberFromPortal(portal, mode, expirationTime) {\n  var pendingProps = portal.children !== null ? portal.children : [];\n  var fiber = createFiber(HostPortal, pendingProps, portal.key, mode);\n  fiber.expirationTime = expirationTime;\n  fiber.stateNode = {\n    containerInfo: portal.containerInfo,\n    pendingChildren: null, // Used by persistent updates\n    implementation: portal.implementation\n  };\n  return fiber;\n}\n\n// TODO: This should be lifted into the renderer.\n\nfunction createFiberRoot(containerInfo, isAsync, hydrate) {\n  // Cyclic construction. This cheats the type system right now because\n  // stateNode is any.\n  var uninitializedFiber = createHostRootFiber(isAsync);\n  var root = {\n    current: uninitializedFiber,\n    containerInfo: containerInfo,\n    pendingChildren: null,\n    pendingCommitExpirationTime: NoWork,\n    finishedWork: null,\n    context: null,\n    pendingContext: null,\n    hydrate: hydrate,\n    remainingExpirationTime: NoWork,\n    firstBatch: null,\n    nextScheduledRoot: null\n  };\n  uninitializedFiber.stateNode = root;\n  return root;\n}\n\nvar onCommitFiberRoot = null;\nvar onCommitFiberUnmount = null;\nvar hasLoggedError = false;\n\nfunction catchErrors(fn) {\n  return function(arg) {\n    try {\n      return fn(arg);\n    } catch (err) {\n      if (true && !hasLoggedError) {\n        hasLoggedError = true;\n        warning(false, \"React DevTools encountered an error: %s\", err);\n      }\n    }\n  };\n}\n\nfunction injectInternals(internals) {\n  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === \"undefined\") {\n    // No DevTools\n    return false;\n  }\n  var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;\n  if (hook.isDisabled) {\n    // This isn't a real property on the hook, but it can be set to opt out\n    // of DevTools integration and associated warnings and logs.\n    // https://github.com/facebook/react/issues/3877\n    return true;\n  }\n  if (!hook.supportsFiber) {\n    {\n      warning(\n        false,\n        \"The installed version of React DevTools is too old and will not work \" +\n          \"with the current version of React. Please update React DevTools. \" +\n          \"https://fb.me/react-devtools\"\n      );\n    }\n    // DevTools exists, even though it doesn't support Fiber.\n    return true;\n  }\n  try {\n    var rendererID = hook.inject(internals);\n    // We have successfully injected, so now it is safe to set up hooks.\n    onCommitFiberRoot = catchErrors(function(root) {\n      return hook.onCommitFiberRoot(rendererID, root);\n    });\n    onCommitFiberUnmount = catchErrors(function(fiber) {\n      return hook.onCommitFiberUnmount(rendererID, fiber);\n    });\n  } catch (err) {\n    // Catch all errors because it is unsafe to throw during initialization.\n    {\n      warning(false, \"React DevTools encountered an error: %s.\", err);\n    }\n  }\n  // DevTools exists\n  return true;\n}\n\nfunction onCommitRoot(root) {\n  if (typeof onCommitFiberRoot === \"function\") {\n    onCommitFiberRoot(root);\n  }\n}\n\nfunction onCommitUnmount(fiber) {\n  if (typeof onCommitFiberUnmount === \"function\") {\n    onCommitFiberUnmount(fiber);\n  }\n}\n\n/**\n * Forked from fbjs/warning:\n * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js\n *\n * Only change is we use console.warn instead of console.error,\n * and do nothing when 'console' is not supported.\n * This really simplifies the code.\n * ---\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar lowPriorityWarning = function() {};\n\n{\n  var printWarning = function(format) {\n    for (\n      var _len = arguments.length,\n        args = Array(_len > 1 ? _len - 1 : 0),\n        _key = 1;\n      _key < _len;\n      _key++\n    ) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    var argIndex = 0;\n    var message =\n      \"Warning: \" +\n      format.replace(/%s/g, function() {\n        return args[argIndex++];\n      });\n    if (typeof console !== \"undefined\") {\n      console.warn(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  };\n\n  lowPriorityWarning = function(condition, format) {\n    if (format === undefined) {\n      throw new Error(\n        \"`warning(condition, format, ...args)` requires a warning \" +\n          \"message argument\"\n      );\n    }\n    if (!condition) {\n      for (\n        var _len2 = arguments.length,\n          args = Array(_len2 > 2 ? _len2 - 2 : 0),\n          _key2 = 2;\n        _key2 < _len2;\n        _key2++\n      ) {\n        args[_key2 - 2] = arguments[_key2];\n      }\n\n      printWarning.apply(undefined, [format].concat(args));\n    }\n  };\n}\n\nvar lowPriorityWarning$1 = lowPriorityWarning;\n\nvar ReactStrictModeWarnings = {\n  discardPendingWarnings: function() {},\n  flushPendingDeprecationWarnings: function() {},\n  flushPendingUnsafeLifecycleWarnings: function() {},\n  recordDeprecationWarnings: function(fiber, instance) {},\n  recordUnsafeLifecycleWarnings: function(fiber, instance) {}\n};\n\n{\n  var LIFECYCLE_SUGGESTIONS = {\n    UNSAFE_componentWillMount: \"componentDidMount\",\n    UNSAFE_componentWillReceiveProps: \"static getDerivedStateFromProps\",\n    UNSAFE_componentWillUpdate: \"componentDidUpdate\"\n  };\n\n  var pendingComponentWillMountWarnings = [];\n  var pendingComponentWillReceivePropsWarnings = [];\n  var pendingComponentWillUpdateWarnings = [];\n  var pendingUnsafeLifecycleWarnings = new Map();\n\n  // Tracks components we have already warned about.\n  var didWarnAboutDeprecatedLifecycles = new Set();\n  var didWarnAboutUnsafeLifecycles = new Set();\n\n  ReactStrictModeWarnings.discardPendingWarnings = function() {\n    pendingComponentWillMountWarnings = [];\n    pendingComponentWillReceivePropsWarnings = [];\n    pendingComponentWillUpdateWarnings = [];\n    pendingUnsafeLifecycleWarnings = new Map();\n  };\n\n  ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {\n    pendingUnsafeLifecycleWarnings.forEach(function(\n      lifecycleWarningsMap,\n      strictRoot\n    ) {\n      var lifecyclesWarningMesages = [];\n\n      Object.keys(lifecycleWarningsMap).forEach(function(lifecycle) {\n        var lifecycleWarnings = lifecycleWarningsMap[lifecycle];\n        if (lifecycleWarnings.length > 0) {\n          var componentNames = new Set();\n          lifecycleWarnings.forEach(function(fiber) {\n            componentNames.add(getComponentName(fiber) || \"Component\");\n            didWarnAboutUnsafeLifecycles.add(fiber.type);\n          });\n\n          var formatted = lifecycle.replace(\"UNSAFE_\", \"\");\n          var suggestion = LIFECYCLE_SUGGESTIONS[lifecycle];\n          var sortedComponentNames = Array.from(componentNames)\n            .sort()\n            .join(\", \");\n\n          lifecyclesWarningMesages.push(\n            formatted +\n              \": Please update the following components to use \" +\n              (suggestion + \" instead: \" + sortedComponentNames)\n          );\n        }\n      });\n\n      if (lifecyclesWarningMesages.length > 0) {\n        var strictRootComponentStack = getStackAddendumByWorkInProgressFiber(\n          strictRoot\n        );\n\n        warning(\n          false,\n          \"Unsafe lifecycle methods were found within a strict-mode tree:%s\" +\n            \"\\n\\n%s\" +\n            \"\\n\\nLearn more about this warning here:\" +\n            \"\\nhttps://fb.me/react-strict-mode-warnings\",\n          strictRootComponentStack,\n          lifecyclesWarningMesages.join(\"\\n\\n\")\n        );\n      }\n    });\n\n    pendingUnsafeLifecycleWarnings = new Map();\n  };\n\n  var getStrictRoot = function(fiber) {\n    var maybeStrictRoot = null;\n\n    while (fiber !== null) {\n      if (fiber.mode & StrictMode) {\n        maybeStrictRoot = fiber;\n      }\n\n      fiber = fiber[\"return\"];\n    }\n\n    return maybeStrictRoot;\n  };\n\n  ReactStrictModeWarnings.flushPendingDeprecationWarnings = function() {\n    if (pendingComponentWillMountWarnings.length > 0) {\n      var uniqueNames = new Set();\n      pendingComponentWillMountWarnings.forEach(function(fiber) {\n        uniqueNames.add(getComponentName(fiber) || \"Component\");\n        didWarnAboutDeprecatedLifecycles.add(fiber.type);\n      });\n\n      var sortedNames = Array.from(uniqueNames)\n        .sort()\n        .join(\", \");\n\n      lowPriorityWarning$1(\n        false,\n        \"componentWillMount is deprecated and will be removed in the next major version. \" +\n          \"Use componentDidMount instead. As a temporary workaround, \" +\n          \"you can rename to UNSAFE_componentWillMount.\" +\n          \"\\n\\nPlease update the following components: %s\" +\n          \"\\n\\nLearn more about this warning here:\" +\n          \"\\nhttps://fb.me/react-async-component-lifecycle-hooks\",\n        sortedNames\n      );\n\n      pendingComponentWillMountWarnings = [];\n    }\n\n    if (pendingComponentWillReceivePropsWarnings.length > 0) {\n      var _uniqueNames = new Set();\n      pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {\n        _uniqueNames.add(getComponentName(fiber) || \"Component\");\n        didWarnAboutDeprecatedLifecycles.add(fiber.type);\n      });\n\n      var _sortedNames = Array.from(_uniqueNames)\n        .sort()\n        .join(\", \");\n\n      lowPriorityWarning$1(\n        false,\n        \"componentWillReceiveProps is deprecated and will be removed in the next major version. \" +\n          \"Use static getDerivedStateFromProps instead.\" +\n          \"\\n\\nPlease update the following components: %s\" +\n          \"\\n\\nLearn more about this warning here:\" +\n          \"\\nhttps://fb.me/react-async-component-lifecycle-hooks\",\n        _sortedNames\n      );\n\n      pendingComponentWillReceivePropsWarnings = [];\n    }\n\n    if (pendingComponentWillUpdateWarnings.length > 0) {\n      var _uniqueNames2 = new Set();\n      pendingComponentWillUpdateWarnings.forEach(function(fiber) {\n        _uniqueNames2.add(getComponentName(fiber) || \"Component\");\n        didWarnAboutDeprecatedLifecycles.add(fiber.type);\n      });\n\n      var _sortedNames2 = Array.from(_uniqueNames2)\n        .sort()\n        .join(\", \");\n\n      lowPriorityWarning$1(\n        false,\n        \"componentWillUpdate is deprecated and will be removed in the next major version. \" +\n          \"Use componentDidUpdate instead. As a temporary workaround, \" +\n          \"you can rename to UNSAFE_componentWillUpdate.\" +\n          \"\\n\\nPlease update the following components: %s\" +\n          \"\\n\\nLearn more about this warning here:\" +\n          \"\\nhttps://fb.me/react-async-component-lifecycle-hooks\",\n        _sortedNames2\n      );\n\n      pendingComponentWillUpdateWarnings = [];\n    }\n  };\n\n  ReactStrictModeWarnings.recordDeprecationWarnings = function(\n    fiber,\n    instance\n  ) {\n    // Dedup strategy: Warn once per component.\n    if (didWarnAboutDeprecatedLifecycles.has(fiber.type)) {\n      return;\n    }\n\n    // Don't warn about react-lifecycles-compat polyfilled components.\n    if (\n      typeof instance.componentWillMount === \"function\" &&\n      instance.componentWillMount.__suppressDeprecationWarning !== true\n    ) {\n      pendingComponentWillMountWarnings.push(fiber);\n    }\n    if (\n      typeof instance.componentWillReceiveProps === \"function\" &&\n      instance.componentWillReceiveProps.__suppressDeprecationWarning !== true\n    ) {\n      pendingComponentWillReceivePropsWarnings.push(fiber);\n    }\n    if (typeof instance.componentWillUpdate === \"function\") {\n      pendingComponentWillUpdateWarnings.push(fiber);\n    }\n  };\n\n  ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(\n    fiber,\n    instance\n  ) {\n    var strictRoot = getStrictRoot(fiber);\n\n    // Dedup strategy: Warn once per component.\n    // This is difficult to track any other way since component names\n    // are often vague and are likely to collide between 3rd party libraries.\n    // An expand property is probably okay to use here since it's DEV-only,\n    // and will only be set in the event of serious warnings.\n    if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {\n      return;\n    }\n\n    // Don't warn about react-lifecycles-compat polyfilled components.\n    // Note that it is sufficient to check for the presence of a\n    // single lifecycle, componentWillMount, with the polyfill flag.\n    if (\n      typeof instance.componentWillMount === \"function\" &&\n      instance.componentWillMount.__suppressDeprecationWarning === true\n    ) {\n      return;\n    }\n\n    var warningsForRoot = void 0;\n    if (!pendingUnsafeLifecycleWarnings.has(strictRoot)) {\n      warningsForRoot = {\n        UNSAFE_componentWillMount: [],\n        UNSAFE_componentWillReceiveProps: [],\n        UNSAFE_componentWillUpdate: []\n      };\n\n      pendingUnsafeLifecycleWarnings.set(strictRoot, warningsForRoot);\n    } else {\n      warningsForRoot = pendingUnsafeLifecycleWarnings.get(strictRoot);\n    }\n\n    var unsafeLifecycles = [];\n    if (\n      typeof instance.componentWillMount === \"function\" ||\n      typeof instance.UNSAFE_componentWillMount === \"function\"\n    ) {\n      unsafeLifecycles.push(\"UNSAFE_componentWillMount\");\n    }\n    if (\n      typeof instance.componentWillReceiveProps === \"function\" ||\n      typeof instance.UNSAFE_componentWillReceiveProps === \"function\"\n    ) {\n      unsafeLifecycles.push(\"UNSAFE_componentWillReceiveProps\");\n    }\n    if (\n      typeof instance.componentWillUpdate === \"function\" ||\n      typeof instance.UNSAFE_componentWillUpdate === \"function\"\n    ) {\n      unsafeLifecycles.push(\"UNSAFE_componentWillUpdate\");\n    }\n\n    if (unsafeLifecycles.length > 0) {\n      unsafeLifecycles.forEach(function(lifecycle) {\n        warningsForRoot[lifecycle].push(fiber);\n      });\n    }\n  };\n}\n\nvar didWarnUpdateInsideUpdate = void 0;\n\n{\n  didWarnUpdateInsideUpdate = false;\n}\n\n// Callbacks are not validated until invocation\n\n// Singly linked-list of updates. When an update is scheduled, it is added to\n// the queue of the current fiber and the work-in-progress fiber. The two queues\n// are separate but they share a persistent structure.\n//\n// During reconciliation, updates are removed from the work-in-progress fiber,\n// but they remain on the current fiber. That ensures that if a work-in-progress\n// is aborted, the aborted updates are recovered by cloning from current.\n//\n// The work-in-progress queue is always a subset of the current queue.\n//\n// When the tree is committed, the work-in-progress becomes the current.\n\nfunction createUpdateQueue(baseState) {\n  var queue = {\n    baseState: baseState,\n    expirationTime: NoWork,\n    first: null,\n    last: null,\n    callbackList: null,\n    hasForceUpdate: false,\n    isInitialized: false,\n    capturedValues: null\n  };\n  {\n    queue.isProcessing = false;\n  }\n  return queue;\n}\n\nfunction insertUpdateIntoQueue(queue, update) {\n  // Append the update to the end of the list.\n  if (queue.last === null) {\n    // Queue is empty\n    queue.first = queue.last = update;\n  } else {\n    queue.last.next = update;\n    queue.last = update;\n  }\n  if (\n    queue.expirationTime === NoWork ||\n    queue.expirationTime > update.expirationTime\n  ) {\n    queue.expirationTime = update.expirationTime;\n  }\n}\n\nvar q1 = void 0;\nvar q2 = void 0;\nfunction ensureUpdateQueues(fiber) {\n  q1 = q2 = null;\n  // We'll have at least one and at most two distinct update queues.\n  var alternateFiber = fiber.alternate;\n  var queue1 = fiber.updateQueue;\n  if (queue1 === null) {\n    // TODO: We don't know what the base state will be until we begin work.\n    // It depends on which fiber is the next current. Initialize with an empty\n    // base state, then set to the memoizedState when rendering. Not super\n    // happy with this approach.\n    queue1 = fiber.updateQueue = createUpdateQueue(null);\n  }\n\n  var queue2 = void 0;\n  if (alternateFiber !== null) {\n    queue2 = alternateFiber.updateQueue;\n    if (queue2 === null) {\n      queue2 = alternateFiber.updateQueue = createUpdateQueue(null);\n    }\n  } else {\n    queue2 = null;\n  }\n  queue2 = queue2 !== queue1 ? queue2 : null;\n\n  // Use module variables instead of returning a tuple\n  q1 = queue1;\n  q2 = queue2;\n}\n\nfunction insertUpdateIntoFiber(fiber, update) {\n  ensureUpdateQueues(fiber);\n  var queue1 = q1;\n  var queue2 = q2;\n\n  // Warn if an update is scheduled from inside an updater function.\n  {\n    if (\n      (queue1.isProcessing || (queue2 !== null && queue2.isProcessing)) &&\n      !didWarnUpdateInsideUpdate\n    ) {\n      warning(\n        false,\n        \"An update (setState, replaceState, or forceUpdate) was scheduled \" +\n          \"from inside an update function. Update functions should be pure, \" +\n          \"with zero side-effects. Consider using componentDidUpdate or a \" +\n          \"callback.\"\n      );\n      didWarnUpdateInsideUpdate = true;\n    }\n  }\n\n  // If there's only one queue, add the update to that queue and exit.\n  if (queue2 === null) {\n    insertUpdateIntoQueue(queue1, update);\n    return;\n  }\n\n  // If either queue is empty, we need to add to both queues.\n  if (queue1.last === null || queue2.last === null) {\n    insertUpdateIntoQueue(queue1, update);\n    insertUpdateIntoQueue(queue2, update);\n    return;\n  }\n\n  // If both lists are not empty, the last update is the same for both lists\n  // because of structural sharing. So, we should only append to one of\n  // the lists.\n  insertUpdateIntoQueue(queue1, update);\n  // But we still need to update the `last` pointer of queue2.\n  queue2.last = update;\n}\n\nfunction getUpdateExpirationTime(fiber) {\n  switch (fiber.tag) {\n    case HostRoot:\n    case ClassComponent:\n      var updateQueue = fiber.updateQueue;\n      if (updateQueue === null) {\n        return NoWork;\n      }\n      return updateQueue.expirationTime;\n    default:\n      return NoWork;\n  }\n}\n\nfunction getStateFromUpdate(update, instance, prevState, props) {\n  var partialState = update.partialState;\n  if (typeof partialState === \"function\") {\n    return partialState.call(instance, prevState, props);\n  } else {\n    return partialState;\n  }\n}\n\nfunction processUpdateQueue(\n  current,\n  workInProgress,\n  queue,\n  instance,\n  props,\n  renderExpirationTime\n) {\n  if (current !== null && current.updateQueue === queue) {\n    // We need to create a work-in-progress queue, by cloning the current queue.\n    var currentQueue = queue;\n    queue = workInProgress.updateQueue = {\n      baseState: currentQueue.baseState,\n      expirationTime: currentQueue.expirationTime,\n      first: currentQueue.first,\n      last: currentQueue.last,\n      isInitialized: currentQueue.isInitialized,\n      capturedValues: currentQueue.capturedValues,\n      // These fields are no longer valid because they were already committed.\n      // Reset them.\n      callbackList: null,\n      hasForceUpdate: false\n    };\n  }\n\n  {\n    // Set this flag so we can warn if setState is called inside the update\n    // function of another setState.\n    queue.isProcessing = true;\n  }\n\n  // Reset the remaining expiration time. If we skip over any updates, we'll\n  // increase this accordingly.\n  queue.expirationTime = NoWork;\n\n  // TODO: We don't know what the base state will be until we begin work.\n  // It depends on which fiber is the next current. Initialize with an empty\n  // base state, then set to the memoizedState when rendering. Not super\n  // happy with this approach.\n  var state = void 0;\n  if (queue.isInitialized) {\n    state = queue.baseState;\n  } else {\n    state = queue.baseState = workInProgress.memoizedState;\n    queue.isInitialized = true;\n  }\n  var dontMutatePrevState = true;\n  var update = queue.first;\n  var didSkip = false;\n  while (update !== null) {\n    var updateExpirationTime = update.expirationTime;\n    if (updateExpirationTime > renderExpirationTime) {\n      // This update does not have sufficient priority. Skip it.\n      var remainingExpirationTime = queue.expirationTime;\n      if (\n        remainingExpirationTime === NoWork ||\n        remainingExpirationTime > updateExpirationTime\n      ) {\n        // Update the remaining expiration time.\n        queue.expirationTime = updateExpirationTime;\n      }\n      if (!didSkip) {\n        didSkip = true;\n        queue.baseState = state;\n      }\n      // Continue to the next update.\n      update = update.next;\n      continue;\n    }\n\n    // This update does have sufficient priority.\n\n    // If no previous updates were skipped, drop this update from the queue by\n    // advancing the head of the list.\n    if (!didSkip) {\n      queue.first = update.next;\n      if (queue.first === null) {\n        queue.last = null;\n      }\n    }\n\n    // Invoke setState callback an extra time to help detect side-effects.\n    // Ignore the return value in this case.\n    if (\n      debugRenderPhaseSideEffects ||\n      (debugRenderPhaseSideEffectsForStrictMode &&\n        workInProgress.mode & StrictMode)\n    ) {\n      getStateFromUpdate(update, instance, state, props);\n    }\n\n    // Process the update\n    var _partialState = void 0;\n    if (update.isReplace) {\n      state = getStateFromUpdate(update, instance, state, props);\n      dontMutatePrevState = true;\n    } else {\n      _partialState = getStateFromUpdate(update, instance, state, props);\n      if (_partialState) {\n        if (dontMutatePrevState) {\n          // $FlowFixMe: Idk how to type this properly.\n          state = Object.assign({}, state, _partialState);\n        } else {\n          state = Object.assign(state, _partialState);\n        }\n        dontMutatePrevState = false;\n      }\n    }\n    if (update.isForced) {\n      queue.hasForceUpdate = true;\n    }\n    if (update.callback !== null) {\n      // Append to list of callbacks.\n      var _callbackList = queue.callbackList;\n      if (_callbackList === null) {\n        _callbackList = queue.callbackList = [];\n      }\n      _callbackList.push(update);\n    }\n    if (update.capturedValue !== null) {\n      var _capturedValues = queue.capturedValues;\n      if (_capturedValues === null) {\n        queue.capturedValues = [update.capturedValue];\n      } else {\n        _capturedValues.push(update.capturedValue);\n      }\n    }\n    update = update.next;\n  }\n\n  if (queue.callbackList !== null) {\n    workInProgress.effectTag |= Callback;\n  } else if (\n    queue.first === null &&\n    !queue.hasForceUpdate &&\n    queue.capturedValues === null\n  ) {\n    // The queue is empty. We can reset it.\n    workInProgress.updateQueue = null;\n  }\n\n  if (!didSkip) {\n    didSkip = true;\n    queue.baseState = state;\n  }\n\n  {\n    // No longer processing.\n    queue.isProcessing = false;\n  }\n\n  return state;\n}\n\nfunction commitCallbacks(queue, context) {\n  var callbackList = queue.callbackList;\n  if (callbackList === null) {\n    return;\n  }\n  // Set the list to null to make sure they don't get called more than once.\n  queue.callbackList = null;\n  for (var i = 0; i < callbackList.length; i++) {\n    var update = callbackList[i];\n    var _callback = update.callback;\n    // This update might be processed again. Clear the callback so it's only\n    // called once.\n    update.callback = null;\n    invariant(\n      typeof _callback === \"function\",\n      \"Invalid argument passed as callback. Expected a function. Instead \" +\n        \"received: %s\",\n      _callback\n    );\n    _callback.call(context);\n  }\n}\n\nvar fakeInternalInstance = {};\nvar isArray = Array.isArray;\n\nvar didWarnAboutStateAssignmentForComponent = void 0;\nvar didWarnAboutUndefinedDerivedState = void 0;\nvar didWarnAboutUninitializedState = void 0;\nvar didWarnAboutWillReceivePropsAndDerivedState = void 0;\nvar warnOnInvalidCallback = void 0;\n\n{\n  didWarnAboutStateAssignmentForComponent = {};\n  didWarnAboutUndefinedDerivedState = {};\n  didWarnAboutUninitializedState = {};\n  didWarnAboutWillReceivePropsAndDerivedState = {};\n\n  var didWarnOnInvalidCallback = {};\n\n  warnOnInvalidCallback = function(callback, callerName) {\n    if (callback === null || typeof callback === \"function\") {\n      return;\n    }\n    var key = callerName + \"_\" + callback;\n    if (!didWarnOnInvalidCallback[key]) {\n      warning(\n        false,\n        \"%s(...): Expected the last optional `callback` argument to be a \" +\n          \"function. Instead received: %s.\",\n        callerName,\n        callback\n      );\n      didWarnOnInvalidCallback[key] = true;\n    }\n  };\n\n  // This is so gross but it's at least non-critical and can be removed if\n  // it causes problems. This is meant to give a nicer error message for\n  // ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,\n  // ...)) which otherwise throws a \"_processChildContext is not a function\"\n  // exception.\n  Object.defineProperty(fakeInternalInstance, \"_processChildContext\", {\n    enumerable: false,\n    value: function() {\n      invariant(\n        false,\n        \"_processChildContext is not available in React 16+. This likely \" +\n          \"means you have multiple copies of React and are attempting to nest \" +\n          \"a React 15 tree inside a React 16 tree using \" +\n          \"unstable_renderSubtreeIntoContainer, which isn't supported. Try \" +\n          \"to make sure you have only one copy of React (and ideally, switch \" +\n          \"to ReactDOM.createPortal).\"\n      );\n    }\n  });\n  Object.freeze(fakeInternalInstance);\n}\nfunction callGetDerivedStateFromCatch(ctor, capturedValues) {\n  var resultState = {};\n  for (var i = 0; i < capturedValues.length; i++) {\n    var capturedValue = capturedValues[i];\n    var error = capturedValue.value;\n    var partialState = ctor.getDerivedStateFromCatch.call(null, error);\n    if (partialState !== null && partialState !== undefined) {\n      Object.assign(resultState, partialState);\n    }\n  }\n  return resultState;\n}\n\nvar ReactFiberClassComponent = function(\n  scheduleWork,\n  computeExpirationForFiber,\n  memoizeProps,\n  memoizeState\n) {\n  // Class component state updater\n  var updater = {\n    isMounted: isMounted,\n    enqueueSetState: function(instance, partialState, callback) {\n      var fiber = get(instance);\n      callback = callback === undefined ? null : callback;\n      {\n        warnOnInvalidCallback(callback, \"setState\");\n      }\n      var expirationTime = computeExpirationForFiber(fiber);\n      var update = {\n        expirationTime: expirationTime,\n        partialState: partialState,\n        callback: callback,\n        isReplace: false,\n        isForced: false,\n        capturedValue: null,\n        next: null\n      };\n      insertUpdateIntoFiber(fiber, update);\n      scheduleWork(fiber, expirationTime);\n    },\n    enqueueReplaceState: function(instance, state, callback) {\n      var fiber = get(instance);\n      callback = callback === undefined ? null : callback;\n      {\n        warnOnInvalidCallback(callback, \"replaceState\");\n      }\n      var expirationTime = computeExpirationForFiber(fiber);\n      var update = {\n        expirationTime: expirationTime,\n        partialState: state,\n        callback: callback,\n        isReplace: true,\n        isForced: false,\n        capturedValue: null,\n        next: null\n      };\n      insertUpdateIntoFiber(fiber, update);\n      scheduleWork(fiber, expirationTime);\n    },\n    enqueueForceUpdate: function(instance, callback) {\n      var fiber = get(instance);\n      callback = callback === undefined ? null : callback;\n      {\n        warnOnInvalidCallback(callback, \"forceUpdate\");\n      }\n      var expirationTime = computeExpirationForFiber(fiber);\n      var update = {\n        expirationTime: expirationTime,\n        partialState: null,\n        callback: callback,\n        isReplace: false,\n        isForced: true,\n        capturedValue: null,\n        next: null\n      };\n      insertUpdateIntoFiber(fiber, update);\n      scheduleWork(fiber, expirationTime);\n    }\n  };\n\n  function checkShouldComponentUpdate(\n    workInProgress,\n    oldProps,\n    newProps,\n    oldState,\n    newState,\n    newContext\n  ) {\n    if (\n      oldProps === null ||\n      (workInProgress.updateQueue !== null &&\n        workInProgress.updateQueue.hasForceUpdate)\n    ) {\n      // If the workInProgress already has an Update effect, return true\n      return true;\n    }\n\n    var instance = workInProgress.stateNode;\n    var ctor = workInProgress.type;\n    if (typeof instance.shouldComponentUpdate === \"function\") {\n      startPhaseTimer(workInProgress, \"shouldComponentUpdate\");\n      var shouldUpdate = instance.shouldComponentUpdate(\n        newProps,\n        newState,\n        newContext\n      );\n      stopPhaseTimer();\n\n      {\n        warning(\n          shouldUpdate !== undefined,\n          \"%s.shouldComponentUpdate(): Returned undefined instead of a \" +\n            \"boolean value. Make sure to return true or false.\",\n          getComponentName(workInProgress) || \"Unknown\"\n        );\n      }\n\n      return shouldUpdate;\n    }\n\n    if (ctor.prototype && ctor.prototype.isPureReactComponent) {\n      return (\n        !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)\n      );\n    }\n\n    return true;\n  }\n\n  function checkClassInstance(workInProgress) {\n    var instance = workInProgress.stateNode;\n    var type = workInProgress.type;\n    {\n      var name = getComponentName(workInProgress);\n      var renderPresent = instance.render;\n\n      if (!renderPresent) {\n        if (type.prototype && typeof type.prototype.render === \"function\") {\n          warning(\n            false,\n            \"%s(...): No `render` method found on the returned component \" +\n              \"instance: did you accidentally return an object from the constructor?\",\n            name\n          );\n        } else {\n          warning(\n            false,\n            \"%s(...): No `render` method found on the returned component \" +\n              \"instance: you may have forgotten to define `render`.\",\n            name\n          );\n        }\n      }\n\n      var noGetInitialStateOnES6 =\n        !instance.getInitialState ||\n        instance.getInitialState.isReactClassApproved ||\n        instance.state;\n      warning(\n        noGetInitialStateOnES6,\n        \"getInitialState was defined on %s, a plain JavaScript class. \" +\n          \"This is only supported for classes created using React.createClass. \" +\n          \"Did you mean to define a state property instead?\",\n        name\n      );\n      var noGetDefaultPropsOnES6 =\n        !instance.getDefaultProps ||\n        instance.getDefaultProps.isReactClassApproved;\n      warning(\n        noGetDefaultPropsOnES6,\n        \"getDefaultProps was defined on %s, a plain JavaScript class. \" +\n          \"This is only supported for classes created using React.createClass. \" +\n          \"Use a static property to define defaultProps instead.\",\n        name\n      );\n      var noInstancePropTypes = !instance.propTypes;\n      warning(\n        noInstancePropTypes,\n        \"propTypes was defined as an instance property on %s. Use a static \" +\n          \"property to define propTypes instead.\",\n        name\n      );\n      var noInstanceContextTypes = !instance.contextTypes;\n      warning(\n        noInstanceContextTypes,\n        \"contextTypes was defined as an instance property on %s. Use a static \" +\n          \"property to define contextTypes instead.\",\n        name\n      );\n      var noComponentShouldUpdate =\n        typeof instance.componentShouldUpdate !== \"function\";\n      warning(\n        noComponentShouldUpdate,\n        \"%s has a method called \" +\n          \"componentShouldUpdate(). Did you mean shouldComponentUpdate()? \" +\n          \"The name is phrased as a question because the function is \" +\n          \"expected to return a value.\",\n        name\n      );\n      if (\n        type.prototype &&\n        type.prototype.isPureReactComponent &&\n        typeof instance.shouldComponentUpdate !== \"undefined\"\n      ) {\n        warning(\n          false,\n          \"%s has a method called shouldComponentUpdate(). \" +\n            \"shouldComponentUpdate should not be used when extending React.PureComponent. \" +\n            \"Please extend React.Component if shouldComponentUpdate is used.\",\n          getComponentName(workInProgress) || \"A pure component\"\n        );\n      }\n      var noComponentDidUnmount =\n        typeof instance.componentDidUnmount !== \"function\";\n      warning(\n        noComponentDidUnmount,\n        \"%s has a method called \" +\n          \"componentDidUnmount(). But there is no such lifecycle method. \" +\n          \"Did you mean componentWillUnmount()?\",\n        name\n      );\n      var noComponentDidReceiveProps =\n        typeof instance.componentDidReceiveProps !== \"function\";\n      warning(\n        noComponentDidReceiveProps,\n        \"%s has a method called \" +\n          \"componentDidReceiveProps(). But there is no such lifecycle method. \" +\n          \"If you meant to update the state in response to changing props, \" +\n          \"use componentWillReceiveProps(). If you meant to fetch data or \" +\n          \"run side-effects or mutations after React has updated the UI, use componentDidUpdate().\",\n        name\n      );\n      var noComponentWillRecieveProps =\n        typeof instance.componentWillRecieveProps !== \"function\";\n      warning(\n        noComponentWillRecieveProps,\n        \"%s has a method called \" +\n          \"componentWillRecieveProps(). Did you mean componentWillReceiveProps()?\",\n        name\n      );\n      var noUnsafeComponentWillRecieveProps =\n        typeof instance.UNSAFE_componentWillRecieveProps !== \"function\";\n      warning(\n        noUnsafeComponentWillRecieveProps,\n        \"%s has a method called \" +\n          \"UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?\",\n        name\n      );\n      var hasMutatedProps = instance.props !== workInProgress.pendingProps;\n      warning(\n        instance.props === undefined || !hasMutatedProps,\n        \"%s(...): When calling super() in `%s`, make sure to pass \" +\n          \"up the same props that your component's constructor was passed.\",\n        name,\n        name\n      );\n      var noInstanceDefaultProps = !instance.defaultProps;\n      warning(\n        noInstanceDefaultProps,\n        \"Setting defaultProps as an instance property on %s is not supported and will be ignored.\" +\n          \" Instead, define defaultProps as a static property on %s.\",\n        name,\n        name\n      );\n    }\n\n    var state = instance.state;\n    if (state && (typeof state !== \"object\" || isArray(state))) {\n      warning(\n        false,\n        \"%s.state: must be set to an object or null\",\n        getComponentName(workInProgress)\n      );\n    }\n    if (typeof instance.getChildContext === \"function\") {\n      warning(\n        typeof type.childContextTypes === \"object\",\n        \"%s.getChildContext(): childContextTypes must be defined in order to \" +\n          \"use getChildContext().\",\n        getComponentName(workInProgress)\n      );\n    }\n  }\n\n  function resetInputPointers(workInProgress, instance) {\n    instance.props = workInProgress.memoizedProps;\n    instance.state = workInProgress.memoizedState;\n  }\n\n  function adoptClassInstance(workInProgress, instance) {\n    instance.updater = updater;\n    workInProgress.stateNode = instance;\n    // The instance needs access to the fiber so that it can schedule updates\n    set(instance, workInProgress);\n    {\n      instance._reactInternalInstance = fakeInternalInstance;\n    }\n  }\n\n  function constructClassInstance(workInProgress, props) {\n    var ctor = workInProgress.type;\n    var unmaskedContext = getUnmaskedContext(workInProgress);\n    var needsContext = isContextConsumer(workInProgress);\n    var context = needsContext\n      ? getMaskedContext(workInProgress, unmaskedContext)\n      : emptyObject;\n\n    // Instantiate twice to help detect side-effects.\n    if (\n      debugRenderPhaseSideEffects ||\n      (debugRenderPhaseSideEffectsForStrictMode &&\n        workInProgress.mode & StrictMode)\n    ) {\n      new ctor(props, context); // eslint-disable-line no-new\n    }\n\n    var instance = new ctor(props, context);\n    var state =\n      instance.state !== null && instance.state !== undefined\n        ? instance.state\n        : null;\n    adoptClassInstance(workInProgress, instance);\n\n    {\n      if (\n        typeof ctor.getDerivedStateFromProps === \"function\" &&\n        state === null\n      ) {\n        var componentName = getComponentName(workInProgress) || \"Unknown\";\n        if (!didWarnAboutUninitializedState[componentName]) {\n          warning(\n            false,\n            \"%s: Did not properly initialize state during construction. \" +\n              \"Expected state to be an object, but it was %s.\",\n            componentName,\n            instance.state === null ? \"null\" : \"undefined\"\n          );\n          didWarnAboutUninitializedState[componentName] = true;\n        }\n      }\n    }\n\n    workInProgress.memoizedState = state;\n\n    var partialState = callGetDerivedStateFromProps(\n      workInProgress,\n      instance,\n      props\n    );\n\n    if (partialState !== null && partialState !== undefined) {\n      // Render-phase updates (like this) should not be added to the update queue,\n      // So that multiple render passes do not enqueue multiple updates.\n      // Instead, just synchronously merge the returned state into the instance.\n      workInProgress.memoizedState = Object.assign(\n        {},\n        workInProgress.memoizedState,\n        partialState\n      );\n    }\n\n    // Cache unmasked context so we can avoid recreating masked context unless necessary.\n    // ReactFiberContext usually updates this cache but can't for newly-created instances.\n    if (needsContext) {\n      cacheContext(workInProgress, unmaskedContext, context);\n    }\n\n    return instance;\n  }\n\n  function callComponentWillMount(workInProgress, instance) {\n    startPhaseTimer(workInProgress, \"componentWillMount\");\n    var oldState = instance.state;\n\n    if (typeof instance.componentWillMount === \"function\") {\n      instance.componentWillMount();\n    }\n    if (typeof instance.UNSAFE_componentWillMount === \"function\") {\n      instance.UNSAFE_componentWillMount();\n    }\n\n    stopPhaseTimer();\n\n    if (oldState !== instance.state) {\n      {\n        warning(\n          false,\n          \"%s.componentWillMount(): Assigning directly to this.state is \" +\n            \"deprecated (except inside a component's \" +\n            \"constructor). Use setState instead.\",\n          getComponentName(workInProgress)\n        );\n      }\n      updater.enqueueReplaceState(instance, instance.state, null);\n    }\n  }\n\n  function callComponentWillReceiveProps(\n    workInProgress,\n    instance,\n    newProps,\n    newContext\n  ) {\n    var oldState = instance.state;\n    startPhaseTimer(workInProgress, \"componentWillReceiveProps\");\n    if (typeof instance.componentWillReceiveProps === \"function\") {\n      instance.componentWillReceiveProps(newProps, newContext);\n    }\n    if (typeof instance.UNSAFE_componentWillReceiveProps === \"function\") {\n      instance.UNSAFE_componentWillReceiveProps(newProps, newContext);\n    }\n    stopPhaseTimer();\n\n    if (instance.state !== oldState) {\n      {\n        var componentName = getComponentName(workInProgress) || \"Component\";\n        if (!didWarnAboutStateAssignmentForComponent[componentName]) {\n          warning(\n            false,\n            \"%s.componentWillReceiveProps(): Assigning directly to \" +\n              \"this.state is deprecated (except inside a component's \" +\n              \"constructor). Use setState instead.\",\n            componentName\n          );\n          didWarnAboutStateAssignmentForComponent[componentName] = true;\n        }\n      }\n      updater.enqueueReplaceState(instance, instance.state, null);\n    }\n  }\n\n  function callGetDerivedStateFromProps(workInProgress, instance, props) {\n    var type = workInProgress.type;\n\n    if (typeof type.getDerivedStateFromProps === \"function\") {\n      {\n        // Don't warn about react-lifecycles-compat polyfilled components\n        if (\n          (typeof instance.componentWillReceiveProps === \"function\" &&\n            instance.componentWillReceiveProps.__suppressDeprecationWarning !==\n              true) ||\n          typeof instance.UNSAFE_componentWillReceiveProps === \"function\"\n        ) {\n          var componentName = getComponentName(workInProgress) || \"Unknown\";\n          if (!didWarnAboutWillReceivePropsAndDerivedState[componentName]) {\n            warning(\n              false,\n              \"%s: Defines both componentWillReceiveProps() and static \" +\n                \"getDerivedStateFromProps() methods. We recommend using \" +\n                \"only getDerivedStateFromProps().\",\n              componentName\n            );\n            didWarnAboutWillReceivePropsAndDerivedState[componentName] = true;\n          }\n        }\n      }\n\n      if (\n        debugRenderPhaseSideEffects ||\n        (debugRenderPhaseSideEffectsForStrictMode &&\n          workInProgress.mode & StrictMode)\n      ) {\n        // Invoke method an extra time to help detect side-effects.\n        type.getDerivedStateFromProps.call(\n          null,\n          props,\n          workInProgress.memoizedState\n        );\n      }\n\n      var partialState = type.getDerivedStateFromProps.call(\n        null,\n        props,\n        workInProgress.memoizedState\n      );\n\n      {\n        if (partialState === undefined) {\n          var _componentName = getComponentName(workInProgress) || \"Unknown\";\n          if (!didWarnAboutUndefinedDerivedState[_componentName]) {\n            warning(\n              false,\n              \"%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. \" +\n                \"You have returned undefined.\",\n              _componentName\n            );\n            didWarnAboutUndefinedDerivedState[_componentName] = _componentName;\n          }\n        }\n      }\n\n      return partialState;\n    }\n  }\n\n  // Invokes the mount life-cycles on a previously never rendered instance.\n  function mountClassInstance(workInProgress, renderExpirationTime) {\n    var ctor = workInProgress.type;\n    var current = workInProgress.alternate;\n\n    {\n      checkClassInstance(workInProgress);\n    }\n\n    var instance = workInProgress.stateNode;\n    var props = workInProgress.pendingProps;\n    var unmaskedContext = getUnmaskedContext(workInProgress);\n\n    instance.props = props;\n    instance.state = workInProgress.memoizedState;\n    instance.refs = emptyObject;\n    instance.context = getMaskedContext(workInProgress, unmaskedContext);\n\n    {\n      if (workInProgress.mode & StrictMode) {\n        ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(\n          workInProgress,\n          instance\n        );\n      }\n\n      if (warnAboutDeprecatedLifecycles) {\n        ReactStrictModeWarnings.recordDeprecationWarnings(\n          workInProgress,\n          instance\n        );\n      }\n    }\n\n    // In order to support react-lifecycles-compat polyfilled components,\n    // Unsafe lifecycles should not be invoked for any component with the new gDSFP.\n    if (\n      (typeof instance.UNSAFE_componentWillMount === \"function\" ||\n        typeof instance.componentWillMount === \"function\") &&\n      typeof ctor.getDerivedStateFromProps !== \"function\"\n    ) {\n      callComponentWillMount(workInProgress, instance);\n      // If we had additional state updates during this life-cycle, let's\n      // process them now.\n      var updateQueue = workInProgress.updateQueue;\n      if (updateQueue !== null) {\n        instance.state = processUpdateQueue(\n          current,\n          workInProgress,\n          updateQueue,\n          instance,\n          props,\n          renderExpirationTime\n        );\n      }\n    }\n    if (typeof instance.componentDidMount === \"function\") {\n      workInProgress.effectTag |= Update;\n    }\n  }\n\n  function resumeMountClassInstance(workInProgress, renderExpirationTime) {\n    var ctor = workInProgress.type;\n    var instance = workInProgress.stateNode;\n    resetInputPointers(workInProgress, instance);\n\n    var oldProps = workInProgress.memoizedProps;\n    var newProps = workInProgress.pendingProps;\n    var oldContext = instance.context;\n    var newUnmaskedContext = getUnmaskedContext(workInProgress);\n    var newContext = getMaskedContext(workInProgress, newUnmaskedContext);\n\n    // Note: During these life-cycles, instance.props/instance.state are what\n    // ever the previously attempted to render - not the \"current\". However,\n    // during componentDidUpdate we pass the \"current\" props.\n\n    // In order to support react-lifecycles-compat polyfilled components,\n    // Unsafe lifecycles should not be invoked for any component with the new gDSFP.\n    if (\n      (typeof instance.UNSAFE_componentWillReceiveProps === \"function\" ||\n        typeof instance.componentWillReceiveProps === \"function\") &&\n      typeof ctor.getDerivedStateFromProps !== \"function\"\n    ) {\n      if (oldProps !== newProps || oldContext !== newContext) {\n        callComponentWillReceiveProps(\n          workInProgress,\n          instance,\n          newProps,\n          newContext\n        );\n      }\n    }\n\n    var derivedStateFromProps = void 0;\n    if (oldProps !== newProps) {\n      derivedStateFromProps = callGetDerivedStateFromProps(\n        workInProgress,\n        instance,\n        newProps\n      );\n    }\n\n    // Compute the next state using the memoized state and the update queue.\n    var oldState = workInProgress.memoizedState;\n    // TODO: Previous state can be null.\n    var newState = void 0;\n    var derivedStateFromCatch = void 0;\n    if (workInProgress.updateQueue !== null) {\n      newState = processUpdateQueue(\n        null,\n        workInProgress,\n        workInProgress.updateQueue,\n        instance,\n        newProps,\n        renderExpirationTime\n      );\n\n      var updateQueue = workInProgress.updateQueue;\n      if (\n        updateQueue !== null &&\n        updateQueue.capturedValues !== null &&\n        enableGetDerivedStateFromCatch &&\n        typeof ctor.getDerivedStateFromCatch === \"function\"\n      ) {\n        var capturedValues = updateQueue.capturedValues;\n        // Don't remove these from the update queue yet. We need them in\n        // finishClassComponent. Do the reset there.\n        // TODO: This is awkward. Refactor class components.\n        // updateQueue.capturedValues = null;\n        derivedStateFromCatch = callGetDerivedStateFromCatch(\n          ctor,\n          capturedValues\n        );\n      }\n    } else {\n      newState = oldState;\n    }\n\n    if (derivedStateFromProps !== null && derivedStateFromProps !== undefined) {\n      // Render-phase updates (like this) should not be added to the update queue,\n      // So that multiple render passes do not enqueue multiple updates.\n      // Instead, just synchronously merge the returned state into the instance.\n      newState =\n        newState === null || newState === undefined\n          ? derivedStateFromProps\n          : Object.assign({}, newState, derivedStateFromProps);\n    }\n    if (derivedStateFromCatch !== null && derivedStateFromCatch !== undefined) {\n      // Render-phase updates (like this) should not be added to the update queue,\n      // So that multiple render passes do not enqueue multiple updates.\n      // Instead, just synchronously merge the returned state into the instance.\n      newState =\n        newState === null || newState === undefined\n          ? derivedStateFromCatch\n          : Object.assign({}, newState, derivedStateFromCatch);\n    }\n\n    if (\n      oldProps === newProps &&\n      oldState === newState &&\n      !hasContextChanged() &&\n      !(\n        workInProgress.updateQueue !== null &&\n        workInProgress.updateQueue.hasForceUpdate\n      )\n    ) {\n      // If an update was already in progress, we should schedule an Update\n      // effect even though we're bailing out, so that cWU/cDU are called.\n      if (typeof instance.componentDidMount === \"function\") {\n        workInProgress.effectTag |= Update;\n      }\n      return false;\n    }\n\n    var shouldUpdate = checkShouldComponentUpdate(\n      workInProgress,\n      oldProps,\n      newProps,\n      oldState,\n      newState,\n      newContext\n    );\n\n    if (shouldUpdate) {\n      // In order to support react-lifecycles-compat polyfilled components,\n      // Unsafe lifecycles should not be invoked for any component with the new gDSFP.\n      if (\n        (typeof instance.UNSAFE_componentWillUpdate === \"function\" ||\n          typeof instance.componentWillUpdate === \"function\") &&\n        typeof ctor.getDerivedStateFromProps !== \"function\"\n      ) {\n        startPhaseTimer(workInProgress, \"componentWillUpdate\");\n        if (typeof instance.componentWillUpdate === \"function\") {\n          instance.componentWillUpdate(newProps, newState, newContext);\n        }\n        if (typeof instance.UNSAFE_componentWillUpdate === \"function\") {\n          instance.UNSAFE_componentWillUpdate(newProps, newState, newContext);\n        }\n        stopPhaseTimer();\n      }\n      if (typeof instance.componentDidUpdate === \"function\") {\n        workInProgress.effectTag |= Update;\n      }\n    } else {\n      // If an update was already in progress, we should schedule an Update\n      // effect even though we're bailing out, so that cWU/cDU are called.\n      if (typeof instance.componentDidMount === \"function\") {\n        workInProgress.effectTag |= Update;\n      }\n\n      // If shouldComponentUpdate returned false, we should still update the\n      // memoized props/state to indicate that this work can be reused.\n      memoizeProps(workInProgress, newProps);\n      memoizeState(workInProgress, newState);\n    }\n\n    // Update the existing instance's state, props, and context pointers even\n    // if shouldComponentUpdate returns false.\n    instance.props = newProps;\n    instance.state = newState;\n    instance.context = newContext;\n\n    return shouldUpdate;\n  }\n\n  // Invokes the update life-cycles and returns false if it shouldn't rerender.\n  function updateClassInstance(current, workInProgress, renderExpirationTime) {\n    var ctor = workInProgress.type;\n    var instance = workInProgress.stateNode;\n    resetInputPointers(workInProgress, instance);\n\n    var oldProps = workInProgress.memoizedProps;\n    var newProps = workInProgress.pendingProps;\n    var oldContext = instance.context;\n    var newUnmaskedContext = getUnmaskedContext(workInProgress);\n    var newContext = getMaskedContext(workInProgress, newUnmaskedContext);\n\n    // Note: During these life-cycles, instance.props/instance.state are what\n    // ever the previously attempted to render - not the \"current\". However,\n    // during componentDidUpdate we pass the \"current\" props.\n\n    // In order to support react-lifecycles-compat polyfilled components,\n    // Unsafe lifecycles should not be invoked for any component with the new gDSFP.\n    if (\n      (typeof instance.UNSAFE_componentWillReceiveProps === \"function\" ||\n        typeof instance.componentWillReceiveProps === \"function\") &&\n      typeof ctor.getDerivedStateFromProps !== \"function\"\n    ) {\n      if (oldProps !== newProps || oldContext !== newContext) {\n        callComponentWillReceiveProps(\n          workInProgress,\n          instance,\n          newProps,\n          newContext\n        );\n      }\n    }\n\n    var derivedStateFromProps = void 0;\n    if (oldProps !== newProps) {\n      derivedStateFromProps = callGetDerivedStateFromProps(\n        workInProgress,\n        instance,\n        newProps\n      );\n    }\n\n    // Compute the next state using the memoized state and the update queue.\n    var oldState = workInProgress.memoizedState;\n    // TODO: Previous state can be null.\n    var newState = void 0;\n    var derivedStateFromCatch = void 0;\n    if (workInProgress.updateQueue !== null) {\n      newState = processUpdateQueue(\n        current,\n        workInProgress,\n        workInProgress.updateQueue,\n        instance,\n        newProps,\n        renderExpirationTime\n      );\n\n      var updateQueue = workInProgress.updateQueue;\n      if (\n        updateQueue !== null &&\n        updateQueue.capturedValues !== null &&\n        enableGetDerivedStateFromCatch &&\n        typeof ctor.getDerivedStateFromCatch === \"function\"\n      ) {\n        var capturedValues = updateQueue.capturedValues;\n        // Don't remove these from the update queue yet. We need them in\n        // finishClassComponent. Do the reset there.\n        // TODO: This is awkward. Refactor class components.\n        // updateQueue.capturedValues = null;\n        derivedStateFromCatch = callGetDerivedStateFromCatch(\n          ctor,\n          capturedValues\n        );\n      }\n    } else {\n      newState = oldState;\n    }\n\n    if (derivedStateFromProps !== null && derivedStateFromProps !== undefined) {\n      // Render-phase updates (like this) should not be added to the update queue,\n      // So that multiple render passes do not enqueue multiple updates.\n      // Instead, just synchronously merge the returned state into the instance.\n      newState =\n        newState === null || newState === undefined\n          ? derivedStateFromProps\n          : Object.assign({}, newState, derivedStateFromProps);\n    }\n    if (derivedStateFromCatch !== null && derivedStateFromCatch !== undefined) {\n      // Render-phase updates (like this) should not be added to the update queue,\n      // So that multiple render passes do not enqueue multiple updates.\n      // Instead, just synchronously merge the returned state into the instance.\n      newState =\n        newState === null || newState === undefined\n          ? derivedStateFromCatch\n          : Object.assign({}, newState, derivedStateFromCatch);\n    }\n\n    if (\n      oldProps === newProps &&\n      oldState === newState &&\n      !hasContextChanged() &&\n      !(\n        workInProgress.updateQueue !== null &&\n        workInProgress.updateQueue.hasForceUpdate\n      )\n    ) {\n      // If an update was already in progress, we should schedule an Update\n      // effect even though we're bailing out, so that cWU/cDU are called.\n      if (typeof instance.componentDidUpdate === \"function\") {\n        if (\n          oldProps !== current.memoizedProps ||\n          oldState !== current.memoizedState\n        ) {\n          workInProgress.effectTag |= Update;\n        }\n      }\n      return false;\n    }\n\n    var shouldUpdate = checkShouldComponentUpdate(\n      workInProgress,\n      oldProps,\n      newProps,\n      oldState,\n      newState,\n      newContext\n    );\n\n    if (shouldUpdate) {\n      // In order to support react-lifecycles-compat polyfilled components,\n      // Unsafe lifecycles should not be invoked for any component with the new gDSFP.\n      if (\n        (typeof instance.UNSAFE_componentWillUpdate === \"function\" ||\n          typeof instance.componentWillUpdate === \"function\") &&\n        typeof ctor.getDerivedStateFromProps !== \"function\"\n      ) {\n        startPhaseTimer(workInProgress, \"componentWillUpdate\");\n        if (typeof instance.componentWillUpdate === \"function\") {\n          instance.componentWillUpdate(newProps, newState, newContext);\n        }\n        if (typeof instance.UNSAFE_componentWillUpdate === \"function\") {\n          instance.UNSAFE_componentWillUpdate(newProps, newState, newContext);\n        }\n        stopPhaseTimer();\n      }\n      if (typeof instance.componentDidUpdate === \"function\") {\n        workInProgress.effectTag |= Update;\n      }\n    } else {\n      // If an update was already in progress, we should schedule an Update\n      // effect even though we're bailing out, so that cWU/cDU are called.\n      if (typeof instance.componentDidUpdate === \"function\") {\n        if (\n          oldProps !== current.memoizedProps ||\n          oldState !== current.memoizedState\n        ) {\n          workInProgress.effectTag |= Update;\n        }\n      }\n\n      // If shouldComponentUpdate returned false, we should still update the\n      // memoized props/state to indicate that this work can be reused.\n      memoizeProps(workInProgress, newProps);\n      memoizeState(workInProgress, newState);\n    }\n\n    // Update the existing instance's state, props, and context pointers even\n    // if shouldComponentUpdate returns false.\n    instance.props = newProps;\n    instance.state = newState;\n    instance.context = newContext;\n\n    return shouldUpdate;\n  }\n\n  return {\n    adoptClassInstance: adoptClassInstance,\n    callGetDerivedStateFromProps: callGetDerivedStateFromProps,\n    constructClassInstance: constructClassInstance,\n    mountClassInstance: mountClassInstance,\n    resumeMountClassInstance: resumeMountClassInstance,\n    updateClassInstance: updateClassInstance\n  };\n};\n\nvar getCurrentFiberStackAddendum$1 =\n  ReactDebugCurrentFiber.getCurrentFiberStackAddendum;\n\nvar didWarnAboutMaps = void 0;\nvar didWarnAboutStringRefInStrictMode = void 0;\nvar ownerHasKeyUseWarning = void 0;\nvar ownerHasFunctionTypeWarning = void 0;\nvar warnForMissingKey = function(child) {};\n\n{\n  didWarnAboutMaps = false;\n  didWarnAboutStringRefInStrictMode = {};\n\n  /**\n   * Warn if there's no key explicitly set on dynamic arrays of children or\n   * object keys are not valid. This allows us to keep track of children between\n   * updates.\n   */\n  ownerHasKeyUseWarning = {};\n  ownerHasFunctionTypeWarning = {};\n\n  warnForMissingKey = function(child) {\n    if (child === null || typeof child !== \"object\") {\n      return;\n    }\n    if (!child._store || child._store.validated || child.key != null) {\n      return;\n    }\n    invariant(\n      typeof child._store === \"object\",\n      \"React Component in warnForMissingKey should have a _store. \" +\n        \"This error is likely caused by a bug in React. Please file an issue.\"\n    );\n    child._store.validated = true;\n\n    var currentComponentErrorInfo =\n      \"Each child in an array or iterator should have a unique \" +\n      '\"key\" prop. See https://fb.me/react-warning-keys for ' +\n      \"more information.\" +\n      (getCurrentFiberStackAddendum$1() || \"\");\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true;\n\n    warning(\n      false,\n      \"Each child in an array or iterator should have a unique \" +\n        '\"key\" prop. See https://fb.me/react-warning-keys for ' +\n        \"more information.%s\",\n      getCurrentFiberStackAddendum$1()\n    );\n  };\n}\n\nvar isArray$1 = Array.isArray;\n\nfunction coerceRef(returnFiber, current, element) {\n  var mixedRef = element.ref;\n  if (\n    mixedRef !== null &&\n    typeof mixedRef !== \"function\" &&\n    typeof mixedRef !== \"object\"\n  ) {\n    {\n      if (returnFiber.mode & StrictMode) {\n        var componentName = getComponentName(returnFiber) || \"Component\";\n        if (!didWarnAboutStringRefInStrictMode[componentName]) {\n          warning(\n            false,\n            'A string ref, \"%s\",has been found within a strict mode tree. ' +\n              \"String refs are a source of potential bugs and should be avoided. \" +\n              \"We recommend using createRef() instead.\" +\n              \"\\n%s\" +\n              \"\\n\\nLearn more about using refs safely here:\" +\n              \"\\nhttps://fb.me/react-strict-mode-string-ref\",\n            mixedRef,\n            getStackAddendumByWorkInProgressFiber(returnFiber)\n          );\n          didWarnAboutStringRefInStrictMode[componentName] = true;\n        }\n      }\n    }\n\n    if (element._owner) {\n      var owner = element._owner;\n      var inst = void 0;\n      if (owner) {\n        var ownerFiber = owner;\n        invariant(\n          ownerFiber.tag === ClassComponent,\n          \"Stateless function components cannot have refs.\"\n        );\n        inst = ownerFiber.stateNode;\n      }\n      invariant(\n        inst,\n        \"Missing owner for string ref %s. This error is likely caused by a \" +\n          \"bug in React. Please file an issue.\",\n        mixedRef\n      );\n      var stringRef = \"\" + mixedRef;\n      // Check if previous string ref matches new string ref\n      if (\n        current !== null &&\n        current.ref !== null &&\n        current.ref._stringRef === stringRef\n      ) {\n        return current.ref;\n      }\n      var ref = function(value) {\n        var refs = inst.refs === emptyObject ? (inst.refs = {}) : inst.refs;\n        if (value === null) {\n          delete refs[stringRef];\n        } else {\n          refs[stringRef] = value;\n        }\n      };\n      ref._stringRef = stringRef;\n      return ref;\n    } else {\n      invariant(\n        typeof mixedRef === \"string\",\n        \"Expected ref to be a function or a string.\"\n      );\n      invariant(\n        element._owner,\n        \"Element ref was specified as a string (%s) but no owner was set. This could happen for one of\" +\n          \" the following reasons:\\n\" +\n          \"1. You may be adding a ref to a functional component\\n\" +\n          \"2. You may be adding a ref to a component that was not created inside a component's render method\\n\" +\n          \"3. You have multiple copies of React loaded\\n\" +\n          \"See https://fb.me/react-refs-must-have-owner for more information.\",\n        mixedRef\n      );\n    }\n  }\n  return mixedRef;\n}\n\nfunction throwOnInvalidObjectType(returnFiber, newChild) {\n  if (returnFiber.type !== \"textarea\") {\n    var addendum = \"\";\n    {\n      addendum =\n        \" If you meant to render a collection of children, use an array \" +\n        \"instead.\" +\n        (getCurrentFiberStackAddendum$1() || \"\");\n    }\n    invariant(\n      false,\n      \"Objects are not valid as a React child (found: %s).%s\",\n      Object.prototype.toString.call(newChild) === \"[object Object]\"\n        ? \"object with keys {\" + Object.keys(newChild).join(\", \") + \"}\"\n        : newChild,\n      addendum\n    );\n  }\n}\n\nfunction warnOnFunctionType() {\n  var currentComponentErrorInfo =\n    \"Functions are not valid as a React child. This may happen if \" +\n    \"you return a Component instead of <Component /> from render. \" +\n    \"Or maybe you meant to call this function rather than return it.\" +\n    (getCurrentFiberStackAddendum$1() || \"\");\n\n  if (ownerHasFunctionTypeWarning[currentComponentErrorInfo]) {\n    return;\n  }\n  ownerHasFunctionTypeWarning[currentComponentErrorInfo] = true;\n\n  warning(\n    false,\n    \"Functions are not valid as a React child. This may happen if \" +\n      \"you return a Component instead of <Component /> from render. \" +\n      \"Or maybe you meant to call this function rather than return it.%s\",\n    getCurrentFiberStackAddendum$1() || \"\"\n  );\n}\n\n// This wrapper function exists because I expect to clone the code in each path\n// to be able to optimize each path individually by branching early. This needs\n// a compiler or we can do it manually. Helpers that don't need this branching\n// live outside of this function.\nfunction ChildReconciler(shouldTrackSideEffects) {\n  function deleteChild(returnFiber, childToDelete) {\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return;\n    }\n    // Deletions are added in reversed order so we add it to the front.\n    // At this point, the return fiber's effect list is empty except for\n    // deletions, so we can just append the deletion to the list. The remaining\n    // effects aren't added until the complete phase. Once we implement\n    // resuming, this may not be true.\n    var last = returnFiber.lastEffect;\n    if (last !== null) {\n      last.nextEffect = childToDelete;\n      returnFiber.lastEffect = childToDelete;\n    } else {\n      returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;\n    }\n    childToDelete.nextEffect = null;\n    childToDelete.effectTag = Deletion;\n  }\n\n  function deleteRemainingChildren(returnFiber, currentFirstChild) {\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return null;\n    }\n\n    // TODO: For the shouldClone case, this could be micro-optimized a bit by\n    // assuming that after the first child we've already added everything.\n    var childToDelete = currentFirstChild;\n    while (childToDelete !== null) {\n      deleteChild(returnFiber, childToDelete);\n      childToDelete = childToDelete.sibling;\n    }\n    return null;\n  }\n\n  function mapRemainingChildren(returnFiber, currentFirstChild) {\n    // Add the remaining children to a temporary map so that we can find them by\n    // keys quickly. Implicit (null) keys get added to this set with their index\n    var existingChildren = new Map();\n\n    var existingChild = currentFirstChild;\n    while (existingChild !== null) {\n      if (existingChild.key !== null) {\n        existingChildren.set(existingChild.key, existingChild);\n      } else {\n        existingChildren.set(existingChild.index, existingChild);\n      }\n      existingChild = existingChild.sibling;\n    }\n    return existingChildren;\n  }\n\n  function useFiber(fiber, pendingProps, expirationTime) {\n    // We currently set sibling to null and index to 0 here because it is easy\n    // to forget to do before returning it. E.g. for the single child case.\n    var clone = createWorkInProgress(fiber, pendingProps, expirationTime);\n    clone.index = 0;\n    clone.sibling = null;\n    return clone;\n  }\n\n  function placeChild(newFiber, lastPlacedIndex, newIndex) {\n    newFiber.index = newIndex;\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return lastPlacedIndex;\n    }\n    var current = newFiber.alternate;\n    if (current !== null) {\n      var oldIndex = current.index;\n      if (oldIndex < lastPlacedIndex) {\n        // This is a move.\n        newFiber.effectTag = Placement;\n        return lastPlacedIndex;\n      } else {\n        // This item can stay in place.\n        return oldIndex;\n      }\n    } else {\n      // This is an insertion.\n      newFiber.effectTag = Placement;\n      return lastPlacedIndex;\n    }\n  }\n\n  function placeSingleChild(newFiber) {\n    // This is simpler for the single child case. We only need to do a\n    // placement for inserting new children.\n    if (shouldTrackSideEffects && newFiber.alternate === null) {\n      newFiber.effectTag = Placement;\n    }\n    return newFiber;\n  }\n\n  function updateTextNode(returnFiber, current, textContent, expirationTime) {\n    if (current === null || current.tag !== HostText) {\n      // Insert\n      var created = createFiberFromText(\n        textContent,\n        returnFiber.mode,\n        expirationTime\n      );\n      created[\"return\"] = returnFiber;\n      return created;\n    } else {\n      // Update\n      var existing = useFiber(current, textContent, expirationTime);\n      existing[\"return\"] = returnFiber;\n      return existing;\n    }\n  }\n\n  function updateElement(returnFiber, current, element, expirationTime) {\n    if (current !== null && current.type === element.type) {\n      // Move based on index\n      var existing = useFiber(current, element.props, expirationTime);\n      existing.ref = coerceRef(returnFiber, current, element);\n      existing[\"return\"] = returnFiber;\n      {\n        existing._debugSource = element._source;\n        existing._debugOwner = element._owner;\n      }\n      return existing;\n    } else {\n      // Insert\n      var created = createFiberFromElement(\n        element,\n        returnFiber.mode,\n        expirationTime\n      );\n      created.ref = coerceRef(returnFiber, current, element);\n      created[\"return\"] = returnFiber;\n      return created;\n    }\n  }\n\n  function updatePortal(returnFiber, current, portal, expirationTime) {\n    if (\n      current === null ||\n      current.tag !== HostPortal ||\n      current.stateNode.containerInfo !== portal.containerInfo ||\n      current.stateNode.implementation !== portal.implementation\n    ) {\n      // Insert\n      var created = createFiberFromPortal(\n        portal,\n        returnFiber.mode,\n        expirationTime\n      );\n      created[\"return\"] = returnFiber;\n      return created;\n    } else {\n      // Update\n      var existing = useFiber(current, portal.children || [], expirationTime);\n      existing[\"return\"] = returnFiber;\n      return existing;\n    }\n  }\n\n  function updateFragment(returnFiber, current, fragment, expirationTime, key) {\n    if (current === null || current.tag !== Fragment) {\n      // Insert\n      var created = createFiberFromFragment(\n        fragment,\n        returnFiber.mode,\n        expirationTime,\n        key\n      );\n      created[\"return\"] = returnFiber;\n      return created;\n    } else {\n      // Update\n      var existing = useFiber(current, fragment, expirationTime);\n      existing[\"return\"] = returnFiber;\n      return existing;\n    }\n  }\n\n  function createChild(returnFiber, newChild, expirationTime) {\n    if (typeof newChild === \"string\" || typeof newChild === \"number\") {\n      // Text nodes don't have keys. If the previous node is implicitly keyed\n      // we can continue to replace it without aborting even if it is not a text\n      // node.\n      var created = createFiberFromText(\n        \"\" + newChild,\n        returnFiber.mode,\n        expirationTime\n      );\n      created[\"return\"] = returnFiber;\n      return created;\n    }\n\n    if (typeof newChild === \"object\" && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE: {\n          var _created = createFiberFromElement(\n            newChild,\n            returnFiber.mode,\n            expirationTime\n          );\n          _created.ref = coerceRef(returnFiber, null, newChild);\n          _created[\"return\"] = returnFiber;\n          return _created;\n        }\n        case REACT_PORTAL_TYPE: {\n          var _created2 = createFiberFromPortal(\n            newChild,\n            returnFiber.mode,\n            expirationTime\n          );\n          _created2[\"return\"] = returnFiber;\n          return _created2;\n        }\n      }\n\n      if (isArray$1(newChild) || getIteratorFn(newChild)) {\n        var _created3 = createFiberFromFragment(\n          newChild,\n          returnFiber.mode,\n          expirationTime,\n          null\n        );\n        _created3[\"return\"] = returnFiber;\n        return _created3;\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === \"function\") {\n        warnOnFunctionType();\n      }\n    }\n\n    return null;\n  }\n\n  function updateSlot(returnFiber, oldFiber, newChild, expirationTime) {\n    // Update the fiber if the keys match, otherwise return null.\n\n    var key = oldFiber !== null ? oldFiber.key : null;\n\n    if (typeof newChild === \"string\" || typeof newChild === \"number\") {\n      // Text nodes don't have keys. If the previous node is implicitly keyed\n      // we can continue to replace it without aborting even if it is not a text\n      // node.\n      if (key !== null) {\n        return null;\n      }\n      return updateTextNode(\n        returnFiber,\n        oldFiber,\n        \"\" + newChild,\n        expirationTime\n      );\n    }\n\n    if (typeof newChild === \"object\" && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE: {\n          if (newChild.key === key) {\n            if (newChild.type === REACT_FRAGMENT_TYPE) {\n              return updateFragment(\n                returnFiber,\n                oldFiber,\n                newChild.props.children,\n                expirationTime,\n                key\n              );\n            }\n            return updateElement(\n              returnFiber,\n              oldFiber,\n              newChild,\n              expirationTime\n            );\n          } else {\n            return null;\n          }\n        }\n        case REACT_PORTAL_TYPE: {\n          if (newChild.key === key) {\n            return updatePortal(\n              returnFiber,\n              oldFiber,\n              newChild,\n              expirationTime\n            );\n          } else {\n            return null;\n          }\n        }\n      }\n\n      if (isArray$1(newChild) || getIteratorFn(newChild)) {\n        if (key !== null) {\n          return null;\n        }\n\n        return updateFragment(\n          returnFiber,\n          oldFiber,\n          newChild,\n          expirationTime,\n          null\n        );\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === \"function\") {\n        warnOnFunctionType();\n      }\n    }\n\n    return null;\n  }\n\n  function updateFromMap(\n    existingChildren,\n    returnFiber,\n    newIdx,\n    newChild,\n    expirationTime\n  ) {\n    if (typeof newChild === \"string\" || typeof newChild === \"number\") {\n      // Text nodes don't have keys, so we neither have to check the old nor\n      // new node for the key. If both are text nodes, they match.\n      var matchedFiber = existingChildren.get(newIdx) || null;\n      return updateTextNode(\n        returnFiber,\n        matchedFiber,\n        \"\" + newChild,\n        expirationTime\n      );\n    }\n\n    if (typeof newChild === \"object\" && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE: {\n          var _matchedFiber =\n            existingChildren.get(\n              newChild.key === null ? newIdx : newChild.key\n            ) || null;\n          if (newChild.type === REACT_FRAGMENT_TYPE) {\n            return updateFragment(\n              returnFiber,\n              _matchedFiber,\n              newChild.props.children,\n              expirationTime,\n              newChild.key\n            );\n          }\n          return updateElement(\n            returnFiber,\n            _matchedFiber,\n            newChild,\n            expirationTime\n          );\n        }\n        case REACT_PORTAL_TYPE: {\n          var _matchedFiber2 =\n            existingChildren.get(\n              newChild.key === null ? newIdx : newChild.key\n            ) || null;\n          return updatePortal(\n            returnFiber,\n            _matchedFiber2,\n            newChild,\n            expirationTime\n          );\n        }\n      }\n\n      if (isArray$1(newChild) || getIteratorFn(newChild)) {\n        var _matchedFiber3 = existingChildren.get(newIdx) || null;\n        return updateFragment(\n          returnFiber,\n          _matchedFiber3,\n          newChild,\n          expirationTime,\n          null\n        );\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === \"function\") {\n        warnOnFunctionType();\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Warns if there is a duplicate or missing key\n   */\n  function warnOnInvalidKey(child, knownKeys) {\n    {\n      if (typeof child !== \"object\" || child === null) {\n        return knownKeys;\n      }\n      switch (child.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n        case REACT_PORTAL_TYPE:\n          warnForMissingKey(child);\n          var key = child.key;\n          if (typeof key !== \"string\") {\n            break;\n          }\n          if (knownKeys === null) {\n            knownKeys = new Set();\n            knownKeys.add(key);\n            break;\n          }\n          if (!knownKeys.has(key)) {\n            knownKeys.add(key);\n            break;\n          }\n          warning(\n            false,\n            \"Encountered two children with the same key, `%s`. \" +\n              \"Keys should be unique so that components maintain their identity \" +\n              \"across updates. Non-unique keys may cause children to be \" +\n              \"duplicated and/or omitted  the behavior is unsupported and \" +\n              \"could change in a future version.%s\",\n            key,\n            getCurrentFiberStackAddendum$1()\n          );\n          break;\n        default:\n          break;\n      }\n    }\n    return knownKeys;\n  }\n\n  function reconcileChildrenArray(\n    returnFiber,\n    currentFirstChild,\n    newChildren,\n    expirationTime\n  ) {\n    // This algorithm can't optimize by searching from boths ends since we\n    // don't have backpointers on fibers. I'm trying to see how far we can get\n    // with that model. If it ends up not being worth the tradeoffs, we can\n    // add it later.\n\n    // Even with a two ended optimization, we'd want to optimize for the case\n    // where there are few changes and brute force the comparison instead of\n    // going for the Map. It'd like to explore hitting that path first in\n    // forward-only mode and only go for the Map once we notice that we need\n    // lots of look ahead. This doesn't handle reversal as well as two ended\n    // search but that's unusual. Besides, for the two ended optimization to\n    // work on Iterables, we'd need to copy the whole set.\n\n    // In this first iteration, we'll just live with hitting the bad case\n    // (adding everything to a Map) in for every insert/move.\n\n    // If you change this code, also update reconcileChildrenIterator() which\n    // uses the same algorithm.\n\n    {\n      // First, validate keys.\n      var knownKeys = null;\n      for (var i = 0; i < newChildren.length; i++) {\n        var child = newChildren[i];\n        knownKeys = warnOnInvalidKey(child, knownKeys);\n      }\n    }\n\n    var resultingFirstChild = null;\n    var previousNewFiber = null;\n\n    var oldFiber = currentFirstChild;\n    var lastPlacedIndex = 0;\n    var newIdx = 0;\n    var nextOldFiber = null;\n    for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {\n      if (oldFiber.index > newIdx) {\n        nextOldFiber = oldFiber;\n        oldFiber = null;\n      } else {\n        nextOldFiber = oldFiber.sibling;\n      }\n      var newFiber = updateSlot(\n        returnFiber,\n        oldFiber,\n        newChildren[newIdx],\n        expirationTime\n      );\n      if (newFiber === null) {\n        // TODO: This breaks on empty slots like null children. That's\n        // unfortunate because it triggers the slow path all the time. We need\n        // a better way to communicate whether this was a miss or null,\n        // boolean, undefined, etc.\n        if (oldFiber === null) {\n          oldFiber = nextOldFiber;\n        }\n        break;\n      }\n      if (shouldTrackSideEffects) {\n        if (oldFiber && newFiber.alternate === null) {\n          // We matched the slot, but we didn't reuse the existing fiber, so we\n          // need to delete the existing child.\n          deleteChild(returnFiber, oldFiber);\n        }\n      }\n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n      if (previousNewFiber === null) {\n        // TODO: Move out of the loop. This only happens for the first run.\n        resultingFirstChild = newFiber;\n      } else {\n        // TODO: Defer siblings if we're not at the right index for this slot.\n        // I.e. if we had null values before, then we want to defer this\n        // for each null value. However, we also don't want to call updateSlot\n        // with the previous one.\n        previousNewFiber.sibling = newFiber;\n      }\n      previousNewFiber = newFiber;\n      oldFiber = nextOldFiber;\n    }\n\n    if (newIdx === newChildren.length) {\n      // We've reached the end of the new children. We can delete the rest.\n      deleteRemainingChildren(returnFiber, oldFiber);\n      return resultingFirstChild;\n    }\n\n    if (oldFiber === null) {\n      // If we don't have any more existing children we can choose a fast path\n      // since the rest will all be insertions.\n      for (; newIdx < newChildren.length; newIdx++) {\n        var _newFiber = createChild(\n          returnFiber,\n          newChildren[newIdx],\n          expirationTime\n        );\n        if (!_newFiber) {\n          continue;\n        }\n        lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          // TODO: Move out of the loop. This only happens for the first run.\n          resultingFirstChild = _newFiber;\n        } else {\n          previousNewFiber.sibling = _newFiber;\n        }\n        previousNewFiber = _newFiber;\n      }\n      return resultingFirstChild;\n    }\n\n    // Add all children to a key map for quick lookups.\n    var existingChildren = mapRemainingChildren(returnFiber, oldFiber);\n\n    // Keep scanning and use the map to restore deleted items as moves.\n    for (; newIdx < newChildren.length; newIdx++) {\n      var _newFiber2 = updateFromMap(\n        existingChildren,\n        returnFiber,\n        newIdx,\n        newChildren[newIdx],\n        expirationTime\n      );\n      if (_newFiber2) {\n        if (shouldTrackSideEffects) {\n          if (_newFiber2.alternate !== null) {\n            // The new fiber is a work in progress, but if there exists a\n            // current, that means that we reused the fiber. We need to delete\n            // it from the child list so that we don't add it to the deletion\n            // list.\n            existingChildren[\"delete\"](\n              _newFiber2.key === null ? newIdx : _newFiber2.key\n            );\n          }\n        }\n        lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          resultingFirstChild = _newFiber2;\n        } else {\n          previousNewFiber.sibling = _newFiber2;\n        }\n        previousNewFiber = _newFiber2;\n      }\n    }\n\n    if (shouldTrackSideEffects) {\n      // Any existing children that weren't consumed above were deleted. We need\n      // to add them to the deletion list.\n      existingChildren.forEach(function(child) {\n        return deleteChild(returnFiber, child);\n      });\n    }\n\n    return resultingFirstChild;\n  }\n\n  function reconcileChildrenIterator(\n    returnFiber,\n    currentFirstChild,\n    newChildrenIterable,\n    expirationTime\n  ) {\n    // This is the same implementation as reconcileChildrenArray(),\n    // but using the iterator instead.\n\n    var iteratorFn = getIteratorFn(newChildrenIterable);\n    invariant(\n      typeof iteratorFn === \"function\",\n      \"An object is not an iterable. This error is likely caused by a bug in \" +\n        \"React. Please file an issue.\"\n    );\n\n    {\n      // Warn about using Maps as children\n      if (typeof newChildrenIterable.entries === \"function\") {\n        var possibleMap = newChildrenIterable;\n        if (possibleMap.entries === iteratorFn) {\n          warning(\n            didWarnAboutMaps,\n            \"Using Maps as children is unsupported and will likely yield \" +\n              \"unexpected results. Convert it to a sequence/iterable of keyed \" +\n              \"ReactElements instead.%s\",\n            getCurrentFiberStackAddendum$1()\n          );\n          didWarnAboutMaps = true;\n        }\n      }\n\n      // First, validate keys.\n      // We'll get a different iterator later for the main pass.\n      var _newChildren = iteratorFn.call(newChildrenIterable);\n      if (_newChildren) {\n        var knownKeys = null;\n        var _step = _newChildren.next();\n        for (; !_step.done; _step = _newChildren.next()) {\n          var child = _step.value;\n          knownKeys = warnOnInvalidKey(child, knownKeys);\n        }\n      }\n    }\n\n    var newChildren = iteratorFn.call(newChildrenIterable);\n    invariant(newChildren != null, \"An iterable object provided no iterator.\");\n\n    var resultingFirstChild = null;\n    var previousNewFiber = null;\n\n    var oldFiber = currentFirstChild;\n    var lastPlacedIndex = 0;\n    var newIdx = 0;\n    var nextOldFiber = null;\n\n    var step = newChildren.next();\n    for (\n      ;\n      oldFiber !== null && !step.done;\n      newIdx++, step = newChildren.next()\n    ) {\n      if (oldFiber.index > newIdx) {\n        nextOldFiber = oldFiber;\n        oldFiber = null;\n      } else {\n        nextOldFiber = oldFiber.sibling;\n      }\n      var newFiber = updateSlot(\n        returnFiber,\n        oldFiber,\n        step.value,\n        expirationTime\n      );\n      if (newFiber === null) {\n        // TODO: This breaks on empty slots like null children. That's\n        // unfortunate because it triggers the slow path all the time. We need\n        // a better way to communicate whether this was a miss or null,\n        // boolean, undefined, etc.\n        if (!oldFiber) {\n          oldFiber = nextOldFiber;\n        }\n        break;\n      }\n      if (shouldTrackSideEffects) {\n        if (oldFiber && newFiber.alternate === null) {\n          // We matched the slot, but we didn't reuse the existing fiber, so we\n          // need to delete the existing child.\n          deleteChild(returnFiber, oldFiber);\n        }\n      }\n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n      if (previousNewFiber === null) {\n        // TODO: Move out of the loop. This only happens for the first run.\n        resultingFirstChild = newFiber;\n      } else {\n        // TODO: Defer siblings if we're not at the right index for this slot.\n        // I.e. if we had null values before, then we want to defer this\n        // for each null value. However, we also don't want to call updateSlot\n        // with the previous one.\n        previousNewFiber.sibling = newFiber;\n      }\n      previousNewFiber = newFiber;\n      oldFiber = nextOldFiber;\n    }\n\n    if (step.done) {\n      // We've reached the end of the new children. We can delete the rest.\n      deleteRemainingChildren(returnFiber, oldFiber);\n      return resultingFirstChild;\n    }\n\n    if (oldFiber === null) {\n      // If we don't have any more existing children we can choose a fast path\n      // since the rest will all be insertions.\n      for (; !step.done; newIdx++, step = newChildren.next()) {\n        var _newFiber3 = createChild(returnFiber, step.value, expirationTime);\n        if (_newFiber3 === null) {\n          continue;\n        }\n        lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          // TODO: Move out of the loop. This only happens for the first run.\n          resultingFirstChild = _newFiber3;\n        } else {\n          previousNewFiber.sibling = _newFiber3;\n        }\n        previousNewFiber = _newFiber3;\n      }\n      return resultingFirstChild;\n    }\n\n    // Add all children to a key map for quick lookups.\n    var existingChildren = mapRemainingChildren(returnFiber, oldFiber);\n\n    // Keep scanning and use the map to restore deleted items as moves.\n    for (; !step.done; newIdx++, step = newChildren.next()) {\n      var _newFiber4 = updateFromMap(\n        existingChildren,\n        returnFiber,\n        newIdx,\n        step.value,\n        expirationTime\n      );\n      if (_newFiber4 !== null) {\n        if (shouldTrackSideEffects) {\n          if (_newFiber4.alternate !== null) {\n            // The new fiber is a work in progress, but if there exists a\n            // current, that means that we reused the fiber. We need to delete\n            // it from the child list so that we don't add it to the deletion\n            // list.\n            existingChildren[\"delete\"](\n              _newFiber4.key === null ? newIdx : _newFiber4.key\n            );\n          }\n        }\n        lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          resultingFirstChild = _newFiber4;\n        } else {\n          previousNewFiber.sibling = _newFiber4;\n        }\n        previousNewFiber = _newFiber4;\n      }\n    }\n\n    if (shouldTrackSideEffects) {\n      // Any existing children that weren't consumed above were deleted. We need\n      // to add them to the deletion list.\n      existingChildren.forEach(function(child) {\n        return deleteChild(returnFiber, child);\n      });\n    }\n\n    return resultingFirstChild;\n  }\n\n  function reconcileSingleTextNode(\n    returnFiber,\n    currentFirstChild,\n    textContent,\n    expirationTime\n  ) {\n    // There's no need to check for keys on text nodes since we don't have a\n    // way to define them.\n    if (currentFirstChild !== null && currentFirstChild.tag === HostText) {\n      // We already have an existing node so let's just update it and delete\n      // the rest.\n      deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n      var existing = useFiber(currentFirstChild, textContent, expirationTime);\n      existing[\"return\"] = returnFiber;\n      return existing;\n    }\n    // The existing first child is not a text node so we need to create one\n    // and delete the existing ones.\n    deleteRemainingChildren(returnFiber, currentFirstChild);\n    var created = createFiberFromText(\n      textContent,\n      returnFiber.mode,\n      expirationTime\n    );\n    created[\"return\"] = returnFiber;\n    return created;\n  }\n\n  function reconcileSingleElement(\n    returnFiber,\n    currentFirstChild,\n    element,\n    expirationTime\n  ) {\n    var key = element.key;\n    var child = currentFirstChild;\n    while (child !== null) {\n      // TODO: If key === null and child.key === null, then this only applies to\n      // the first item in the list.\n      if (child.key === key) {\n        if (\n          child.tag === Fragment\n            ? element.type === REACT_FRAGMENT_TYPE\n            : child.type === element.type\n        ) {\n          deleteRemainingChildren(returnFiber, child.sibling);\n          var existing = useFiber(\n            child,\n            element.type === REACT_FRAGMENT_TYPE\n              ? element.props.children\n              : element.props,\n            expirationTime\n          );\n          existing.ref = coerceRef(returnFiber, child, element);\n          existing[\"return\"] = returnFiber;\n          {\n            existing._debugSource = element._source;\n            existing._debugOwner = element._owner;\n          }\n          return existing;\n        } else {\n          deleteRemainingChildren(returnFiber, child);\n          break;\n        }\n      } else {\n        deleteChild(returnFiber, child);\n      }\n      child = child.sibling;\n    }\n\n    if (element.type === REACT_FRAGMENT_TYPE) {\n      var created = createFiberFromFragment(\n        element.props.children,\n        returnFiber.mode,\n        expirationTime,\n        element.key\n      );\n      created[\"return\"] = returnFiber;\n      return created;\n    } else {\n      var _created4 = createFiberFromElement(\n        element,\n        returnFiber.mode,\n        expirationTime\n      );\n      _created4.ref = coerceRef(returnFiber, currentFirstChild, element);\n      _created4[\"return\"] = returnFiber;\n      return _created4;\n    }\n  }\n\n  function reconcileSinglePortal(\n    returnFiber,\n    currentFirstChild,\n    portal,\n    expirationTime\n  ) {\n    var key = portal.key;\n    var child = currentFirstChild;\n    while (child !== null) {\n      // TODO: If key === null and child.key === null, then this only applies to\n      // the first item in the list.\n      if (child.key === key) {\n        if (\n          child.tag === HostPortal &&\n          child.stateNode.containerInfo === portal.containerInfo &&\n          child.stateNode.implementation === portal.implementation\n        ) {\n          deleteRemainingChildren(returnFiber, child.sibling);\n          var existing = useFiber(child, portal.children || [], expirationTime);\n          existing[\"return\"] = returnFiber;\n          return existing;\n        } else {\n          deleteRemainingChildren(returnFiber, child);\n          break;\n        }\n      } else {\n        deleteChild(returnFiber, child);\n      }\n      child = child.sibling;\n    }\n\n    var created = createFiberFromPortal(\n      portal,\n      returnFiber.mode,\n      expirationTime\n    );\n    created[\"return\"] = returnFiber;\n    return created;\n  }\n\n  // This API will tag the children with the side-effect of the reconciliation\n  // itself. They will be added to the side-effect list as we pass through the\n  // children and the parent.\n  function reconcileChildFibers(\n    returnFiber,\n    currentFirstChild,\n    newChild,\n    expirationTime\n  ) {\n    // This function is not recursive.\n    // If the top level item is an array, we treat it as a set of children,\n    // not as a fragment. Nested arrays on the other hand will be treated as\n    // fragment nodes. Recursion happens at the normal flow.\n\n    // Handle top level unkeyed fragments as if they were arrays.\n    // This leads to an ambiguity between <>{[...]}</> and <>...</>.\n    // We treat the ambiguous cases above the same.\n    if (\n      typeof newChild === \"object\" &&\n      newChild !== null &&\n      newChild.type === REACT_FRAGMENT_TYPE &&\n      newChild.key === null\n    ) {\n      newChild = newChild.props.children;\n    }\n\n    // Handle object types\n    var isObject = typeof newChild === \"object\" && newChild !== null;\n\n    if (isObject) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          return placeSingleChild(\n            reconcileSingleElement(\n              returnFiber,\n              currentFirstChild,\n              newChild,\n              expirationTime\n            )\n          );\n        case REACT_PORTAL_TYPE:\n          return placeSingleChild(\n            reconcileSinglePortal(\n              returnFiber,\n              currentFirstChild,\n              newChild,\n              expirationTime\n            )\n          );\n      }\n    }\n\n    if (typeof newChild === \"string\" || typeof newChild === \"number\") {\n      return placeSingleChild(\n        reconcileSingleTextNode(\n          returnFiber,\n          currentFirstChild,\n          \"\" + newChild,\n          expirationTime\n        )\n      );\n    }\n\n    if (isArray$1(newChild)) {\n      return reconcileChildrenArray(\n        returnFiber,\n        currentFirstChild,\n        newChild,\n        expirationTime\n      );\n    }\n\n    if (getIteratorFn(newChild)) {\n      return reconcileChildrenIterator(\n        returnFiber,\n        currentFirstChild,\n        newChild,\n        expirationTime\n      );\n    }\n\n    if (isObject) {\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === \"function\") {\n        warnOnFunctionType();\n      }\n    }\n    if (typeof newChild === \"undefined\") {\n      // If the new child is undefined, and the return fiber is a composite\n      // component, throw an error. If Fiber return types are disabled,\n      // we already threw above.\n      switch (returnFiber.tag) {\n        case ClassComponent: {\n          {\n            var instance = returnFiber.stateNode;\n            if (instance.render._isMockFunction) {\n              // We allow auto-mocks to proceed as if they're returning null.\n              break;\n            }\n          }\n        }\n        // Intentionally fall through to the next case, which handles both\n        // functions and classes\n        // eslint-disable-next-lined no-fallthrough\n        case FunctionalComponent: {\n          var Component = returnFiber.type;\n          invariant(\n            false,\n            \"%s(...): Nothing was returned from render. This usually means a \" +\n              \"return statement is missing. Or, to render nothing, \" +\n              \"return null.\",\n            Component.displayName || Component.name || \"Component\"\n          );\n        }\n      }\n    }\n\n    // Remaining cases are all treated as empty.\n    return deleteRemainingChildren(returnFiber, currentFirstChild);\n  }\n\n  return reconcileChildFibers;\n}\n\nvar reconcileChildFibers = ChildReconciler(true);\nvar mountChildFibers = ChildReconciler(false);\n\nfunction cloneChildFibers(current, workInProgress) {\n  invariant(\n    current === null || workInProgress.child === current.child,\n    \"Resuming work not yet implemented.\"\n  );\n\n  if (workInProgress.child === null) {\n    return;\n  }\n\n  var currentChild = workInProgress.child;\n  var newChild = createWorkInProgress(\n    currentChild,\n    currentChild.pendingProps,\n    currentChild.expirationTime\n  );\n  workInProgress.child = newChild;\n\n  newChild[\"return\"] = workInProgress;\n  while (currentChild.sibling !== null) {\n    currentChild = currentChild.sibling;\n    newChild = newChild.sibling = createWorkInProgress(\n      currentChild,\n      currentChild.pendingProps,\n      currentChild.expirationTime\n    );\n    newChild[\"return\"] = workInProgress;\n  }\n  newChild.sibling = null;\n}\n\nvar changedBitsStack = [];\nvar currentValueStack = [];\nvar stack = [];\nvar index$1 = -1;\n\nvar rendererSigil = void 0;\n{\n  // Use this to detect multiple renderers using the same context\n  rendererSigil = {};\n}\n\nfunction pushProvider(providerFiber) {\n  var context = providerFiber.type.context;\n  index$1 += 1;\n  changedBitsStack[index$1] = context._changedBits;\n  currentValueStack[index$1] = context._currentValue;\n  stack[index$1] = providerFiber;\n  context._currentValue = providerFiber.pendingProps.value;\n  context._changedBits = providerFiber.stateNode;\n\n  {\n    warning(\n      context._currentRenderer === null ||\n        context._currentRenderer === rendererSigil,\n      \"Detected multiple renderers concurrently rendering the \" +\n        \"same context provider. This is currently unsupported.\"\n    );\n    context._currentRenderer = rendererSigil;\n  }\n}\n\nfunction popProvider(providerFiber) {\n  {\n    warning(\n      index$1 > -1 && providerFiber === stack[index$1],\n      \"Unexpected pop.\"\n    );\n  }\n  var changedBits = changedBitsStack[index$1];\n  var currentValue = currentValueStack[index$1];\n  changedBitsStack[index$1] = null;\n  currentValueStack[index$1] = null;\n  stack[index$1] = null;\n  index$1 -= 1;\n  var context = providerFiber.type.context;\n  context._currentValue = currentValue;\n  context._changedBits = changedBits;\n}\n\nfunction resetProviderStack() {\n  for (var i = index$1; i > -1; i--) {\n    var providerFiber = stack[i];\n    var context = providerFiber.type.context;\n    context._currentValue = context._defaultValue;\n    context._changedBits = 0;\n    changedBitsStack[i] = null;\n    currentValueStack[i] = null;\n    stack[i] = null;\n    {\n      context._currentRenderer = null;\n    }\n  }\n  index$1 = -1;\n}\n\nvar didWarnAboutBadClass = void 0;\nvar didWarnAboutGetDerivedStateOnFunctionalComponent = void 0;\nvar didWarnAboutStatelessRefs = void 0;\n\n{\n  didWarnAboutBadClass = {};\n  didWarnAboutGetDerivedStateOnFunctionalComponent = {};\n  didWarnAboutStatelessRefs = {};\n}\n\nvar ReactFiberBeginWork = function(\n  config,\n  hostContext,\n  hydrationContext,\n  scheduleWork,\n  computeExpirationForFiber\n) {\n  var shouldSetTextContent = config.shouldSetTextContent,\n    shouldDeprioritizeSubtree = config.shouldDeprioritizeSubtree;\n  var pushHostContext = hostContext.pushHostContext,\n    pushHostContainer = hostContext.pushHostContainer;\n  var enterHydrationState = hydrationContext.enterHydrationState,\n    resetHydrationState = hydrationContext.resetHydrationState,\n    tryToClaimNextHydratableInstance =\n      hydrationContext.tryToClaimNextHydratableInstance;\n\n  var _ReactFiberClassCompo = ReactFiberClassComponent(\n      scheduleWork,\n      computeExpirationForFiber,\n      memoizeProps,\n      memoizeState\n    ),\n    adoptClassInstance = _ReactFiberClassCompo.adoptClassInstance,\n    callGetDerivedStateFromProps =\n      _ReactFiberClassCompo.callGetDerivedStateFromProps,\n    constructClassInstance = _ReactFiberClassCompo.constructClassInstance,\n    mountClassInstance = _ReactFiberClassCompo.mountClassInstance,\n    resumeMountClassInstance = _ReactFiberClassCompo.resumeMountClassInstance,\n    updateClassInstance = _ReactFiberClassCompo.updateClassInstance;\n\n  // TODO: Remove this and use reconcileChildrenAtExpirationTime directly.\n\n  function reconcileChildren(current, workInProgress, nextChildren) {\n    reconcileChildrenAtExpirationTime(\n      current,\n      workInProgress,\n      nextChildren,\n      workInProgress.expirationTime\n    );\n  }\n\n  function reconcileChildrenAtExpirationTime(\n    current,\n    workInProgress,\n    nextChildren,\n    renderExpirationTime\n  ) {\n    if (current === null) {\n      // If this is a fresh new component that hasn't been rendered yet, we\n      // won't update its child set by applying minimal side-effects. Instead,\n      // we will add them all to the child before it gets rendered. That means\n      // we can optimize this reconciliation pass by not tracking side-effects.\n      workInProgress.child = mountChildFibers(\n        workInProgress,\n        null,\n        nextChildren,\n        renderExpirationTime\n      );\n    } else {\n      // If the current child is the same as the work in progress, it means that\n      // we haven't yet started any work on these children. Therefore, we use\n      // the clone algorithm to create a copy of all the current children.\n\n      // If we had any progressed work already, that is invalid at this point so\n      // let's throw it out.\n      workInProgress.child = reconcileChildFibers(\n        workInProgress,\n        current.child,\n        nextChildren,\n        renderExpirationTime\n      );\n    }\n  }\n\n  function updateFragment(current, workInProgress) {\n    var nextChildren = workInProgress.pendingProps;\n    if (hasContextChanged()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n    } else if (workInProgress.memoizedProps === nextChildren) {\n      return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n    reconcileChildren(current, workInProgress, nextChildren);\n    memoizeProps(workInProgress, nextChildren);\n    return workInProgress.child;\n  }\n\n  function updateMode(current, workInProgress) {\n    var nextChildren = workInProgress.pendingProps.children;\n    if (hasContextChanged()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n    } else if (\n      nextChildren === null ||\n      workInProgress.memoizedProps === nextChildren\n    ) {\n      return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n    reconcileChildren(current, workInProgress, nextChildren);\n    memoizeProps(workInProgress, nextChildren);\n    return workInProgress.child;\n  }\n\n  function markRef(current, workInProgress) {\n    var ref = workInProgress.ref;\n    if (\n      (current === null && ref !== null) ||\n      (current !== null && current.ref !== ref)\n    ) {\n      // Schedule a Ref effect\n      workInProgress.effectTag |= Ref;\n    }\n  }\n\n  function updateFunctionalComponent(current, workInProgress) {\n    var fn = workInProgress.type;\n    var nextProps = workInProgress.pendingProps;\n\n    if (hasContextChanged()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n    } else {\n      if (workInProgress.memoizedProps === nextProps) {\n        return bailoutOnAlreadyFinishedWork(current, workInProgress);\n      }\n      // TODO: consider bringing fn.shouldComponentUpdate() back.\n      // It used to be here.\n    }\n\n    var unmaskedContext = getUnmaskedContext(workInProgress);\n    var context = getMaskedContext(workInProgress, unmaskedContext);\n\n    var nextChildren = void 0;\n\n    {\n      ReactCurrentOwner.current = workInProgress;\n      ReactDebugCurrentFiber.setCurrentPhase(\"render\");\n      nextChildren = fn(nextProps, context);\n      ReactDebugCurrentFiber.setCurrentPhase(null);\n    }\n    // React DevTools reads this flag.\n    workInProgress.effectTag |= PerformedWork;\n    reconcileChildren(current, workInProgress, nextChildren);\n    memoizeProps(workInProgress, nextProps);\n    return workInProgress.child;\n  }\n\n  function updateClassComponent(current, workInProgress, renderExpirationTime) {\n    // Push context providers early to prevent context stack mismatches.\n    // During mounting we don't know the child context yet as the instance doesn't exist.\n    // We will invalidate the child context in finishClassComponent() right after rendering.\n    var hasContext = pushContextProvider(workInProgress);\n    var shouldUpdate = void 0;\n    if (current === null) {\n      if (workInProgress.stateNode === null) {\n        // In the initial pass we might need to construct the instance.\n        constructClassInstance(workInProgress, workInProgress.pendingProps);\n        mountClassInstance(workInProgress, renderExpirationTime);\n\n        shouldUpdate = true;\n      } else {\n        // In a resume, we'll already have an instance we can reuse.\n        shouldUpdate = resumeMountClassInstance(\n          workInProgress,\n          renderExpirationTime\n        );\n      }\n    } else {\n      shouldUpdate = updateClassInstance(\n        current,\n        workInProgress,\n        renderExpirationTime\n      );\n    }\n\n    // We processed the update queue inside updateClassInstance. It may have\n    // included some errors that were dispatched during the commit phase.\n    // TODO: Refactor class components so this is less awkward.\n    var didCaptureError = false;\n    var updateQueue = workInProgress.updateQueue;\n    if (updateQueue !== null && updateQueue.capturedValues !== null) {\n      shouldUpdate = true;\n      didCaptureError = true;\n    }\n    return finishClassComponent(\n      current,\n      workInProgress,\n      shouldUpdate,\n      hasContext,\n      didCaptureError,\n      renderExpirationTime\n    );\n  }\n\n  function finishClassComponent(\n    current,\n    workInProgress,\n    shouldUpdate,\n    hasContext,\n    didCaptureError,\n    renderExpirationTime\n  ) {\n    // Refs should update even if shouldComponentUpdate returns false\n    markRef(current, workInProgress);\n\n    if (!shouldUpdate && !didCaptureError) {\n      // Context providers should defer to sCU for rendering\n      if (hasContext) {\n        invalidateContextProvider(workInProgress, false);\n      }\n\n      return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n\n    var ctor = workInProgress.type;\n    var instance = workInProgress.stateNode;\n\n    // Rerender\n    ReactCurrentOwner.current = workInProgress;\n    var nextChildren = void 0;\n    if (\n      didCaptureError &&\n      (!enableGetDerivedStateFromCatch ||\n        typeof ctor.getDerivedStateFromCatch !== \"function\")\n    ) {\n      // If we captured an error, but getDerivedStateFrom catch is not defined,\n      // unmount all the children. componentDidCatch will schedule an update to\n      // re-render a fallback. This is temporary until we migrate everyone to\n      // the new API.\n      // TODO: Warn in a future release.\n      nextChildren = null;\n    } else {\n      {\n        ReactDebugCurrentFiber.setCurrentPhase(\"render\");\n        nextChildren = instance.render();\n        if (\n          debugRenderPhaseSideEffects ||\n          (debugRenderPhaseSideEffectsForStrictMode &&\n            workInProgress.mode & StrictMode)\n        ) {\n          instance.render();\n        }\n        ReactDebugCurrentFiber.setCurrentPhase(null);\n      }\n    }\n\n    // React DevTools reads this flag.\n    workInProgress.effectTag |= PerformedWork;\n    if (didCaptureError) {\n      // If we're recovering from an error, reconcile twice: first to delete\n      // all the existing children.\n      reconcileChildrenAtExpirationTime(\n        current,\n        workInProgress,\n        null,\n        renderExpirationTime\n      );\n      workInProgress.child = null;\n      // Now we can continue reconciling like normal. This has the effect of\n      // remounting all children regardless of whether their their\n      // identity matches.\n    }\n    reconcileChildrenAtExpirationTime(\n      current,\n      workInProgress,\n      nextChildren,\n      renderExpirationTime\n    );\n    // Memoize props and state using the values we just used to render.\n    // TODO: Restructure so we never read values from the instance.\n    memoizeState(workInProgress, instance.state);\n    memoizeProps(workInProgress, instance.props);\n\n    // The context might have changed so we need to recalculate it.\n    if (hasContext) {\n      invalidateContextProvider(workInProgress, true);\n    }\n\n    return workInProgress.child;\n  }\n\n  function pushHostRootContext(workInProgress) {\n    var root = workInProgress.stateNode;\n    if (root.pendingContext) {\n      pushTopLevelContextObject(\n        workInProgress,\n        root.pendingContext,\n        root.pendingContext !== root.context\n      );\n    } else if (root.context) {\n      // Should always be set\n      pushTopLevelContextObject(workInProgress, root.context, false);\n    }\n    pushHostContainer(workInProgress, root.containerInfo);\n  }\n\n  function updateHostRoot(current, workInProgress, renderExpirationTime) {\n    pushHostRootContext(workInProgress);\n    var updateQueue = workInProgress.updateQueue;\n    if (updateQueue !== null) {\n      var prevState = workInProgress.memoizedState;\n      var state = processUpdateQueue(\n        current,\n        workInProgress,\n        updateQueue,\n        null,\n        null,\n        renderExpirationTime\n      );\n      memoizeState(workInProgress, state);\n      updateQueue = workInProgress.updateQueue;\n\n      var element = void 0;\n      if (updateQueue !== null && updateQueue.capturedValues !== null) {\n        // There's an uncaught error. Unmount the whole root.\n        element = null;\n      } else if (prevState === state) {\n        // If the state is the same as before, that's a bailout because we had\n        // no work that expires at this time.\n        resetHydrationState();\n        return bailoutOnAlreadyFinishedWork(current, workInProgress);\n      } else {\n        element = state.element;\n      }\n      var root = workInProgress.stateNode;\n      if (\n        (current === null || current.child === null) &&\n        root.hydrate &&\n        enterHydrationState(workInProgress)\n      ) {\n        // If we don't have any current children this might be the first pass.\n        // We always try to hydrate. If this isn't a hydration pass there won't\n        // be any children to hydrate which is effectively the same thing as\n        // not hydrating.\n\n        // This is a bit of a hack. We track the host root as a placement to\n        // know that we're currently in a mounting state. That way isMounted\n        // works as expected. We must reset this before committing.\n        // TODO: Delete this when we delete isMounted and findDOMNode.\n        workInProgress.effectTag |= Placement;\n\n        // Ensure that children mount into this root without tracking\n        // side-effects. This ensures that we don't store Placement effects on\n        // nodes that will be hydrated.\n        workInProgress.child = mountChildFibers(\n          workInProgress,\n          null,\n          element,\n          renderExpirationTime\n        );\n      } else {\n        // Otherwise reset hydration state in case we aborted and resumed another\n        // root.\n        resetHydrationState();\n        reconcileChildren(current, workInProgress, element);\n      }\n      memoizeState(workInProgress, state);\n      return workInProgress.child;\n    }\n    resetHydrationState();\n    // If there is no update queue, that's a bailout because the root has no props.\n    return bailoutOnAlreadyFinishedWork(current, workInProgress);\n  }\n\n  function updateHostComponent(current, workInProgress, renderExpirationTime) {\n    pushHostContext(workInProgress);\n\n    if (current === null) {\n      tryToClaimNextHydratableInstance(workInProgress);\n    }\n\n    var type = workInProgress.type;\n    var memoizedProps = workInProgress.memoizedProps;\n    var nextProps = workInProgress.pendingProps;\n    var prevProps = current !== null ? current.memoizedProps : null;\n\n    if (hasContextChanged()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n    } else if (memoizedProps === nextProps) {\n      var isHidden =\n        workInProgress.mode & AsyncMode &&\n        shouldDeprioritizeSubtree(type, nextProps);\n      if (isHidden) {\n        // Before bailing out, make sure we've deprioritized a hidden component.\n        workInProgress.expirationTime = Never;\n      }\n      if (!isHidden || renderExpirationTime !== Never) {\n        return bailoutOnAlreadyFinishedWork(current, workInProgress);\n      }\n      // If we're rendering a hidden node at hidden priority, don't bailout. The\n      // parent is complete, but the children may not be.\n    }\n\n    var nextChildren = nextProps.children;\n    var isDirectTextChild = shouldSetTextContent(type, nextProps);\n\n    if (isDirectTextChild) {\n      // We special case a direct text child of a host node. This is a common\n      // case. We won't handle it as a reified child. We will instead handle\n      // this in the host environment that also have access to this prop. That\n      // avoids allocating another HostText fiber and traversing it.\n      nextChildren = null;\n    } else if (prevProps && shouldSetTextContent(type, prevProps)) {\n      // If we're switching from a direct text child to a normal child, or to\n      // empty, we need to schedule the text content to be reset.\n      workInProgress.effectTag |= ContentReset;\n    }\n\n    markRef(current, workInProgress);\n\n    // Check the host config to see if the children are offscreen/hidden.\n    if (\n      renderExpirationTime !== Never &&\n      workInProgress.mode & AsyncMode &&\n      shouldDeprioritizeSubtree(type, nextProps)\n    ) {\n      // Down-prioritize the children.\n      workInProgress.expirationTime = Never;\n      // Bailout and come back to this fiber later.\n      workInProgress.memoizedProps = nextProps;\n      return null;\n    }\n\n    reconcileChildren(current, workInProgress, nextChildren);\n    memoizeProps(workInProgress, nextProps);\n    return workInProgress.child;\n  }\n\n  function updateHostText(current, workInProgress) {\n    if (current === null) {\n      tryToClaimNextHydratableInstance(workInProgress);\n    }\n    var nextProps = workInProgress.pendingProps;\n    memoizeProps(workInProgress, nextProps);\n    // Nothing to do here. This is terminal. We'll do the completion step\n    // immediately after.\n    return null;\n  }\n\n  function mountIndeterminateComponent(\n    current,\n    workInProgress,\n    renderExpirationTime\n  ) {\n    invariant(\n      current === null,\n      \"An indeterminate component should never have mounted. This error is \" +\n        \"likely caused by a bug in React. Please file an issue.\"\n    );\n    var fn = workInProgress.type;\n    var props = workInProgress.pendingProps;\n    var unmaskedContext = getUnmaskedContext(workInProgress);\n    var context = getMaskedContext(workInProgress, unmaskedContext);\n\n    var value = void 0;\n\n    {\n      if (fn.prototype && typeof fn.prototype.render === \"function\") {\n        var componentName = getComponentName(workInProgress) || \"Unknown\";\n\n        if (!didWarnAboutBadClass[componentName]) {\n          warning(\n            false,\n            \"The <%s /> component appears to have a render method, but doesn't extend React.Component. \" +\n              \"This is likely to cause errors. Change %s to extend React.Component instead.\",\n            componentName,\n            componentName\n          );\n          didWarnAboutBadClass[componentName] = true;\n        }\n      }\n      ReactCurrentOwner.current = workInProgress;\n      value = fn(props, context);\n    }\n    // React DevTools reads this flag.\n    workInProgress.effectTag |= PerformedWork;\n\n    if (\n      typeof value === \"object\" &&\n      value !== null &&\n      typeof value.render === \"function\" &&\n      value.$$typeof === undefined\n    ) {\n      var Component = workInProgress.type;\n\n      // Proceed under the assumption that this is a class instance\n      workInProgress.tag = ClassComponent;\n\n      workInProgress.memoizedState =\n        value.state !== null && value.state !== undefined ? value.state : null;\n\n      if (typeof Component.getDerivedStateFromProps === \"function\") {\n        var partialState = callGetDerivedStateFromProps(\n          workInProgress,\n          value,\n          props\n        );\n\n        if (partialState !== null && partialState !== undefined) {\n          workInProgress.memoizedState = Object.assign(\n            {},\n            workInProgress.memoizedState,\n            partialState\n          );\n        }\n      }\n\n      // Push context providers early to prevent context stack mismatches.\n      // During mounting we don't know the child context yet as the instance doesn't exist.\n      // We will invalidate the child context in finishClassComponent() right after rendering.\n      var hasContext = pushContextProvider(workInProgress);\n      adoptClassInstance(workInProgress, value);\n      mountClassInstance(workInProgress, renderExpirationTime);\n      return finishClassComponent(\n        current,\n        workInProgress,\n        true,\n        hasContext,\n        false,\n        renderExpirationTime\n      );\n    } else {\n      // Proceed under the assumption that this is a functional component\n      workInProgress.tag = FunctionalComponent;\n      {\n        var _Component = workInProgress.type;\n\n        if (_Component) {\n          warning(\n            !_Component.childContextTypes,\n            \"%s(...): childContextTypes cannot be defined on a functional component.\",\n            _Component.displayName || _Component.name || \"Component\"\n          );\n        }\n        if (workInProgress.ref !== null) {\n          var info = \"\";\n          var ownerName = ReactDebugCurrentFiber.getCurrentFiberOwnerName();\n          if (ownerName) {\n            info += \"\\n\\nCheck the render method of `\" + ownerName + \"`.\";\n          }\n\n          var warningKey = ownerName || workInProgress._debugID || \"\";\n          var debugSource = workInProgress._debugSource;\n          if (debugSource) {\n            warningKey = debugSource.fileName + \":\" + debugSource.lineNumber;\n          }\n          if (!didWarnAboutStatelessRefs[warningKey]) {\n            didWarnAboutStatelessRefs[warningKey] = true;\n            warning(\n              false,\n              \"Stateless function components cannot be given refs. \" +\n                \"Attempts to access this ref will fail.%s%s\",\n              info,\n              ReactDebugCurrentFiber.getCurrentFiberStackAddendum()\n            );\n          }\n        }\n\n        if (typeof fn.getDerivedStateFromProps === \"function\") {\n          var _componentName = getComponentName(workInProgress) || \"Unknown\";\n\n          if (\n            !didWarnAboutGetDerivedStateOnFunctionalComponent[_componentName]\n          ) {\n            warning(\n              false,\n              \"%s: Stateless functional components do not support getDerivedStateFromProps.\",\n              _componentName\n            );\n            didWarnAboutGetDerivedStateOnFunctionalComponent[\n              _componentName\n            ] = true;\n          }\n        }\n      }\n      reconcileChildren(current, workInProgress, value);\n      memoizeProps(workInProgress, props);\n      return workInProgress.child;\n    }\n  }\n\n  function updateCallComponent(current, workInProgress, renderExpirationTime) {\n    var nextProps = workInProgress.pendingProps;\n    if (hasContextChanged()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n    } else if (workInProgress.memoizedProps === nextProps) {\n      nextProps = workInProgress.memoizedProps;\n      // TODO: When bailing out, we might need to return the stateNode instead\n      // of the child. To check it for work.\n      // return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n\n    var nextChildren = nextProps.children;\n\n    // The following is a fork of reconcileChildrenAtExpirationTime but using\n    // stateNode to store the child.\n    if (current === null) {\n      workInProgress.stateNode = mountChildFibers(\n        workInProgress,\n        workInProgress.stateNode,\n        nextChildren,\n        renderExpirationTime\n      );\n    } else {\n      workInProgress.stateNode = reconcileChildFibers(\n        workInProgress,\n        current.stateNode,\n        nextChildren,\n        renderExpirationTime\n      );\n    }\n\n    memoizeProps(workInProgress, nextProps);\n    // This doesn't take arbitrary time so we could synchronously just begin\n    // eagerly do the work of workInProgress.child as an optimization.\n    return workInProgress.stateNode;\n  }\n\n  function updatePortalComponent(\n    current,\n    workInProgress,\n    renderExpirationTime\n  ) {\n    pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n    var nextChildren = workInProgress.pendingProps;\n    if (hasContextChanged()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n    } else if (workInProgress.memoizedProps === nextChildren) {\n      return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n\n    if (current === null) {\n      // Portals are special because we don't append the children during mount\n      // but at commit. Therefore we need to track insertions which the normal\n      // flow doesn't do during mount. This doesn't happen at the root because\n      // the root always starts with a \"current\" with a null child.\n      // TODO: Consider unifying this with how the root works.\n      workInProgress.child = reconcileChildFibers(\n        workInProgress,\n        null,\n        nextChildren,\n        renderExpirationTime\n      );\n      memoizeProps(workInProgress, nextChildren);\n    } else {\n      reconcileChildren(current, workInProgress, nextChildren);\n      memoizeProps(workInProgress, nextChildren);\n    }\n    return workInProgress.child;\n  }\n\n  function propagateContextChange(\n    workInProgress,\n    context,\n    changedBits,\n    renderExpirationTime\n  ) {\n    var fiber = workInProgress.child;\n    while (fiber !== null) {\n      var nextFiber = void 0;\n      // Visit this fiber.\n      switch (fiber.tag) {\n        case ContextConsumer:\n          // Check if the context matches.\n          var observedBits = fiber.stateNode | 0;\n          if (fiber.type === context && (observedBits & changedBits) !== 0) {\n            // Update the expiration time of all the ancestors, including\n            // the alternates.\n            var node = fiber;\n            while (node !== null) {\n              var alternate = node.alternate;\n              if (\n                node.expirationTime === NoWork ||\n                node.expirationTime > renderExpirationTime\n              ) {\n                node.expirationTime = renderExpirationTime;\n                if (\n                  alternate !== null &&\n                  (alternate.expirationTime === NoWork ||\n                    alternate.expirationTime > renderExpirationTime)\n                ) {\n                  alternate.expirationTime = renderExpirationTime;\n                }\n              } else if (\n                alternate !== null &&\n                (alternate.expirationTime === NoWork ||\n                  alternate.expirationTime > renderExpirationTime)\n              ) {\n                alternate.expirationTime = renderExpirationTime;\n              } else {\n                // Neither alternate was updated, which means the rest of the\n                // ancestor path already has sufficient priority.\n                break;\n              }\n              node = node[\"return\"];\n            }\n            // Don't scan deeper than a matching consumer. When we render the\n            // consumer, we'll continue scanning from that point. This way the\n            // scanning work is time-sliced.\n            nextFiber = null;\n          } else {\n            // Traverse down.\n            nextFiber = fiber.child;\n          }\n          break;\n        case ContextProvider:\n          // Don't scan deeper if this is a matching provider\n          nextFiber = fiber.type === workInProgress.type ? null : fiber.child;\n          break;\n        default:\n          // Traverse down.\n          nextFiber = fiber.child;\n          break;\n      }\n      if (nextFiber !== null) {\n        // Set the return pointer of the child to the work-in-progress fiber.\n        nextFiber[\"return\"] = fiber;\n      } else {\n        // No child. Traverse to next sibling.\n        nextFiber = fiber;\n        while (nextFiber !== null) {\n          if (nextFiber === workInProgress) {\n            // We're back to the root of this subtree. Exit.\n            nextFiber = null;\n            break;\n          }\n          var sibling = nextFiber.sibling;\n          if (sibling !== null) {\n            nextFiber = sibling;\n            break;\n          }\n          // No more siblings. Traverse up.\n          nextFiber = nextFiber[\"return\"];\n        }\n      }\n      fiber = nextFiber;\n    }\n  }\n\n  function updateContextProvider(\n    current,\n    workInProgress,\n    renderExpirationTime\n  ) {\n    var providerType = workInProgress.type;\n    var context = providerType.context;\n\n    var newProps = workInProgress.pendingProps;\n    var oldProps = workInProgress.memoizedProps;\n\n    if (hasContextChanged()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n    } else if (oldProps === newProps) {\n      workInProgress.stateNode = 0;\n      pushProvider(workInProgress);\n      return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n\n    var newValue = newProps.value;\n    workInProgress.memoizedProps = newProps;\n\n    var changedBits = void 0;\n    if (oldProps === null) {\n      // Initial render\n      changedBits = MAX_SIGNED_31_BIT_INT;\n    } else {\n      if (oldProps.value === newProps.value) {\n        // No change. Bailout early if children are the same.\n        if (oldProps.children === newProps.children) {\n          workInProgress.stateNode = 0;\n          pushProvider(workInProgress);\n          return bailoutOnAlreadyFinishedWork(current, workInProgress);\n        }\n        changedBits = 0;\n      } else {\n        var oldValue = oldProps.value;\n        // Use Object.is to compare the new context value to the old value.\n        // Inlined Object.is polyfill.\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n        if (\n          (oldValue === newValue &&\n            (oldValue !== 0 || 1 / oldValue === 1 / newValue)) ||\n          (oldValue !== oldValue && newValue !== newValue) // eslint-disable-line no-self-compare\n        ) {\n          // No change. Bailout early if children are the same.\n          if (oldProps.children === newProps.children) {\n            workInProgress.stateNode = 0;\n            pushProvider(workInProgress);\n            return bailoutOnAlreadyFinishedWork(current, workInProgress);\n          }\n          changedBits = 0;\n        } else {\n          changedBits =\n            typeof context._calculateChangedBits === \"function\"\n              ? context._calculateChangedBits(oldValue, newValue)\n              : MAX_SIGNED_31_BIT_INT;\n          {\n            warning(\n              (changedBits & MAX_SIGNED_31_BIT_INT) === changedBits,\n              \"calculateChangedBits: Expected the return value to be a \" +\n                \"31-bit integer. Instead received: %s\",\n              changedBits\n            );\n          }\n          changedBits |= 0;\n\n          if (changedBits === 0) {\n            // No change. Bailout early if children are the same.\n            if (oldProps.children === newProps.children) {\n              workInProgress.stateNode = 0;\n              pushProvider(workInProgress);\n              return bailoutOnAlreadyFinishedWork(current, workInProgress);\n            }\n          } else {\n            propagateContextChange(\n              workInProgress,\n              context,\n              changedBits,\n              renderExpirationTime\n            );\n          }\n        }\n      }\n    }\n\n    workInProgress.stateNode = changedBits;\n    pushProvider(workInProgress);\n\n    var newChildren = newProps.children;\n    reconcileChildren(current, workInProgress, newChildren);\n    return workInProgress.child;\n  }\n\n  function updateContextConsumer(\n    current,\n    workInProgress,\n    renderExpirationTime\n  ) {\n    var context = workInProgress.type;\n    var newProps = workInProgress.pendingProps;\n    var oldProps = workInProgress.memoizedProps;\n\n    var newValue = context._currentValue;\n    var changedBits = context._changedBits;\n\n    if (hasContextChanged()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n    } else if (changedBits === 0 && oldProps === newProps) {\n      return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n    workInProgress.memoizedProps = newProps;\n\n    var observedBits = newProps.unstable_observedBits;\n    if (observedBits === undefined || observedBits === null) {\n      // Subscribe to all changes by default\n      observedBits = MAX_SIGNED_31_BIT_INT;\n    }\n    // Store the observedBits on the fiber's stateNode for quick access.\n    workInProgress.stateNode = observedBits;\n\n    if ((changedBits & observedBits) !== 0) {\n      // Context change propagation stops at matching consumers, for time-\n      // slicing. Continue the propagation here.\n      propagateContextChange(\n        workInProgress,\n        context,\n        changedBits,\n        renderExpirationTime\n      );\n    } else if (oldProps !== null && oldProps.children === newProps.children) {\n      // No change. Bailout early if children are the same.\n      return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n\n    var render = newProps.children;\n\n    {\n      warning(\n        typeof render === \"function\",\n        \"A context consumer was rendered with multiple children, or a child \" +\n          \"that isn't a function. A context consumer expects a single child \" +\n          \"that is a function. If you did pass a function, make sure there \" +\n          \"is no trailing or leading whitespace around it.\"\n      );\n    }\n\n    var newChildren = render(newValue);\n    reconcileChildren(current, workInProgress, newChildren);\n    return workInProgress.child;\n  }\n\n  /*\n  function reuseChildrenEffects(returnFiber : Fiber, firstChild : Fiber) {\n    let child = firstChild;\n    do {\n      // Ensure that the first and last effect of the parent corresponds\n      // to the children's first and last effect.\n      if (!returnFiber.firstEffect) {\n        returnFiber.firstEffect = child.firstEffect;\n      }\n      if (child.lastEffect) {\n        if (returnFiber.lastEffect) {\n          returnFiber.lastEffect.nextEffect = child.firstEffect;\n        }\n        returnFiber.lastEffect = child.lastEffect;\n      }\n    } while (child = child.sibling);\n  }\n  */\n\n  function bailoutOnAlreadyFinishedWork(current, workInProgress) {\n    cancelWorkTimer(workInProgress);\n\n    // TODO: We should ideally be able to bail out early if the children have no\n    // more work to do. However, since we don't have a separation of this\n    // Fiber's priority and its children yet - we don't know without doing lots\n    // of the same work we do anyway. Once we have that separation we can just\n    // bail out here if the children has no more work at this priority level.\n    // if (workInProgress.priorityOfChildren <= priorityLevel) {\n    //   // If there are side-effects in these children that have not yet been\n    //   // committed we need to ensure that they get properly transferred up.\n    //   if (current && current.child !== workInProgress.child) {\n    //     reuseChildrenEffects(workInProgress, child);\n    //   }\n    //   return null;\n    // }\n\n    cloneChildFibers(current, workInProgress);\n    return workInProgress.child;\n  }\n\n  function bailoutOnLowPriority(current, workInProgress) {\n    cancelWorkTimer(workInProgress);\n\n    // TODO: Handle HostComponent tags here as well and call pushHostContext()?\n    // See PR 8590 discussion for context\n    switch (workInProgress.tag) {\n      case HostRoot:\n        pushHostRootContext(workInProgress);\n        break;\n      case ClassComponent:\n        pushContextProvider(workInProgress);\n        break;\n      case HostPortal:\n        pushHostContainer(\n          workInProgress,\n          workInProgress.stateNode.containerInfo\n        );\n        break;\n      case ContextProvider:\n        pushProvider(workInProgress);\n        break;\n    }\n    // TODO: What if this is currently in progress?\n    // How can that happen? How is this not being cloned?\n    return null;\n  }\n\n  // TODO: Delete memoizeProps/State and move to reconcile/bailout instead\n  function memoizeProps(workInProgress, nextProps) {\n    workInProgress.memoizedProps = nextProps;\n  }\n\n  function memoizeState(workInProgress, nextState) {\n    workInProgress.memoizedState = nextState;\n    // Don't reset the updateQueue, in case there are pending updates. Resetting\n    // is handled by processUpdateQueue.\n  }\n\n  function beginWork(current, workInProgress, renderExpirationTime) {\n    if (\n      workInProgress.expirationTime === NoWork ||\n      workInProgress.expirationTime > renderExpirationTime\n    ) {\n      return bailoutOnLowPriority(current, workInProgress);\n    }\n\n    switch (workInProgress.tag) {\n      case IndeterminateComponent:\n        return mountIndeterminateComponent(\n          current,\n          workInProgress,\n          renderExpirationTime\n        );\n      case FunctionalComponent:\n        return updateFunctionalComponent(current, workInProgress);\n      case ClassComponent:\n        return updateClassComponent(\n          current,\n          workInProgress,\n          renderExpirationTime\n        );\n      case HostRoot:\n        return updateHostRoot(current, workInProgress, renderExpirationTime);\n      case HostComponent:\n        return updateHostComponent(\n          current,\n          workInProgress,\n          renderExpirationTime\n        );\n      case HostText:\n        return updateHostText(current, workInProgress);\n      case CallHandlerPhase:\n        // This is a restart. Reset the tag to the initial phase.\n        workInProgress.tag = CallComponent;\n      // Intentionally fall through since this is now the same.\n      case CallComponent:\n        return updateCallComponent(\n          current,\n          workInProgress,\n          renderExpirationTime\n        );\n      case ReturnComponent:\n        // A return component is just a placeholder, we can just run through the\n        // next one immediately.\n        return null;\n      case HostPortal:\n        return updatePortalComponent(\n          current,\n          workInProgress,\n          renderExpirationTime\n        );\n      case Fragment:\n        return updateFragment(current, workInProgress);\n      case Mode:\n        return updateMode(current, workInProgress);\n      case ContextProvider:\n        return updateContextProvider(\n          current,\n          workInProgress,\n          renderExpirationTime\n        );\n      case ContextConsumer:\n        return updateContextConsumer(\n          current,\n          workInProgress,\n          renderExpirationTime\n        );\n      default:\n        invariant(\n          false,\n          \"Unknown unit of work tag. This error is likely caused by a bug in \" +\n            \"React. Please file an issue.\"\n        );\n    }\n  }\n\n  return {\n    beginWork: beginWork\n  };\n};\n\nvar ReactFiberCompleteWork = function(config, hostContext, hydrationContext) {\n  var createInstance = config.createInstance,\n    createTextInstance = config.createTextInstance,\n    appendInitialChild = config.appendInitialChild,\n    finalizeInitialChildren = config.finalizeInitialChildren,\n    prepareUpdate = config.prepareUpdate,\n    mutation = config.mutation,\n    persistence = config.persistence;\n  var getRootHostContainer = hostContext.getRootHostContainer,\n    popHostContext = hostContext.popHostContext,\n    getHostContext = hostContext.getHostContext,\n    popHostContainer = hostContext.popHostContainer;\n  var prepareToHydrateHostInstance =\n      hydrationContext.prepareToHydrateHostInstance,\n    prepareToHydrateHostTextInstance =\n      hydrationContext.prepareToHydrateHostTextInstance,\n    popHydrationState = hydrationContext.popHydrationState;\n\n  function markUpdate(workInProgress) {\n    // Tag the fiber with an update effect. This turns a Placement into\n    // an UpdateAndPlacement.\n    workInProgress.effectTag |= Update;\n  }\n\n  function markRef(workInProgress) {\n    workInProgress.effectTag |= Ref;\n  }\n\n  function appendAllReturns(returns, workInProgress) {\n    var node = workInProgress.stateNode;\n    if (node) {\n      node[\"return\"] = workInProgress;\n    }\n    while (node !== null) {\n      if (\n        node.tag === HostComponent ||\n        node.tag === HostText ||\n        node.tag === HostPortal\n      ) {\n        invariant(false, \"A call cannot have host component children.\");\n      } else if (node.tag === ReturnComponent) {\n        returns.push(node.pendingProps.value);\n      } else if (node.child !== null) {\n        node.child[\"return\"] = node;\n        node = node.child;\n        continue;\n      }\n      while (node.sibling === null) {\n        if (node[\"return\"] === null || node[\"return\"] === workInProgress) {\n          return;\n        }\n        node = node[\"return\"];\n      }\n      node.sibling[\"return\"] = node[\"return\"];\n      node = node.sibling;\n    }\n  }\n\n  function moveCallToHandlerPhase(\n    current,\n    workInProgress,\n    renderExpirationTime\n  ) {\n    var props = workInProgress.memoizedProps;\n    invariant(\n      props,\n      \"Should be resolved by now. This error is likely caused by a bug in \" +\n        \"React. Please file an issue.\"\n    );\n\n    // First step of the call has completed. Now we need to do the second.\n    // TODO: It would be nice to have a multi stage call represented by a\n    // single component, or at least tail call optimize nested ones. Currently\n    // that requires additional fields that we don't want to add to the fiber.\n    // So this requires nested handlers.\n    // Note: This doesn't mutate the alternate node. I don't think it needs to\n    // since this stage is reset for every pass.\n    workInProgress.tag = CallHandlerPhase;\n\n    // Build up the returns.\n    // TODO: Compare this to a generator or opaque helpers like Children.\n    var returns = [];\n    appendAllReturns(returns, workInProgress);\n    var fn = props.handler;\n    var childProps = props.props;\n    var nextChildren = fn(childProps, returns);\n\n    var currentFirstChild = current !== null ? current.child : null;\n    workInProgress.child = reconcileChildFibers(\n      workInProgress,\n      currentFirstChild,\n      nextChildren,\n      renderExpirationTime\n    );\n    return workInProgress.child;\n  }\n\n  function appendAllChildren(parent, workInProgress) {\n    // We only have the top Fiber that was created but we need recurse down its\n    // children to find all the terminal nodes.\n    var node = workInProgress.child;\n    while (node !== null) {\n      if (node.tag === HostComponent || node.tag === HostText) {\n        appendInitialChild(parent, node.stateNode);\n      } else if (node.tag === HostPortal) {\n        // If we have a portal child, then we don't want to traverse\n        // down its children. Instead, we'll get insertions from each child in\n        // the portal directly.\n      } else if (node.child !== null) {\n        node.child[\"return\"] = node;\n        node = node.child;\n        continue;\n      }\n      if (node === workInProgress) {\n        return;\n      }\n      while (node.sibling === null) {\n        if (node[\"return\"] === null || node[\"return\"] === workInProgress) {\n          return;\n        }\n        node = node[\"return\"];\n      }\n      node.sibling[\"return\"] = node[\"return\"];\n      node = node.sibling;\n    }\n  }\n\n  var updateHostContainer = void 0;\n  var updateHostComponent = void 0;\n  var updateHostText = void 0;\n  if (mutation) {\n    if (enableMutatingReconciler) {\n      // Mutation mode\n      updateHostContainer = function(workInProgress) {\n        // Noop\n      };\n      updateHostComponent = function(\n        current,\n        workInProgress,\n        updatePayload,\n        type,\n        oldProps,\n        newProps,\n        rootContainerInstance,\n        currentHostContext\n      ) {\n        // TODO: Type this specific to this type of component.\n        workInProgress.updateQueue = updatePayload;\n        // If the update payload indicates that there is a change or if there\n        // is a new ref we mark this as an update. All the work is done in commitWork.\n        if (updatePayload) {\n          markUpdate(workInProgress);\n        }\n      };\n      updateHostText = function(current, workInProgress, oldText, newText) {\n        // If the text differs, mark it as an update. All the work in done in commitWork.\n        if (oldText !== newText) {\n          markUpdate(workInProgress);\n        }\n      };\n    } else {\n      invariant(false, \"Mutating reconciler is disabled.\");\n    }\n  } else if (persistence) {\n    if (enablePersistentReconciler) {\n      // Persistent host tree mode\n      var cloneInstance = persistence.cloneInstance,\n        createContainerChildSet = persistence.createContainerChildSet,\n        appendChildToContainerChildSet =\n          persistence.appendChildToContainerChildSet,\n        finalizeContainerChildren = persistence.finalizeContainerChildren;\n\n      // An unfortunate fork of appendAllChildren because we have two different parent types.\n\n      var appendAllChildrenToContainer = function(\n        containerChildSet,\n        workInProgress\n      ) {\n        // We only have the top Fiber that was created but we need recurse down its\n        // children to find all the terminal nodes.\n        var node = workInProgress.child;\n        while (node !== null) {\n          if (node.tag === HostComponent || node.tag === HostText) {\n            appendChildToContainerChildSet(containerChildSet, node.stateNode);\n          } else if (node.tag === HostPortal) {\n            // If we have a portal child, then we don't want to traverse\n            // down its children. Instead, we'll get insertions from each child in\n            // the portal directly.\n          } else if (node.child !== null) {\n            node.child[\"return\"] = node;\n            node = node.child;\n            continue;\n          }\n          if (node === workInProgress) {\n            return;\n          }\n          while (node.sibling === null) {\n            if (node[\"return\"] === null || node[\"return\"] === workInProgress) {\n              return;\n            }\n            node = node[\"return\"];\n          }\n          node.sibling[\"return\"] = node[\"return\"];\n          node = node.sibling;\n        }\n      };\n      updateHostContainer = function(workInProgress) {\n        var portalOrRoot = workInProgress.stateNode;\n        var childrenUnchanged = workInProgress.firstEffect === null;\n        if (childrenUnchanged) {\n          // No changes, just reuse the existing instance.\n        } else {\n          var container = portalOrRoot.containerInfo;\n          var newChildSet = createContainerChildSet(container);\n          // If children might have changed, we have to add them all to the set.\n          appendAllChildrenToContainer(newChildSet, workInProgress);\n          portalOrRoot.pendingChildren = newChildSet;\n          // Schedule an update on the container to swap out the container.\n          markUpdate(workInProgress);\n          finalizeContainerChildren(container, newChildSet);\n        }\n      };\n      updateHostComponent = function(\n        current,\n        workInProgress,\n        updatePayload,\n        type,\n        oldProps,\n        newProps,\n        rootContainerInstance,\n        currentHostContext\n      ) {\n        // If there are no effects associated with this node, then none of our children had any updates.\n        // This guarantees that we can reuse all of them.\n        var childrenUnchanged = workInProgress.firstEffect === null;\n        var currentInstance = current.stateNode;\n        if (childrenUnchanged && updatePayload === null) {\n          // No changes, just reuse the existing instance.\n          // Note that this might release a previous clone.\n          workInProgress.stateNode = currentInstance;\n        } else {\n          var recyclableInstance = workInProgress.stateNode;\n          var newInstance = cloneInstance(\n            currentInstance,\n            updatePayload,\n            type,\n            oldProps,\n            newProps,\n            workInProgress,\n            childrenUnchanged,\n            recyclableInstance\n          );\n          if (\n            finalizeInitialChildren(\n              newInstance,\n              type,\n              newProps,\n              rootContainerInstance,\n              currentHostContext\n            )\n          ) {\n            markUpdate(workInProgress);\n          }\n          workInProgress.stateNode = newInstance;\n          if (childrenUnchanged) {\n            // If there are no other effects in this tree, we need to flag this node as having one.\n            // Even though we're not going to use it for anything.\n            // Otherwise parents won't know that there are new children to propagate upwards.\n            markUpdate(workInProgress);\n          } else {\n            // If children might have changed, we have to add them all to the set.\n            appendAllChildren(newInstance, workInProgress);\n          }\n        }\n      };\n      updateHostText = function(current, workInProgress, oldText, newText) {\n        if (oldText !== newText) {\n          // If the text content differs, we'll create a new text instance for it.\n          var rootContainerInstance = getRootHostContainer();\n          var currentHostContext = getHostContext();\n          workInProgress.stateNode = createTextInstance(\n            newText,\n            rootContainerInstance,\n            currentHostContext,\n            workInProgress\n          );\n          // We'll have to mark it as having an effect, even though we won't use the effect for anything.\n          // This lets the parents know that at least one of their children has changed.\n          markUpdate(workInProgress);\n        }\n      };\n    } else {\n      invariant(false, \"Persistent reconciler is disabled.\");\n    }\n  } else {\n    if (enableNoopReconciler) {\n      // No host operations\n      updateHostContainer = function(workInProgress) {\n        // Noop\n      };\n      updateHostComponent = function(\n        current,\n        workInProgress,\n        updatePayload,\n        type,\n        oldProps,\n        newProps,\n        rootContainerInstance,\n        currentHostContext\n      ) {\n        // Noop\n      };\n      updateHostText = function(current, workInProgress, oldText, newText) {\n        // Noop\n      };\n    } else {\n      invariant(false, \"Noop reconciler is disabled.\");\n    }\n  }\n\n  function completeWork(current, workInProgress, renderExpirationTime) {\n    var newProps = workInProgress.pendingProps;\n    switch (workInProgress.tag) {\n      case FunctionalComponent:\n        return null;\n      case ClassComponent: {\n        // We are leaving this subtree, so pop context if any.\n        popContextProvider(workInProgress);\n\n        // If this component caught an error, schedule an error log effect.\n        var instance = workInProgress.stateNode;\n        var updateQueue = workInProgress.updateQueue;\n        if (updateQueue !== null && updateQueue.capturedValues !== null) {\n          workInProgress.effectTag &= ~DidCapture;\n          if (typeof instance.componentDidCatch === \"function\") {\n            workInProgress.effectTag |= ErrLog;\n          } else {\n            // Normally we clear this in the commit phase, but since we did not\n            // schedule an effect, we need to reset it here.\n            updateQueue.capturedValues = null;\n          }\n        }\n        return null;\n      }\n      case HostRoot: {\n        popHostContainer(workInProgress);\n        popTopLevelContextObject(workInProgress);\n        var fiberRoot = workInProgress.stateNode;\n        if (fiberRoot.pendingContext) {\n          fiberRoot.context = fiberRoot.pendingContext;\n          fiberRoot.pendingContext = null;\n        }\n        if (current === null || current.child === null) {\n          // If we hydrated, pop so that we can delete any remaining children\n          // that weren't hydrated.\n          popHydrationState(workInProgress);\n          // This resets the hacky state to fix isMounted before committing.\n          // TODO: Delete this when we delete isMounted and findDOMNode.\n          workInProgress.effectTag &= ~Placement;\n        }\n        updateHostContainer(workInProgress);\n\n        var _updateQueue = workInProgress.updateQueue;\n        if (_updateQueue !== null && _updateQueue.capturedValues !== null) {\n          workInProgress.effectTag |= ErrLog;\n        }\n        return null;\n      }\n      case HostComponent: {\n        popHostContext(workInProgress);\n        var rootContainerInstance = getRootHostContainer();\n        var type = workInProgress.type;\n        if (current !== null && workInProgress.stateNode != null) {\n          // If we have an alternate, that means this is an update and we need to\n          // schedule a side-effect to do the updates.\n          var oldProps = current.memoizedProps;\n          // If we get updated because one of our children updated, we don't\n          // have newProps so we'll have to reuse them.\n          // TODO: Split the update API as separate for the props vs. children.\n          // Even better would be if children weren't special cased at all tho.\n          var _instance = workInProgress.stateNode;\n          var currentHostContext = getHostContext();\n          // TODO: Experiencing an error where oldProps is null. Suggests a host\n          // component is hitting the resume path. Figure out why. Possibly\n          // related to `hidden`.\n          var updatePayload = prepareUpdate(\n            _instance,\n            type,\n            oldProps,\n            newProps,\n            rootContainerInstance,\n            currentHostContext\n          );\n\n          updateHostComponent(\n            current,\n            workInProgress,\n            updatePayload,\n            type,\n            oldProps,\n            newProps,\n            rootContainerInstance,\n            currentHostContext\n          );\n\n          if (current.ref !== workInProgress.ref) {\n            markRef(workInProgress);\n          }\n        } else {\n          if (!newProps) {\n            invariant(\n              workInProgress.stateNode !== null,\n              \"We must have new props for new mounts. This error is likely \" +\n                \"caused by a bug in React. Please file an issue.\"\n            );\n            // This can happen when we abort work.\n            return null;\n          }\n\n          var _currentHostContext = getHostContext();\n          // TODO: Move createInstance to beginWork and keep it on a context\n          // \"stack\" as the parent. Then append children as we go in beginWork\n          // or completeWork depending on we want to add then top->down or\n          // bottom->up. Top->down is faster in IE11.\n          var wasHydrated = popHydrationState(workInProgress);\n          if (wasHydrated) {\n            // TODO: Move this and createInstance step into the beginPhase\n            // to consolidate.\n            if (\n              prepareToHydrateHostInstance(\n                workInProgress,\n                rootContainerInstance,\n                _currentHostContext\n              )\n            ) {\n              // If changes to the hydrated node needs to be applied at the\n              // commit-phase we mark this as such.\n              markUpdate(workInProgress);\n            }\n          } else {\n            var _instance2 = createInstance(\n              type,\n              newProps,\n              rootContainerInstance,\n              _currentHostContext,\n              workInProgress\n            );\n\n            appendAllChildren(_instance2, workInProgress);\n\n            // Certain renderers require commit-time effects for initial mount.\n            // (eg DOM renderer supports auto-focus for certain elements).\n            // Make sure such renderers get scheduled for later work.\n            if (\n              finalizeInitialChildren(\n                _instance2,\n                type,\n                newProps,\n                rootContainerInstance,\n                _currentHostContext\n              )\n            ) {\n              markUpdate(workInProgress);\n            }\n            workInProgress.stateNode = _instance2;\n          }\n\n          if (workInProgress.ref !== null) {\n            // If there is a ref on a host node we need to schedule a callback\n            markRef(workInProgress);\n          }\n        }\n        return null;\n      }\n      case HostText: {\n        var newText = newProps;\n        if (current && workInProgress.stateNode != null) {\n          var oldText = current.memoizedProps;\n          // If we have an alternate, that means this is an update and we need\n          // to schedule a side-effect to do the updates.\n          updateHostText(current, workInProgress, oldText, newText);\n        } else {\n          if (typeof newText !== \"string\") {\n            invariant(\n              workInProgress.stateNode !== null,\n              \"We must have new props for new mounts. This error is likely \" +\n                \"caused by a bug in React. Please file an issue.\"\n            );\n            // This can happen when we abort work.\n            return null;\n          }\n          var _rootContainerInstance = getRootHostContainer();\n          var _currentHostContext2 = getHostContext();\n          var _wasHydrated = popHydrationState(workInProgress);\n          if (_wasHydrated) {\n            if (prepareToHydrateHostTextInstance(workInProgress)) {\n              markUpdate(workInProgress);\n            }\n          } else {\n            workInProgress.stateNode = createTextInstance(\n              newText,\n              _rootContainerInstance,\n              _currentHostContext2,\n              workInProgress\n            );\n          }\n        }\n        return null;\n      }\n      case CallComponent:\n        return moveCallToHandlerPhase(\n          current,\n          workInProgress,\n          renderExpirationTime\n        );\n      case CallHandlerPhase:\n        // Reset the tag to now be a first phase call.\n        workInProgress.tag = CallComponent;\n        return null;\n      case ReturnComponent:\n        // Does nothing.\n        return null;\n      case Fragment:\n        return null;\n      case Mode:\n        return null;\n      case HostPortal:\n        popHostContainer(workInProgress);\n        updateHostContainer(workInProgress);\n        return null;\n      case ContextProvider:\n        // Pop provider fiber\n        popProvider(workInProgress);\n        return null;\n      case ContextConsumer:\n        return null;\n      // Error cases\n      case IndeterminateComponent:\n        invariant(\n          false,\n          \"An indeterminate component should have become determinate before \" +\n            \"completing. This error is likely caused by a bug in React. Please \" +\n            \"file an issue.\"\n        );\n      // eslint-disable-next-line no-fallthrough\n      default:\n        invariant(\n          false,\n          \"Unknown unit of work tag. This error is likely caused by a bug in \" +\n            \"React. Please file an issue.\"\n        );\n    }\n  }\n\n  return {\n    completeWork: completeWork\n  };\n};\n\nfunction createCapturedValue(value, source) {\n  // If the value is an error, call this function immediately after it is thrown\n  // so the stack is accurate.\n  return {\n    value: value,\n    source: source,\n    stack: getStackAddendumByWorkInProgressFiber(source)\n  };\n}\n\nvar ReactFiberUnwindWork = function(\n  hostContext,\n  scheduleWork,\n  isAlreadyFailedLegacyErrorBoundary\n) {\n  var popHostContainer = hostContext.popHostContainer,\n    popHostContext = hostContext.popHostContext;\n\n  function throwException(returnFiber, sourceFiber, rawValue) {\n    // The source fiber did not complete.\n    sourceFiber.effectTag |= Incomplete;\n    // Its effect list is no longer valid.\n    sourceFiber.firstEffect = sourceFiber.lastEffect = null;\n\n    var value = createCapturedValue(rawValue, sourceFiber);\n\n    var workInProgress = returnFiber;\n    do {\n      switch (workInProgress.tag) {\n        case HostRoot: {\n          // Uncaught error\n          var errorInfo = value;\n          ensureUpdateQueues(workInProgress);\n          var updateQueue = workInProgress.updateQueue;\n          updateQueue.capturedValues = [errorInfo];\n          workInProgress.effectTag |= ShouldCapture;\n          return;\n        }\n        case ClassComponent:\n          // Capture and retry\n          var ctor = workInProgress.type;\n          var _instance = workInProgress.stateNode;\n          if (\n            (workInProgress.effectTag & DidCapture) === NoEffect &&\n            ((typeof ctor.getDerivedStateFromCatch === \"function\" &&\n              enableGetDerivedStateFromCatch) ||\n              (_instance !== null &&\n                typeof _instance.componentDidCatch === \"function\" &&\n                !isAlreadyFailedLegacyErrorBoundary(_instance)))\n          ) {\n            ensureUpdateQueues(workInProgress);\n            var _updateQueue = workInProgress.updateQueue;\n            var capturedValues = _updateQueue.capturedValues;\n            if (capturedValues === null) {\n              _updateQueue.capturedValues = [value];\n            } else {\n              capturedValues.push(value);\n            }\n            workInProgress.effectTag |= ShouldCapture;\n            return;\n          }\n          break;\n        default:\n          break;\n      }\n      workInProgress = workInProgress[\"return\"];\n    } while (workInProgress !== null);\n  }\n\n  function unwindWork(workInProgress) {\n    switch (workInProgress.tag) {\n      case ClassComponent: {\n        popContextProvider(workInProgress);\n        var effectTag = workInProgress.effectTag;\n        if (effectTag & ShouldCapture) {\n          workInProgress.effectTag = (effectTag & ~ShouldCapture) | DidCapture;\n          return workInProgress;\n        }\n        return null;\n      }\n      case HostRoot: {\n        popHostContainer(workInProgress);\n        popTopLevelContextObject(workInProgress);\n        var _effectTag = workInProgress.effectTag;\n        if (_effectTag & ShouldCapture) {\n          workInProgress.effectTag = (_effectTag & ~ShouldCapture) | DidCapture;\n          return workInProgress;\n        }\n        return null;\n      }\n      case HostComponent: {\n        popHostContext(workInProgress);\n        return null;\n      }\n      case HostPortal:\n        popHostContainer(workInProgress);\n        return null;\n      case ContextProvider:\n        popProvider(workInProgress);\n        return null;\n      default:\n        return null;\n    }\n  }\n  return {\n    throwException: throwException,\n    unwindWork: unwindWork\n  };\n};\n\n// Module provided by RN:\n/**\n * Intercept lifecycle errors and ensure they are shown with the correct stack\n * trace within the native redbox component.\n */\nfunction showErrorDialog(capturedError) {\n  var componentStack = capturedError.componentStack,\n    error = capturedError.error;\n\n  var errorToHandle = void 0;\n\n  // Typically Errors are thrown but eg strings or null can be thrown as well.\n  if (error instanceof Error) {\n    var message = error.message,\n      name = error.name;\n\n    var summary = message ? name + \": \" + message : name;\n\n    errorToHandle = error;\n\n    try {\n      errorToHandle.message =\n        summary + \"\\n\\nThis error is located at:\" + componentStack;\n    } catch (e) {}\n  } else if (typeof error === \"string\") {\n    errorToHandle = new Error(\n      error + \"\\n\\nThis error is located at:\" + componentStack\n    );\n  } else {\n    errorToHandle = new Error(\"Unspecified error at:\" + componentStack);\n  }\n\n  ExceptionsManager.handleException(errorToHandle, false);\n\n  // Return false here to prevent ReactFiberErrorLogger default behavior of\n  // logging error details to console.error. Calls to console.error are\n  // automatically routed to the native redbox controller, which we've already\n  // done above by calling ExceptionsManager.\n  return false;\n}\n\nfunction logCapturedError(capturedError) {\n  var logError = showErrorDialog(capturedError);\n\n  // Allow injected showErrorDialog() to prevent default console.error logging.\n  // This enables renderers like ReactNative to better manage redbox behavior.\n  if (logError === false) {\n    return;\n  }\n\n  var error = capturedError.error;\n  var suppressLogging = error && error.suppressReactErrorLogging;\n  if (suppressLogging) {\n    return;\n  }\n\n  {\n    var componentName = capturedError.componentName,\n      componentStack = capturedError.componentStack,\n      errorBoundaryName = capturedError.errorBoundaryName,\n      errorBoundaryFound = capturedError.errorBoundaryFound,\n      willRetry = capturedError.willRetry;\n\n    var componentNameMessage = componentName\n      ? \"The above error occurred in the <\" + componentName + \"> component:\"\n      : \"The above error occurred in one of your React components:\";\n\n    var errorBoundaryMessage = void 0;\n    // errorBoundaryFound check is sufficient; errorBoundaryName check is to satisfy Flow.\n    if (errorBoundaryFound && errorBoundaryName) {\n      if (willRetry) {\n        errorBoundaryMessage =\n          \"React will try to recreate this component tree from scratch \" +\n          (\"using the error boundary you provided, \" + errorBoundaryName + \".\");\n      } else {\n        errorBoundaryMessage =\n          \"This error was initially handled by the error boundary \" +\n          errorBoundaryName +\n          \".\\n\" +\n          \"Recreating the tree from scratch failed so React will unmount the tree.\";\n      }\n    } else {\n      errorBoundaryMessage =\n        \"Consider adding an error boundary to your tree to customize error handling behavior.\\n\" +\n        \"Visit https://fb.me/react-error-boundaries to learn more about error boundaries.\";\n    }\n    var combinedMessage =\n      \"\" +\n      componentNameMessage +\n      componentStack +\n      \"\\n\\n\" +\n      (\"\" + errorBoundaryMessage);\n\n    // In development, we provide our own message with just the component stack.\n    // We don't include the original error message and JS stack because the browser\n    // has already printed it. Even if the application swallows the error, it is still\n    // displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.\n    console.error(combinedMessage);\n  }\n}\n\nvar invokeGuardedCallback$3 = ReactErrorUtils.invokeGuardedCallback;\nvar hasCaughtError$1 = ReactErrorUtils.hasCaughtError;\nvar clearCaughtError$1 = ReactErrorUtils.clearCaughtError;\n\nfunction logError(boundary, errorInfo) {\n  var source = errorInfo.source;\n  var stack = errorInfo.stack;\n  if (stack === null) {\n    stack = getStackAddendumByWorkInProgressFiber(source);\n  }\n\n  var capturedError = {\n    componentName: source !== null ? getComponentName(source) : null,\n    error: errorInfo.value,\n    errorBoundary: boundary,\n    componentStack: stack !== null ? stack : \"\",\n    errorBoundaryName: null,\n    errorBoundaryFound: false,\n    willRetry: false\n  };\n\n  if (boundary !== null) {\n    capturedError.errorBoundaryName = getComponentName(boundary);\n    capturedError.errorBoundaryFound = capturedError.willRetry =\n      boundary.tag === ClassComponent;\n  } else {\n    capturedError.errorBoundaryName = null;\n    capturedError.errorBoundaryFound = capturedError.willRetry = false;\n  }\n\n  try {\n    logCapturedError(capturedError);\n  } catch (e) {\n    // Prevent cycle if logCapturedError() throws.\n    // A cycle may still occur if logCapturedError renders a component that throws.\n    var suppressLogging = e && e.suppressReactErrorLogging;\n    if (!suppressLogging) {\n      console.error(e);\n    }\n  }\n}\n\nvar ReactFiberCommitWork = function(\n  config,\n  captureError,\n  scheduleWork,\n  computeExpirationForFiber,\n  markLegacyErrorBoundaryAsFailed,\n  recalculateCurrentTime\n) {\n  var getPublicInstance = config.getPublicInstance,\n    mutation = config.mutation,\n    persistence = config.persistence;\n\n  var callComponentWillUnmountWithTimer = function(current, instance) {\n    startPhaseTimer(current, \"componentWillUnmount\");\n    instance.props = current.memoizedProps;\n    instance.state = current.memoizedState;\n    instance.componentWillUnmount();\n    stopPhaseTimer();\n  };\n\n  // Capture errors so they don't interrupt unmounting.\n  function safelyCallComponentWillUnmount(current, instance) {\n    {\n      invokeGuardedCallback$3(\n        null,\n        callComponentWillUnmountWithTimer,\n        null,\n        current,\n        instance\n      );\n      if (hasCaughtError$1()) {\n        var unmountError = clearCaughtError$1();\n        captureError(current, unmountError);\n      }\n    }\n  }\n\n  function safelyDetachRef(current) {\n    var ref = current.ref;\n    if (ref !== null) {\n      if (typeof ref === \"function\") {\n        {\n          invokeGuardedCallback$3(null, ref, null, null);\n          if (hasCaughtError$1()) {\n            var refError = clearCaughtError$1();\n            captureError(current, refError);\n          }\n        }\n      } else {\n        ref.value = null;\n      }\n    }\n  }\n\n  function commitLifeCycles(\n    finishedRoot,\n    current,\n    finishedWork,\n    currentTime,\n    committedExpirationTime\n  ) {\n    switch (finishedWork.tag) {\n      case ClassComponent: {\n        var _instance = finishedWork.stateNode;\n        if (finishedWork.effectTag & Update) {\n          if (current === null) {\n            startPhaseTimer(finishedWork, \"componentDidMount\");\n            _instance.props = finishedWork.memoizedProps;\n            _instance.state = finishedWork.memoizedState;\n            _instance.componentDidMount();\n            stopPhaseTimer();\n          } else {\n            var prevProps = current.memoizedProps;\n            var prevState = current.memoizedState;\n            startPhaseTimer(finishedWork, \"componentDidUpdate\");\n            _instance.props = finishedWork.memoizedProps;\n            _instance.state = finishedWork.memoizedState;\n            _instance.componentDidUpdate(prevProps, prevState);\n            stopPhaseTimer();\n          }\n        }\n        var updateQueue = finishedWork.updateQueue;\n        if (updateQueue !== null) {\n          commitCallbacks(updateQueue, _instance);\n        }\n        return;\n      }\n      case HostRoot: {\n        var _updateQueue = finishedWork.updateQueue;\n        if (_updateQueue !== null) {\n          var _instance2 = null;\n          if (finishedWork.child !== null) {\n            switch (finishedWork.child.tag) {\n              case HostComponent:\n                _instance2 = getPublicInstance(finishedWork.child.stateNode);\n                break;\n              case ClassComponent:\n                _instance2 = finishedWork.child.stateNode;\n                break;\n            }\n          }\n          commitCallbacks(_updateQueue, _instance2);\n        }\n        return;\n      }\n      case HostComponent: {\n        var _instance3 = finishedWork.stateNode;\n\n        // Renderers may schedule work to be done after host components are mounted\n        // (eg DOM renderer may schedule auto-focus for inputs and form controls).\n        // These effects should only be committed when components are first mounted,\n        // aka when there is no current/alternate.\n        if (current === null && finishedWork.effectTag & Update) {\n          var type = finishedWork.type;\n          var props = finishedWork.memoizedProps;\n          commitMount(_instance3, type, props, finishedWork);\n        }\n\n        return;\n      }\n      case HostText: {\n        // We have no life-cycles associated with text.\n        return;\n      }\n      case HostPortal: {\n        // We have no life-cycles associated with portals.\n        return;\n      }\n      default: {\n        invariant(\n          false,\n          \"This unit of work tag should not have side-effects. This error is \" +\n            \"likely caused by a bug in React. Please file an issue.\"\n        );\n      }\n    }\n  }\n\n  function commitErrorLogging(finishedWork, onUncaughtError) {\n    switch (finishedWork.tag) {\n      case ClassComponent:\n        {\n          var ctor = finishedWork.type;\n          var _instance4 = finishedWork.stateNode;\n          var updateQueue = finishedWork.updateQueue;\n          invariant(\n            updateQueue !== null && updateQueue.capturedValues !== null,\n            \"An error logging effect should not have been scheduled if no errors \" +\n              \"were captured. This error is likely caused by a bug in React. \" +\n              \"Please file an issue.\"\n          );\n          var capturedErrors = updateQueue.capturedValues;\n          updateQueue.capturedValues = null;\n\n          if (typeof ctor.getDerivedStateFromCatch !== \"function\") {\n            // To preserve the preexisting retry behavior of error boundaries,\n            // we keep track of which ones already failed during this batch.\n            // This gets reset before we yield back to the browser.\n            // TODO: Warn in strict mode if getDerivedStateFromCatch is\n            // not defined.\n            markLegacyErrorBoundaryAsFailed(_instance4);\n          }\n\n          _instance4.props = finishedWork.memoizedProps;\n          _instance4.state = finishedWork.memoizedState;\n          for (var i = 0; i < capturedErrors.length; i++) {\n            var errorInfo = capturedErrors[i];\n            var _error = errorInfo.value;\n            logError(finishedWork, errorInfo);\n            _instance4.componentDidCatch(_error);\n          }\n        }\n        break;\n      case HostRoot: {\n        var _updateQueue2 = finishedWork.updateQueue;\n        invariant(\n          _updateQueue2 !== null && _updateQueue2.capturedValues !== null,\n          \"An error logging effect should not have been scheduled if no errors \" +\n            \"were captured. This error is likely caused by a bug in React. \" +\n            \"Please file an issue.\"\n        );\n        var _capturedErrors = _updateQueue2.capturedValues;\n        _updateQueue2.capturedValues = null;\n        for (var _i = 0; _i < _capturedErrors.length; _i++) {\n          var _errorInfo = _capturedErrors[_i];\n          logError(finishedWork, _errorInfo);\n          onUncaughtError(_errorInfo.value);\n        }\n        break;\n      }\n      default:\n        invariant(\n          false,\n          \"This unit of work tag cannot capture errors.  This error is \" +\n            \"likely caused by a bug in React. Please file an issue.\"\n        );\n    }\n  }\n\n  function commitAttachRef(finishedWork) {\n    var ref = finishedWork.ref;\n    if (ref !== null) {\n      var _instance5 = finishedWork.stateNode;\n      var instanceToUse = void 0;\n      switch (finishedWork.tag) {\n        case HostComponent:\n          instanceToUse = getPublicInstance(_instance5);\n          break;\n        default:\n          instanceToUse = _instance5;\n      }\n      if (typeof ref === \"function\") {\n        ref(instanceToUse);\n      } else {\n        ref.value = instanceToUse;\n      }\n    }\n  }\n\n  function commitDetachRef(current) {\n    var currentRef = current.ref;\n    if (currentRef !== null) {\n      if (typeof currentRef === \"function\") {\n        currentRef(null);\n      } else {\n        currentRef.value = null;\n      }\n    }\n  }\n\n  // User-originating errors (lifecycles and refs) should not interrupt\n  // deletion, so don't let them throw. Host-originating errors should\n  // interrupt deletion, so it's okay\n  function commitUnmount(current) {\n    if (typeof onCommitUnmount === \"function\") {\n      onCommitUnmount(current);\n    }\n\n    switch (current.tag) {\n      case ClassComponent: {\n        safelyDetachRef(current);\n        var _instance6 = current.stateNode;\n        if (typeof _instance6.componentWillUnmount === \"function\") {\n          safelyCallComponentWillUnmount(current, _instance6);\n        }\n        return;\n      }\n      case HostComponent: {\n        safelyDetachRef(current);\n        return;\n      }\n      case CallComponent: {\n        commitNestedUnmounts(current.stateNode);\n        return;\n      }\n      case HostPortal: {\n        // TODO: this is recursive.\n        // We are also not using this parent because\n        // the portal will get pushed immediately.\n        if (enableMutatingReconciler && mutation) {\n          unmountHostComponents(current);\n        } else if (enablePersistentReconciler && persistence) {\n          emptyPortalContainer(current);\n        }\n        return;\n      }\n    }\n  }\n\n  function commitNestedUnmounts(root) {\n    // While we're inside a removed host node we don't want to call\n    // removeChild on the inner nodes because they're removed by the top\n    // call anyway. We also want to call componentWillUnmount on all\n    // composites before this host node is removed from the tree. Therefore\n    var node = root;\n    while (true) {\n      commitUnmount(node);\n      // Visit children because they may contain more composite or host nodes.\n      // Skip portals because commitUnmount() currently visits them recursively.\n      if (\n        node.child !== null &&\n        // If we use mutation we drill down into portals using commitUnmount above.\n        // If we don't use mutation we drill down into portals here instead.\n        (!mutation || node.tag !== HostPortal)\n      ) {\n        node.child[\"return\"] = node;\n        node = node.child;\n        continue;\n      }\n      if (node === root) {\n        return;\n      }\n      while (node.sibling === null) {\n        if (node[\"return\"] === null || node[\"return\"] === root) {\n          return;\n        }\n        node = node[\"return\"];\n      }\n      node.sibling[\"return\"] = node[\"return\"];\n      node = node.sibling;\n    }\n  }\n\n  function detachFiber(current) {\n    // Cut off the return pointers to disconnect it from the tree. Ideally, we\n    // should clear the child pointer of the parent alternate to let this\n    // get GC:ed but we don't know which for sure which parent is the current\n    // one so we'll settle for GC:ing the subtree of this child. This child\n    // itself will be GC:ed when the parent updates the next time.\n    current[\"return\"] = null;\n    current.child = null;\n    if (current.alternate) {\n      current.alternate.child = null;\n      current.alternate[\"return\"] = null;\n    }\n  }\n\n  var emptyPortalContainer = void 0;\n\n  if (!mutation) {\n    var commitContainer = void 0;\n    if (persistence) {\n      var replaceContainerChildren = persistence.replaceContainerChildren,\n        createContainerChildSet = persistence.createContainerChildSet;\n\n      emptyPortalContainer = function(current) {\n        var portal = current.stateNode;\n        var containerInfo = portal.containerInfo;\n\n        var emptyChildSet = createContainerChildSet(containerInfo);\n        replaceContainerChildren(containerInfo, emptyChildSet);\n      };\n      commitContainer = function(finishedWork) {\n        switch (finishedWork.tag) {\n          case ClassComponent: {\n            return;\n          }\n          case HostComponent: {\n            return;\n          }\n          case HostText: {\n            return;\n          }\n          case HostRoot:\n          case HostPortal: {\n            var portalOrRoot = finishedWork.stateNode;\n            var containerInfo = portalOrRoot.containerInfo,\n              _pendingChildren = portalOrRoot.pendingChildren;\n\n            replaceContainerChildren(containerInfo, _pendingChildren);\n            return;\n          }\n          default: {\n            invariant(\n              false,\n              \"This unit of work tag should not have side-effects. This error is \" +\n                \"likely caused by a bug in React. Please file an issue.\"\n            );\n          }\n        }\n      };\n    } else {\n      commitContainer = function(finishedWork) {\n        // Noop\n      };\n    }\n    if (enablePersistentReconciler || enableNoopReconciler) {\n      return {\n        commitResetTextContent: function(finishedWork) {},\n        commitPlacement: function(finishedWork) {},\n        commitDeletion: function(current) {\n          // Detach refs and call componentWillUnmount() on the whole subtree.\n          commitNestedUnmounts(current);\n          detachFiber(current);\n        },\n        commitWork: function(current, finishedWork) {\n          commitContainer(finishedWork);\n        },\n\n        commitLifeCycles: commitLifeCycles,\n        commitErrorLogging: commitErrorLogging,\n        commitAttachRef: commitAttachRef,\n        commitDetachRef: commitDetachRef\n      };\n    } else if (persistence) {\n      invariant(false, \"Persistent reconciler is disabled.\");\n    } else {\n      invariant(false, \"Noop reconciler is disabled.\");\n    }\n  }\n  var commitMount = mutation.commitMount,\n    commitUpdate = mutation.commitUpdate,\n    resetTextContent = mutation.resetTextContent,\n    commitTextUpdate = mutation.commitTextUpdate,\n    appendChild = mutation.appendChild,\n    appendChildToContainer = mutation.appendChildToContainer,\n    insertBefore = mutation.insertBefore,\n    insertInContainerBefore = mutation.insertInContainerBefore,\n    removeChild = mutation.removeChild,\n    removeChildFromContainer = mutation.removeChildFromContainer;\n\n  function getHostParentFiber(fiber) {\n    var parent = fiber[\"return\"];\n    while (parent !== null) {\n      if (isHostParent(parent)) {\n        return parent;\n      }\n      parent = parent[\"return\"];\n    }\n    invariant(\n      false,\n      \"Expected to find a host parent. This error is likely caused by a bug \" +\n        \"in React. Please file an issue.\"\n    );\n  }\n\n  function isHostParent(fiber) {\n    return (\n      fiber.tag === HostComponent ||\n      fiber.tag === HostRoot ||\n      fiber.tag === HostPortal\n    );\n  }\n\n  function getHostSibling(fiber) {\n    // We're going to search forward into the tree until we find a sibling host\n    // node. Unfortunately, if multiple insertions are done in a row we have to\n    // search past them. This leads to exponential search for the next sibling.\n    var node = fiber;\n    siblings: while (true) {\n      // If we didn't find anything, let's try the next sibling.\n      while (node.sibling === null) {\n        if (node[\"return\"] === null || isHostParent(node[\"return\"])) {\n          // If we pop out of the root or hit the parent the fiber we are the\n          // last sibling.\n          return null;\n        }\n        node = node[\"return\"];\n      }\n      node.sibling[\"return\"] = node[\"return\"];\n      node = node.sibling;\n      while (node.tag !== HostComponent && node.tag !== HostText) {\n        // If it is not host node and, we might have a host node inside it.\n        // Try to search down until we find one.\n        if (node.effectTag & Placement) {\n          // If we don't have a child, try the siblings instead.\n          continue siblings;\n        }\n        // If we don't have a child, try the siblings instead.\n        // We also skip portals because they are not part of this host tree.\n        if (node.child === null || node.tag === HostPortal) {\n          continue siblings;\n        } else {\n          node.child[\"return\"] = node;\n          node = node.child;\n        }\n      }\n      // Check if this host node is stable or about to be placed.\n      if (!(node.effectTag & Placement)) {\n        // Found it!\n        return node.stateNode;\n      }\n    }\n  }\n\n  function commitPlacement(finishedWork) {\n    // Recursively insert all host nodes into the parent.\n    var parentFiber = getHostParentFiber(finishedWork);\n    var parent = void 0;\n    var isContainer = void 0;\n    switch (parentFiber.tag) {\n      case HostComponent:\n        parent = parentFiber.stateNode;\n        isContainer = false;\n        break;\n      case HostRoot:\n        parent = parentFiber.stateNode.containerInfo;\n        isContainer = true;\n        break;\n      case HostPortal:\n        parent = parentFiber.stateNode.containerInfo;\n        isContainer = true;\n        break;\n      default:\n        invariant(\n          false,\n          \"Invalid host parent fiber. This error is likely caused by a bug \" +\n            \"in React. Please file an issue.\"\n        );\n    }\n    if (parentFiber.effectTag & ContentReset) {\n      // Reset the text content of the parent before doing any insertions\n      resetTextContent(parent);\n      // Clear ContentReset from the effect tag\n      parentFiber.effectTag &= ~ContentReset;\n    }\n\n    var before = getHostSibling(finishedWork);\n    // We only have the top Fiber that was inserted but we need recurse down its\n    // children to find all the terminal nodes.\n    var node = finishedWork;\n    while (true) {\n      if (node.tag === HostComponent || node.tag === HostText) {\n        if (before) {\n          if (isContainer) {\n            insertInContainerBefore(parent, node.stateNode, before);\n          } else {\n            insertBefore(parent, node.stateNode, before);\n          }\n        } else {\n          if (isContainer) {\n            appendChildToContainer(parent, node.stateNode);\n          } else {\n            appendChild(parent, node.stateNode);\n          }\n        }\n      } else if (node.tag === HostPortal) {\n        // If the insertion itself is a portal, then we don't want to traverse\n        // down its children. Instead, we'll get insertions from each child in\n        // the portal directly.\n      } else if (node.child !== null) {\n        node.child[\"return\"] = node;\n        node = node.child;\n        continue;\n      }\n      if (node === finishedWork) {\n        return;\n      }\n      while (node.sibling === null) {\n        if (node[\"return\"] === null || node[\"return\"] === finishedWork) {\n          return;\n        }\n        node = node[\"return\"];\n      }\n      node.sibling[\"return\"] = node[\"return\"];\n      node = node.sibling;\n    }\n  }\n\n  function unmountHostComponents(current) {\n    // We only have the top Fiber that was inserted but we need recurse down its\n    var node = current;\n\n    // Each iteration, currentParent is populated with node's host parent if not\n    // currentParentIsValid.\n    var currentParentIsValid = false;\n    var currentParent = void 0;\n    var currentParentIsContainer = void 0;\n\n    while (true) {\n      if (!currentParentIsValid) {\n        var parent = node[\"return\"];\n        findParent: while (true) {\n          invariant(\n            parent !== null,\n            \"Expected to find a host parent. This error is likely caused by \" +\n              \"a bug in React. Please file an issue.\"\n          );\n          switch (parent.tag) {\n            case HostComponent:\n              currentParent = parent.stateNode;\n              currentParentIsContainer = false;\n              break findParent;\n            case HostRoot:\n              currentParent = parent.stateNode.containerInfo;\n              currentParentIsContainer = true;\n              break findParent;\n            case HostPortal:\n              currentParent = parent.stateNode.containerInfo;\n              currentParentIsContainer = true;\n              break findParent;\n          }\n          parent = parent[\"return\"];\n        }\n        currentParentIsValid = true;\n      }\n\n      if (node.tag === HostComponent || node.tag === HostText) {\n        commitNestedUnmounts(node);\n        // After all the children have unmounted, it is now safe to remove the\n        // node from the tree.\n        if (currentParentIsContainer) {\n          removeChildFromContainer(currentParent, node.stateNode);\n        } else {\n          removeChild(currentParent, node.stateNode);\n        }\n        // Don't visit children because we already visited them.\n      } else if (node.tag === HostPortal) {\n        // When we go into a portal, it becomes the parent to remove from.\n        // We will reassign it back when we pop the portal on the way up.\n        currentParent = node.stateNode.containerInfo;\n        // Visit children because portals might contain host components.\n        if (node.child !== null) {\n          node.child[\"return\"] = node;\n          node = node.child;\n          continue;\n        }\n      } else {\n        commitUnmount(node);\n        // Visit children because we may find more host components below.\n        if (node.child !== null) {\n          node.child[\"return\"] = node;\n          node = node.child;\n          continue;\n        }\n      }\n      if (node === current) {\n        return;\n      }\n      while (node.sibling === null) {\n        if (node[\"return\"] === null || node[\"return\"] === current) {\n          return;\n        }\n        node = node[\"return\"];\n        if (node.tag === HostPortal) {\n          // When we go out of the portal, we need to restore the parent.\n          // Since we don't keep a stack of them, we will search for it.\n          currentParentIsValid = false;\n        }\n      }\n      node.sibling[\"return\"] = node[\"return\"];\n      node = node.sibling;\n    }\n  }\n\n  function commitDeletion(current) {\n    // Recursively delete all host nodes from the parent.\n    // Detach refs and call componentWillUnmount() on the whole subtree.\n    unmountHostComponents(current);\n    detachFiber(current);\n  }\n\n  function commitWork(current, finishedWork) {\n    switch (finishedWork.tag) {\n      case ClassComponent: {\n        return;\n      }\n      case HostComponent: {\n        var _instance7 = finishedWork.stateNode;\n        if (_instance7 != null) {\n          // Commit the work prepared earlier.\n          var newProps = finishedWork.memoizedProps;\n          // For hydration we reuse the update path but we treat the oldProps\n          // as the newProps. The updatePayload will contain the real change in\n          // this case.\n          var oldProps = current !== null ? current.memoizedProps : newProps;\n          var type = finishedWork.type;\n          // TODO: Type the updateQueue to be specific to host components.\n          var updatePayload = finishedWork.updateQueue;\n          finishedWork.updateQueue = null;\n          if (updatePayload !== null) {\n            commitUpdate(\n              _instance7,\n              updatePayload,\n              type,\n              oldProps,\n              newProps,\n              finishedWork\n            );\n          }\n        }\n        return;\n      }\n      case HostText: {\n        invariant(\n          finishedWork.stateNode !== null,\n          \"This should have a text node initialized. This error is likely \" +\n            \"caused by a bug in React. Please file an issue.\"\n        );\n        var textInstance = finishedWork.stateNode;\n        var newText = finishedWork.memoizedProps;\n        // For hydration we reuse the update path but we treat the oldProps\n        // as the newProps. The updatePayload will contain the real change in\n        // this case.\n        var oldText = current !== null ? current.memoizedProps : newText;\n        commitTextUpdate(textInstance, oldText, newText);\n        return;\n      }\n      case HostRoot: {\n        return;\n      }\n      default: {\n        invariant(\n          false,\n          \"This unit of work tag should not have side-effects. This error is \" +\n            \"likely caused by a bug in React. Please file an issue.\"\n        );\n      }\n    }\n  }\n\n  function commitResetTextContent(current) {\n    resetTextContent(current.stateNode);\n  }\n\n  if (enableMutatingReconciler) {\n    return {\n      commitResetTextContent: commitResetTextContent,\n      commitPlacement: commitPlacement,\n      commitDeletion: commitDeletion,\n      commitWork: commitWork,\n      commitLifeCycles: commitLifeCycles,\n      commitErrorLogging: commitErrorLogging,\n      commitAttachRef: commitAttachRef,\n      commitDetachRef: commitDetachRef\n    };\n  } else {\n    invariant(false, \"Mutating reconciler is disabled.\");\n  }\n};\n\nvar NO_CONTEXT = {};\n\nvar ReactFiberHostContext = function(config) {\n  var getChildHostContext = config.getChildHostContext,\n    getRootHostContext = config.getRootHostContext;\n\n  var contextStackCursor = createCursor(NO_CONTEXT);\n  var contextFiberStackCursor = createCursor(NO_CONTEXT);\n  var rootInstanceStackCursor = createCursor(NO_CONTEXT);\n\n  function requiredContext(c) {\n    invariant(\n      c !== NO_CONTEXT,\n      \"Expected host context to exist. This error is likely caused by a bug \" +\n        \"in React. Please file an issue.\"\n    );\n    return c;\n  }\n\n  function getRootHostContainer() {\n    var rootInstance = requiredContext(rootInstanceStackCursor.current);\n    return rootInstance;\n  }\n\n  function pushHostContainer(fiber, nextRootInstance) {\n    // Push current root instance onto the stack;\n    // This allows us to reset root when portals are popped.\n    push(rootInstanceStackCursor, nextRootInstance, fiber);\n\n    var nextRootContext = getRootHostContext(nextRootInstance);\n\n    // Track the context and the Fiber that provided it.\n    // This enables us to pop only Fibers that provide unique contexts.\n    push(contextFiberStackCursor, fiber, fiber);\n    push(contextStackCursor, nextRootContext, fiber);\n  }\n\n  function popHostContainer(fiber) {\n    pop(contextStackCursor, fiber);\n    pop(contextFiberStackCursor, fiber);\n    pop(rootInstanceStackCursor, fiber);\n  }\n\n  function getHostContext() {\n    var context = requiredContext(contextStackCursor.current);\n    return context;\n  }\n\n  function pushHostContext(fiber) {\n    var rootInstance = requiredContext(rootInstanceStackCursor.current);\n    var context = requiredContext(contextStackCursor.current);\n    var nextContext = getChildHostContext(context, fiber.type, rootInstance);\n\n    // Don't push this Fiber's context unless it's unique.\n    if (context === nextContext) {\n      return;\n    }\n\n    // Track the context and the Fiber that provided it.\n    // This enables us to pop only Fibers that provide unique contexts.\n    push(contextFiberStackCursor, fiber, fiber);\n    push(contextStackCursor, nextContext, fiber);\n  }\n\n  function popHostContext(fiber) {\n    // Do not pop unless this Fiber provided the current context.\n    // pushHostContext() only pushes Fibers that provide unique contexts.\n    if (contextFiberStackCursor.current !== fiber) {\n      return;\n    }\n\n    pop(contextStackCursor, fiber);\n    pop(contextFiberStackCursor, fiber);\n  }\n\n  function resetHostContainer() {\n    contextStackCursor.current = NO_CONTEXT;\n    rootInstanceStackCursor.current = NO_CONTEXT;\n  }\n\n  return {\n    getHostContext: getHostContext,\n    getRootHostContainer: getRootHostContainer,\n    popHostContainer: popHostContainer,\n    popHostContext: popHostContext,\n    pushHostContainer: pushHostContainer,\n    pushHostContext: pushHostContext,\n    resetHostContainer: resetHostContainer\n  };\n};\n\nvar ReactFiberHydrationContext = function(config) {\n  var shouldSetTextContent = config.shouldSetTextContent,\n    hydration = config.hydration;\n\n  // If this doesn't have hydration mode.\n\n  if (!hydration) {\n    return {\n      enterHydrationState: function() {\n        return false;\n      },\n      resetHydrationState: function() {},\n      tryToClaimNextHydratableInstance: function() {},\n      prepareToHydrateHostInstance: function() {\n        invariant(\n          false,\n          \"Expected prepareToHydrateHostInstance() to never be called. \" +\n            \"This error is likely caused by a bug in React. Please file an issue.\"\n        );\n      },\n      prepareToHydrateHostTextInstance: function() {\n        invariant(\n          false,\n          \"Expected prepareToHydrateHostTextInstance() to never be called. \" +\n            \"This error is likely caused by a bug in React. Please file an issue.\"\n        );\n      },\n      popHydrationState: function(fiber) {\n        return false;\n      }\n    };\n  }\n\n  var canHydrateInstance = hydration.canHydrateInstance,\n    canHydrateTextInstance = hydration.canHydrateTextInstance,\n    getNextHydratableSibling = hydration.getNextHydratableSibling,\n    getFirstHydratableChild = hydration.getFirstHydratableChild,\n    hydrateInstance = hydration.hydrateInstance,\n    hydrateTextInstance = hydration.hydrateTextInstance,\n    didNotMatchHydratedContainerTextInstance =\n      hydration.didNotMatchHydratedContainerTextInstance,\n    didNotMatchHydratedTextInstance = hydration.didNotMatchHydratedTextInstance,\n    didNotHydrateContainerInstance = hydration.didNotHydrateContainerInstance,\n    didNotHydrateInstance = hydration.didNotHydrateInstance,\n    didNotFindHydratableContainerInstance =\n      hydration.didNotFindHydratableContainerInstance,\n    didNotFindHydratableContainerTextInstance =\n      hydration.didNotFindHydratableContainerTextInstance,\n    didNotFindHydratableInstance = hydration.didNotFindHydratableInstance,\n    didNotFindHydratableTextInstance =\n      hydration.didNotFindHydratableTextInstance;\n\n  // The deepest Fiber on the stack involved in a hydration context.\n  // This may have been an insertion or a hydration.\n\n  var hydrationParentFiber = null;\n  var nextHydratableInstance = null;\n  var isHydrating = false;\n\n  function enterHydrationState(fiber) {\n    var parentInstance = fiber.stateNode.containerInfo;\n    nextHydratableInstance = getFirstHydratableChild(parentInstance);\n    hydrationParentFiber = fiber;\n    isHydrating = true;\n    return true;\n  }\n\n  function deleteHydratableInstance(returnFiber, instance) {\n    {\n      switch (returnFiber.tag) {\n        case HostRoot:\n          didNotHydrateContainerInstance(\n            returnFiber.stateNode.containerInfo,\n            instance\n          );\n          break;\n        case HostComponent:\n          didNotHydrateInstance(\n            returnFiber.type,\n            returnFiber.memoizedProps,\n            returnFiber.stateNode,\n            instance\n          );\n          break;\n      }\n    }\n\n    var childToDelete = createFiberFromHostInstanceForDeletion();\n    childToDelete.stateNode = instance;\n    childToDelete[\"return\"] = returnFiber;\n    childToDelete.effectTag = Deletion;\n\n    // This might seem like it belongs on progressedFirstDeletion. However,\n    // these children are not part of the reconciliation list of children.\n    // Even if we abort and rereconcile the children, that will try to hydrate\n    // again and the nodes are still in the host tree so these will be\n    // recreated.\n    if (returnFiber.lastEffect !== null) {\n      returnFiber.lastEffect.nextEffect = childToDelete;\n      returnFiber.lastEffect = childToDelete;\n    } else {\n      returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;\n    }\n  }\n\n  function insertNonHydratedInstance(returnFiber, fiber) {\n    fiber.effectTag |= Placement;\n    {\n      switch (returnFiber.tag) {\n        case HostRoot: {\n          var parentContainer = returnFiber.stateNode.containerInfo;\n          switch (fiber.tag) {\n            case HostComponent:\n              var type = fiber.type;\n              var props = fiber.pendingProps;\n              didNotFindHydratableContainerInstance(\n                parentContainer,\n                type,\n                props\n              );\n              break;\n            case HostText:\n              var text = fiber.pendingProps;\n              didNotFindHydratableContainerTextInstance(parentContainer, text);\n              break;\n          }\n          break;\n        }\n        case HostComponent: {\n          var parentType = returnFiber.type;\n          var parentProps = returnFiber.memoizedProps;\n          var parentInstance = returnFiber.stateNode;\n          switch (fiber.tag) {\n            case HostComponent:\n              var _type = fiber.type;\n              var _props = fiber.pendingProps;\n              didNotFindHydratableInstance(\n                parentType,\n                parentProps,\n                parentInstance,\n                _type,\n                _props\n              );\n              break;\n            case HostText:\n              var _text = fiber.pendingProps;\n              didNotFindHydratableTextInstance(\n                parentType,\n                parentProps,\n                parentInstance,\n                _text\n              );\n              break;\n          }\n          break;\n        }\n        default:\n          return;\n      }\n    }\n  }\n\n  function tryHydrate(fiber, nextInstance) {\n    switch (fiber.tag) {\n      case HostComponent: {\n        var type = fiber.type;\n        var props = fiber.pendingProps;\n        var instance = canHydrateInstance(nextInstance, type, props);\n        if (instance !== null) {\n          fiber.stateNode = instance;\n          return true;\n        }\n        return false;\n      }\n      case HostText: {\n        var text = fiber.pendingProps;\n        var textInstance = canHydrateTextInstance(nextInstance, text);\n        if (textInstance !== null) {\n          fiber.stateNode = textInstance;\n          return true;\n        }\n        return false;\n      }\n      default:\n        return false;\n    }\n  }\n\n  function tryToClaimNextHydratableInstance(fiber) {\n    if (!isHydrating) {\n      return;\n    }\n    var nextInstance = nextHydratableInstance;\n    if (!nextInstance) {\n      // Nothing to hydrate. Make it an insertion.\n      insertNonHydratedInstance(hydrationParentFiber, fiber);\n      isHydrating = false;\n      hydrationParentFiber = fiber;\n      return;\n    }\n    if (!tryHydrate(fiber, nextInstance)) {\n      // If we can't hydrate this instance let's try the next one.\n      // We use this as a heuristic. It's based on intuition and not data so it\n      // might be flawed or unnecessary.\n      nextInstance = getNextHydratableSibling(nextInstance);\n      if (!nextInstance || !tryHydrate(fiber, nextInstance)) {\n        // Nothing to hydrate. Make it an insertion.\n        insertNonHydratedInstance(hydrationParentFiber, fiber);\n        isHydrating = false;\n        hydrationParentFiber = fiber;\n        return;\n      }\n      // We matched the next one, we'll now assume that the first one was\n      // superfluous and we'll delete it. Since we can't eagerly delete it\n      // we'll have to schedule a deletion. To do that, this node needs a dummy\n      // fiber associated with it.\n      deleteHydratableInstance(hydrationParentFiber, nextHydratableInstance);\n    }\n    hydrationParentFiber = fiber;\n    nextHydratableInstance = getFirstHydratableChild(nextInstance);\n  }\n\n  function prepareToHydrateHostInstance(\n    fiber,\n    rootContainerInstance,\n    hostContext\n  ) {\n    var instance = fiber.stateNode;\n    var updatePayload = hydrateInstance(\n      instance,\n      fiber.type,\n      fiber.memoizedProps,\n      rootContainerInstance,\n      hostContext,\n      fiber\n    );\n    // TODO: Type this specific to this type of component.\n    fiber.updateQueue = updatePayload;\n    // If the update payload indicates that there is a change or if there\n    // is a new ref we mark this as an update.\n    if (updatePayload !== null) {\n      return true;\n    }\n    return false;\n  }\n\n  function prepareToHydrateHostTextInstance(fiber) {\n    var textInstance = fiber.stateNode;\n    var textContent = fiber.memoizedProps;\n    var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);\n    {\n      if (shouldUpdate) {\n        // We assume that prepareToHydrateHostTextInstance is called in a context where the\n        // hydration parent is the parent host component of this host text.\n        var returnFiber = hydrationParentFiber;\n        if (returnFiber !== null) {\n          switch (returnFiber.tag) {\n            case HostRoot: {\n              var parentContainer = returnFiber.stateNode.containerInfo;\n              didNotMatchHydratedContainerTextInstance(\n                parentContainer,\n                textInstance,\n                textContent\n              );\n              break;\n            }\n            case HostComponent: {\n              var parentType = returnFiber.type;\n              var parentProps = returnFiber.memoizedProps;\n              var parentInstance = returnFiber.stateNode;\n              didNotMatchHydratedTextInstance(\n                parentType,\n                parentProps,\n                parentInstance,\n                textInstance,\n                textContent\n              );\n              break;\n            }\n          }\n        }\n      }\n    }\n    return shouldUpdate;\n  }\n\n  function popToNextHostParent(fiber) {\n    var parent = fiber[\"return\"];\n    while (\n      parent !== null &&\n      parent.tag !== HostComponent &&\n      parent.tag !== HostRoot\n    ) {\n      parent = parent[\"return\"];\n    }\n    hydrationParentFiber = parent;\n  }\n\n  function popHydrationState(fiber) {\n    if (fiber !== hydrationParentFiber) {\n      // We're deeper than the current hydration context, inside an inserted\n      // tree.\n      return false;\n    }\n    if (!isHydrating) {\n      // If we're not currently hydrating but we're in a hydration context, then\n      // we were an insertion and now need to pop up reenter hydration of our\n      // siblings.\n      popToNextHostParent(fiber);\n      isHydrating = true;\n      return false;\n    }\n\n    var type = fiber.type;\n\n    // If we have any remaining hydratable nodes, we need to delete them now.\n    // We only do this deeper than head and body since they tend to have random\n    // other nodes in them. We also ignore components with pure text content in\n    // side of them.\n    // TODO: Better heuristic.\n    if (\n      fiber.tag !== HostComponent ||\n      (type !== \"head\" &&\n        type !== \"body\" &&\n        !shouldSetTextContent(type, fiber.memoizedProps))\n    ) {\n      var nextInstance = nextHydratableInstance;\n      while (nextInstance) {\n        deleteHydratableInstance(fiber, nextInstance);\n        nextInstance = getNextHydratableSibling(nextInstance);\n      }\n    }\n\n    popToNextHostParent(fiber);\n    nextHydratableInstance = hydrationParentFiber\n      ? getNextHydratableSibling(fiber.stateNode)\n      : null;\n    return true;\n  }\n\n  function resetHydrationState() {\n    hydrationParentFiber = null;\n    nextHydratableInstance = null;\n    isHydrating = false;\n  }\n\n  return {\n    enterHydrationState: enterHydrationState,\n    resetHydrationState: resetHydrationState,\n    tryToClaimNextHydratableInstance: tryToClaimNextHydratableInstance,\n    prepareToHydrateHostInstance: prepareToHydrateHostInstance,\n    prepareToHydrateHostTextInstance: prepareToHydrateHostTextInstance,\n    popHydrationState: popHydrationState\n  };\n};\n\n// This lets us hook into Fiber to debug what it's doing.\n// See https://github.com/facebook/react/pull/8033.\n// This is not part of the public API, not even for React DevTools.\n// You may only inject a debugTool if you work on React Fiber itself.\nvar ReactFiberInstrumentation = {\n  debugTool: null\n};\n\nvar ReactFiberInstrumentation_1 = ReactFiberInstrumentation;\n\nvar invokeGuardedCallback$2 = ReactErrorUtils.invokeGuardedCallback;\nvar hasCaughtError = ReactErrorUtils.hasCaughtError;\nvar clearCaughtError = ReactErrorUtils.clearCaughtError;\n\nvar didWarnAboutStateTransition = void 0;\nvar didWarnSetStateChildContext = void 0;\nvar warnAboutUpdateOnUnmounted = void 0;\nvar warnAboutInvalidUpdates = void 0;\n\n{\n  didWarnAboutStateTransition = false;\n  didWarnSetStateChildContext = false;\n  var didWarnStateUpdateForUnmountedComponent = {};\n\n  warnAboutUpdateOnUnmounted = function(fiber) {\n    var componentName = getComponentName(fiber) || \"ReactClass\";\n    if (didWarnStateUpdateForUnmountedComponent[componentName]) {\n      return;\n    }\n    warning(\n      false,\n      \"Can only update a mounted or mounting \" +\n        \"component. This usually means you called setState, replaceState, \" +\n        \"or forceUpdate on an unmounted component. This is a no-op.\\n\\nPlease \" +\n        \"check the code for the %s component.\",\n      componentName\n    );\n    didWarnStateUpdateForUnmountedComponent[componentName] = true;\n  };\n\n  warnAboutInvalidUpdates = function(instance) {\n    switch (ReactDebugCurrentFiber.phase) {\n      case \"getChildContext\":\n        if (didWarnSetStateChildContext) {\n          return;\n        }\n        warning(\n          false,\n          \"setState(...): Cannot call setState() inside getChildContext()\"\n        );\n        didWarnSetStateChildContext = true;\n        break;\n      case \"render\":\n        if (didWarnAboutStateTransition) {\n          return;\n        }\n        warning(\n          false,\n          \"Cannot update during an existing state transition (such as within \" +\n            \"`render` or another component's constructor). Render methods should \" +\n            \"be a pure function of props and state; constructor side-effects are \" +\n            \"an anti-pattern, but can be moved to `componentWillMount`.\"\n        );\n        didWarnAboutStateTransition = true;\n        break;\n    }\n  };\n}\n\nvar ReactFiberScheduler = function(config) {\n  var hostContext = ReactFiberHostContext(config);\n  var popHostContext = hostContext.popHostContext,\n    popHostContainer = hostContext.popHostContainer;\n\n  var hydrationContext = ReactFiberHydrationContext(config);\n  var resetHostContainer = hostContext.resetHostContainer;\n\n  var _ReactFiberBeginWork = ReactFiberBeginWork(\n      config,\n      hostContext,\n      hydrationContext,\n      scheduleWork,\n      computeExpirationForFiber\n    ),\n    beginWork = _ReactFiberBeginWork.beginWork;\n\n  var _ReactFiberCompleteWo = ReactFiberCompleteWork(\n      config,\n      hostContext,\n      hydrationContext\n    ),\n    completeWork = _ReactFiberCompleteWo.completeWork;\n\n  var _ReactFiberUnwindWork = ReactFiberUnwindWork(\n      hostContext,\n      scheduleWork,\n      isAlreadyFailedLegacyErrorBoundary\n    ),\n    throwException = _ReactFiberUnwindWork.throwException,\n    unwindWork = _ReactFiberUnwindWork.unwindWork;\n\n  var _ReactFiberCommitWork = ReactFiberCommitWork(\n      config,\n      onCommitPhaseError,\n      scheduleWork,\n      computeExpirationForFiber,\n      markLegacyErrorBoundaryAsFailed,\n      recalculateCurrentTime\n    ),\n    commitResetTextContent = _ReactFiberCommitWork.commitResetTextContent,\n    commitPlacement = _ReactFiberCommitWork.commitPlacement,\n    commitDeletion = _ReactFiberCommitWork.commitDeletion,\n    commitWork = _ReactFiberCommitWork.commitWork,\n    commitLifeCycles = _ReactFiberCommitWork.commitLifeCycles,\n    commitErrorLogging = _ReactFiberCommitWork.commitErrorLogging,\n    commitAttachRef = _ReactFiberCommitWork.commitAttachRef,\n    commitDetachRef = _ReactFiberCommitWork.commitDetachRef;\n\n  var now = config.now,\n    scheduleDeferredCallback = config.scheduleDeferredCallback,\n    cancelDeferredCallback = config.cancelDeferredCallback,\n    prepareForCommit = config.prepareForCommit,\n    resetAfterCommit = config.resetAfterCommit;\n\n  // Represents the current time in ms.\n\n  var originalStartTimeMs = now();\n  var mostRecentCurrentTime = msToExpirationTime(0);\n  var mostRecentCurrentTimeMs = originalStartTimeMs;\n\n  // Used to ensure computeUniqueAsyncExpiration is monotonically increases.\n  var lastUniqueAsyncExpiration = 0;\n\n  // Represents the expiration time that incoming updates should use. (If this\n  // is NoWork, use the default strategy: async updates in async mode, sync\n  // updates in sync mode.)\n  var expirationContext = NoWork;\n\n  var isWorking = false;\n\n  // The next work in progress fiber that we're currently working on.\n  var nextUnitOfWork = null;\n  var nextRoot = null;\n  // The time at which we're currently rendering work.\n  var nextRenderExpirationTime = NoWork;\n\n  // The next fiber with an effect that we're currently committing.\n  var nextEffect = null;\n\n  var isCommitting = false;\n\n  var isRootReadyForCommit = false;\n\n  var legacyErrorBoundariesThatAlreadyFailed = null;\n\n  // Used for performance tracking.\n  var interruptedBy = null;\n\n  var stashedWorkInProgressProperties = void 0;\n  var replayUnitOfWork = void 0;\n  if (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {\n    stashedWorkInProgressProperties = null;\n    replayUnitOfWork = function(failedUnitOfWork, isAsync) {\n      // Retore the original state of the work-in-progress\n      Object.assign(failedUnitOfWork, stashedWorkInProgressProperties);\n      switch (failedUnitOfWork.tag) {\n        case HostRoot:\n          popHostContainer(failedUnitOfWork);\n          popTopLevelContextObject(failedUnitOfWork);\n          break;\n        case HostComponent:\n          popHostContext(failedUnitOfWork);\n          break;\n        case ClassComponent:\n          popContextProvider(failedUnitOfWork);\n          break;\n        case HostPortal:\n          popHostContainer(failedUnitOfWork);\n          break;\n        case ContextProvider:\n          popProvider(failedUnitOfWork);\n          break;\n      }\n      // Replay the begin phase.\n      invokeGuardedCallback$2(null, workLoop, null, isAsync);\n      if (hasCaughtError()) {\n        clearCaughtError();\n      } else {\n        // This should be unreachable because the render phase is\n        // idempotent\n      }\n    };\n  }\n\n  function resetContextStack() {\n    // Reset the stack\n    reset();\n    // Reset the cursors\n    resetContext();\n    resetHostContainer();\n\n    // TODO: Unify new context implementation with other stacks\n    resetProviderStack();\n\n    {\n      ReactStrictModeWarnings.discardPendingWarnings();\n    }\n\n    nextRoot = null;\n    nextRenderExpirationTime = NoWork;\n    nextUnitOfWork = null;\n\n    isRootReadyForCommit = false;\n  }\n\n  function commitAllHostEffects() {\n    while (nextEffect !== null) {\n      {\n        ReactDebugCurrentFiber.setCurrentFiber(nextEffect);\n      }\n      recordEffect();\n\n      var effectTag = nextEffect.effectTag;\n      if (effectTag & ContentReset) {\n        commitResetTextContent(nextEffect);\n      }\n\n      if (effectTag & Ref) {\n        var current = nextEffect.alternate;\n        if (current !== null) {\n          commitDetachRef(current);\n        }\n      }\n\n      // The following switch statement is only concerned about placement,\n      // updates, and deletions. To avoid needing to add a case for every\n      // possible bitmap value, we remove the secondary effects from the\n      // effect tag and switch on that value.\n      var primaryEffectTag = effectTag & (Placement | Update | Deletion);\n      switch (primaryEffectTag) {\n        case Placement: {\n          commitPlacement(nextEffect);\n          // Clear the \"placement\" from effect tag so that we know that this is inserted, before\n          // any life-cycles like componentDidMount gets called.\n          // TODO: findDOMNode doesn't rely on this any more but isMounted\n          // does and isMounted is deprecated anyway so we should be able\n          // to kill this.\n          nextEffect.effectTag &= ~Placement;\n          break;\n        }\n        case PlacementAndUpdate: {\n          // Placement\n          commitPlacement(nextEffect);\n          // Clear the \"placement\" from effect tag so that we know that this is inserted, before\n          // any life-cycles like componentDidMount gets called.\n          nextEffect.effectTag &= ~Placement;\n\n          // Update\n          var _current = nextEffect.alternate;\n          commitWork(_current, nextEffect);\n          break;\n        }\n        case Update: {\n          var _current2 = nextEffect.alternate;\n          commitWork(_current2, nextEffect);\n          break;\n        }\n        case Deletion: {\n          commitDeletion(nextEffect);\n          break;\n        }\n      }\n      nextEffect = nextEffect.nextEffect;\n    }\n\n    {\n      ReactDebugCurrentFiber.resetCurrentFiber();\n    }\n  }\n\n  function commitAllLifeCycles(\n    finishedRoot,\n    currentTime,\n    committedExpirationTime\n  ) {\n    {\n      ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();\n\n      if (warnAboutDeprecatedLifecycles) {\n        ReactStrictModeWarnings.flushPendingDeprecationWarnings();\n      }\n    }\n    while (nextEffect !== null) {\n      var effectTag = nextEffect.effectTag;\n\n      if (effectTag & (Update | Callback)) {\n        recordEffect();\n        var current = nextEffect.alternate;\n        commitLifeCycles(\n          finishedRoot,\n          current,\n          nextEffect,\n          currentTime,\n          committedExpirationTime\n        );\n      }\n\n      if (effectTag & ErrLog) {\n        commitErrorLogging(nextEffect, onUncaughtError);\n      }\n\n      if (effectTag & Ref) {\n        recordEffect();\n        commitAttachRef(nextEffect);\n      }\n\n      var next = nextEffect.nextEffect;\n      // Ensure that we clean these up so that we don't accidentally keep them.\n      // I'm not actually sure this matters because we can't reset firstEffect\n      // and lastEffect since they're on every node, not just the effectful\n      // ones. So we have to clean everything as we reuse nodes anyway.\n      nextEffect.nextEffect = null;\n      // Ensure that we reset the effectTag here so that we can rely on effect\n      // tags to reason about the current life-cycle.\n      nextEffect = next;\n    }\n  }\n\n  function isAlreadyFailedLegacyErrorBoundary(instance) {\n    return (\n      legacyErrorBoundariesThatAlreadyFailed !== null &&\n      legacyErrorBoundariesThatAlreadyFailed.has(instance)\n    );\n  }\n\n  function markLegacyErrorBoundaryAsFailed(instance) {\n    if (legacyErrorBoundariesThatAlreadyFailed === null) {\n      legacyErrorBoundariesThatAlreadyFailed = new Set([instance]);\n    } else {\n      legacyErrorBoundariesThatAlreadyFailed.add(instance);\n    }\n  }\n\n  function commitRoot(finishedWork) {\n    isWorking = true;\n    isCommitting = true;\n    startCommitTimer();\n\n    var root = finishedWork.stateNode;\n    invariant(\n      root.current !== finishedWork,\n      \"Cannot commit the same tree as before. This is probably a bug \" +\n        \"related to the return field. This error is likely caused by a bug \" +\n        \"in React. Please file an issue.\"\n    );\n    var committedExpirationTime = root.pendingCommitExpirationTime;\n    invariant(\n      committedExpirationTime !== NoWork,\n      \"Cannot commit an incomplete root. This error is likely caused by a \" +\n        \"bug in React. Please file an issue.\"\n    );\n    root.pendingCommitExpirationTime = NoWork;\n\n    var currentTime = recalculateCurrentTime();\n\n    // Reset this to null before calling lifecycles\n    ReactCurrentOwner.current = null;\n\n    var firstEffect = void 0;\n    if (finishedWork.effectTag > PerformedWork) {\n      // A fiber's effect list consists only of its children, not itself. So if\n      // the root has an effect, we need to add it to the end of the list. The\n      // resulting list is the set that would belong to the root's parent, if\n      // it had one; that is, all the effects in the tree including the root.\n      if (finishedWork.lastEffect !== null) {\n        finishedWork.lastEffect.nextEffect = finishedWork;\n        firstEffect = finishedWork.firstEffect;\n      } else {\n        firstEffect = finishedWork;\n      }\n    } else {\n      // There is no effect on the root.\n      firstEffect = finishedWork.firstEffect;\n    }\n\n    prepareForCommit(root.containerInfo);\n\n    // Commit all the side-effects within a tree. We'll do this in two passes.\n    // The first pass performs all the host insertions, updates, deletions and\n    // ref unmounts.\n    nextEffect = firstEffect;\n    startCommitHostEffectsTimer();\n    while (nextEffect !== null) {\n      var didError = false;\n      var error = void 0;\n      {\n        invokeGuardedCallback$2(null, commitAllHostEffects, null);\n        if (hasCaughtError()) {\n          didError = true;\n          error = clearCaughtError();\n        }\n      }\n      if (didError) {\n        invariant(\n          nextEffect !== null,\n          \"Should have next effect. This error is likely caused by a bug \" +\n            \"in React. Please file an issue.\"\n        );\n        onCommitPhaseError(nextEffect, error);\n        // Clean-up\n        if (nextEffect !== null) {\n          nextEffect = nextEffect.nextEffect;\n        }\n      }\n    }\n    stopCommitHostEffectsTimer();\n\n    resetAfterCommit(root.containerInfo);\n\n    // The work-in-progress tree is now the current tree. This must come after\n    // the first pass of the commit phase, so that the previous tree is still\n    // current during componentWillUnmount, but before the second pass, so that\n    // the finished work is current during componentDidMount/Update.\n    root.current = finishedWork;\n\n    // In the second pass we'll perform all life-cycles and ref callbacks.\n    // Life-cycles happen as a separate pass so that all placements, updates,\n    // and deletions in the entire tree have already been invoked.\n    // This pass also triggers any renderer-specific initial effects.\n    nextEffect = firstEffect;\n    startCommitLifeCyclesTimer();\n    while (nextEffect !== null) {\n      var _didError = false;\n      var _error = void 0;\n      {\n        invokeGuardedCallback$2(\n          null,\n          commitAllLifeCycles,\n          null,\n          root,\n          currentTime,\n          committedExpirationTime\n        );\n        if (hasCaughtError()) {\n          _didError = true;\n          _error = clearCaughtError();\n        }\n      }\n      if (_didError) {\n        invariant(\n          nextEffect !== null,\n          \"Should have next effect. This error is likely caused by a bug \" +\n            \"in React. Please file an issue.\"\n        );\n        onCommitPhaseError(nextEffect, _error);\n        if (nextEffect !== null) {\n          nextEffect = nextEffect.nextEffect;\n        }\n      }\n    }\n\n    isCommitting = false;\n    isWorking = false;\n    stopCommitLifeCyclesTimer();\n    stopCommitTimer();\n    if (typeof onCommitRoot === \"function\") {\n      onCommitRoot(finishedWork.stateNode);\n    }\n    if (true && ReactFiberInstrumentation_1.debugTool) {\n      ReactFiberInstrumentation_1.debugTool.onCommitWork(finishedWork);\n    }\n\n    var remainingTime = root.current.expirationTime;\n    if (remainingTime === NoWork) {\n      // If there's no remaining work, we can clear the set of already failed\n      // error boundaries.\n      legacyErrorBoundariesThatAlreadyFailed = null;\n    }\n    return remainingTime;\n  }\n\n  function resetExpirationTime(workInProgress, renderTime) {\n    if (renderTime !== Never && workInProgress.expirationTime === Never) {\n      // The children of this component are hidden. Don't bubble their\n      // expiration times.\n      return;\n    }\n\n    // Check for pending updates.\n    var newExpirationTime = getUpdateExpirationTime(workInProgress);\n\n    // TODO: Calls need to visit stateNode\n\n    // Bubble up the earliest expiration time.\n    var child = workInProgress.child;\n    while (child !== null) {\n      if (\n        child.expirationTime !== NoWork &&\n        (newExpirationTime === NoWork ||\n          newExpirationTime > child.expirationTime)\n      ) {\n        newExpirationTime = child.expirationTime;\n      }\n      child = child.sibling;\n    }\n    workInProgress.expirationTime = newExpirationTime;\n  }\n\n  function completeUnitOfWork(workInProgress) {\n    // Attempt to complete the current unit of work, then move to the\n    // next sibling. If there are no more siblings, return to the\n    // parent fiber.\n    while (true) {\n      // The current, flushed, state of this fiber is the alternate.\n      // Ideally nothing should rely on this, but relying on it here\n      // means that we don't need an additional field on the work in\n      // progress.\n      var current = workInProgress.alternate;\n      {\n        ReactDebugCurrentFiber.setCurrentFiber(workInProgress);\n      }\n\n      var returnFiber = workInProgress[\"return\"];\n      var siblingFiber = workInProgress.sibling;\n\n      if ((workInProgress.effectTag & Incomplete) === NoEffect) {\n        // This fiber completed.\n        var next = completeWork(\n          current,\n          workInProgress,\n          nextRenderExpirationTime\n        );\n        stopWorkTimer(workInProgress);\n        resetExpirationTime(workInProgress, nextRenderExpirationTime);\n        {\n          ReactDebugCurrentFiber.resetCurrentFiber();\n        }\n\n        if (next !== null) {\n          stopWorkTimer(workInProgress);\n          if (true && ReactFiberInstrumentation_1.debugTool) {\n            ReactFiberInstrumentation_1.debugTool.onCompleteWork(\n              workInProgress\n            );\n          }\n          // If completing this work spawned new work, do that next. We'll come\n          // back here again.\n          return next;\n        }\n\n        if (\n          returnFiber !== null &&\n          // Do not append effects to parents if a sibling failed to complete\n          (returnFiber.effectTag & Incomplete) === NoEffect\n        ) {\n          // Append all the effects of the subtree and this fiber onto the effect\n          // list of the parent. The completion order of the children affects the\n          // side-effect order.\n          if (returnFiber.firstEffect === null) {\n            returnFiber.firstEffect = workInProgress.firstEffect;\n          }\n          if (workInProgress.lastEffect !== null) {\n            if (returnFiber.lastEffect !== null) {\n              returnFiber.lastEffect.nextEffect = workInProgress.firstEffect;\n            }\n            returnFiber.lastEffect = workInProgress.lastEffect;\n          }\n\n          // If this fiber had side-effects, we append it AFTER the children's\n          // side-effects. We can perform certain side-effects earlier if\n          // needed, by doing multiple passes over the effect list. We don't want\n          // to schedule our own side-effect on our own list because if end up\n          // reusing children we'll schedule this effect onto itself since we're\n          // at the end.\n          var effectTag = workInProgress.effectTag;\n          // Skip both NoWork and PerformedWork tags when creating the effect list.\n          // PerformedWork effect is read by React DevTools but shouldn't be committed.\n          if (effectTag > PerformedWork) {\n            if (returnFiber.lastEffect !== null) {\n              returnFiber.lastEffect.nextEffect = workInProgress;\n            } else {\n              returnFiber.firstEffect = workInProgress;\n            }\n            returnFiber.lastEffect = workInProgress;\n          }\n        }\n\n        if (true && ReactFiberInstrumentation_1.debugTool) {\n          ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);\n        }\n\n        if (siblingFiber !== null) {\n          // If there is more work to do in this returnFiber, do that next.\n          return siblingFiber;\n        } else if (returnFiber !== null) {\n          // If there's no more work in this returnFiber. Complete the returnFiber.\n          workInProgress = returnFiber;\n          continue;\n        } else {\n          // We've reached the root.\n          isRootReadyForCommit = true;\n          return null;\n        }\n      } else {\n        // This fiber did not complete because something threw. Pop values off\n        // the stack without entering the complete phase. If this is a boundary,\n        // capture values if possible.\n        var _next = unwindWork(workInProgress);\n        // Because this fiber did not complete, don't reset its expiration time.\n        if (workInProgress.effectTag & DidCapture) {\n          // Restarting an error boundary\n          stopFailedWorkTimer(workInProgress);\n        } else {\n          stopWorkTimer(workInProgress);\n        }\n\n        {\n          ReactDebugCurrentFiber.resetCurrentFiber();\n        }\n\n        if (_next !== null) {\n          stopWorkTimer(workInProgress);\n          if (true && ReactFiberInstrumentation_1.debugTool) {\n            ReactFiberInstrumentation_1.debugTool.onCompleteWork(\n              workInProgress\n            );\n          }\n          // If completing this work spawned new work, do that next. We'll come\n          // back here again.\n          // Since we're restarting, remove anything that is not a host effect\n          // from the effect tag.\n          _next.effectTag &= HostEffectMask;\n          return _next;\n        }\n\n        if (returnFiber !== null) {\n          // Mark the parent fiber as incomplete and clear its effect list.\n          returnFiber.firstEffect = returnFiber.lastEffect = null;\n          returnFiber.effectTag |= Incomplete;\n        }\n\n        if (true && ReactFiberInstrumentation_1.debugTool) {\n          ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);\n        }\n\n        if (siblingFiber !== null) {\n          // If there is more work to do in this returnFiber, do that next.\n          return siblingFiber;\n        } else if (returnFiber !== null) {\n          // If there's no more work in this returnFiber. Complete the returnFiber.\n          workInProgress = returnFiber;\n          continue;\n        } else {\n          return null;\n        }\n      }\n    }\n\n    // Without this explicit null return Flow complains of invalid return type\n    // TODO Remove the above while(true) loop\n    // eslint-disable-next-line no-unreachable\n    return null;\n  }\n\n  function performUnitOfWork(workInProgress) {\n    // The current, flushed, state of this fiber is the alternate.\n    // Ideally nothing should rely on this, but relying on it here\n    // means that we don't need an additional field on the work in\n    // progress.\n    var current = workInProgress.alternate;\n\n    // See if beginning this work spawns more work.\n    startWorkTimer(workInProgress);\n    {\n      ReactDebugCurrentFiber.setCurrentFiber(workInProgress);\n    }\n\n    if (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {\n      stashedWorkInProgressProperties = Object.assign({}, workInProgress);\n    }\n    var next = beginWork(current, workInProgress, nextRenderExpirationTime);\n\n    {\n      ReactDebugCurrentFiber.resetCurrentFiber();\n    }\n    if (true && ReactFiberInstrumentation_1.debugTool) {\n      ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);\n    }\n\n    if (next === null) {\n      // If this doesn't spawn new work, complete the current work.\n      next = completeUnitOfWork(workInProgress);\n    }\n\n    ReactCurrentOwner.current = null;\n\n    return next;\n  }\n\n  function workLoop(isAsync) {\n    if (!isAsync) {\n      // Flush all expired work.\n      while (nextUnitOfWork !== null) {\n        nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n      }\n    } else {\n      // Flush asynchronous work until the deadline runs out of time.\n      while (nextUnitOfWork !== null && !shouldYield()) {\n        nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n      }\n    }\n  }\n\n  function renderRoot(root, expirationTime, isAsync) {\n    invariant(\n      !isWorking,\n      \"renderRoot was called recursively. This error is likely caused \" +\n        \"by a bug in React. Please file an issue.\"\n    );\n    isWorking = true;\n\n    // Check if we're starting from a fresh stack, or if we're resuming from\n    // previously yielded work.\n    if (\n      expirationTime !== nextRenderExpirationTime ||\n      root !== nextRoot ||\n      nextUnitOfWork === null\n    ) {\n      // Reset the stack and start working from the root.\n      resetContextStack();\n      nextRoot = root;\n      nextRenderExpirationTime = expirationTime;\n      nextUnitOfWork = createWorkInProgress(\n        nextRoot.current,\n        null,\n        nextRenderExpirationTime\n      );\n      root.pendingCommitExpirationTime = NoWork;\n    }\n\n    var didFatal = false;\n\n    startWorkLoopTimer(nextUnitOfWork);\n\n    do {\n      try {\n        workLoop(isAsync);\n      } catch (thrownValue) {\n        if (nextUnitOfWork === null) {\n          // This is a fatal error.\n          didFatal = true;\n          onUncaughtError(thrownValue);\n          break;\n        }\n\n        if (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {\n          var failedUnitOfWork = nextUnitOfWork;\n          replayUnitOfWork(failedUnitOfWork, isAsync);\n        }\n\n        var sourceFiber = nextUnitOfWork;\n        var returnFiber = sourceFiber[\"return\"];\n        if (returnFiber === null) {\n          // This is a fatal error.\n          didFatal = true;\n          onUncaughtError(thrownValue);\n          break;\n        }\n        throwException(returnFiber, sourceFiber, thrownValue);\n        nextUnitOfWork = completeUnitOfWork(sourceFiber);\n      }\n      break;\n    } while (true);\n\n    // We're done performing work. Time to clean up.\n    stopWorkLoopTimer(interruptedBy);\n    interruptedBy = null;\n    isWorking = false;\n\n    // Yield back to main thread.\n    if (didFatal) {\n      // There was a fatal error.\n      return null;\n    } else if (nextUnitOfWork === null) {\n      // We reached the root.\n      if (isRootReadyForCommit) {\n        // The root successfully completed. It's ready for commit.\n        root.pendingCommitExpirationTime = expirationTime;\n        var finishedWork = root.current.alternate;\n        return finishedWork;\n      } else {\n        // The root did not complete.\n        invariant(\n          false,\n          \"Expired work should have completed. This error is likely caused \" +\n            \"by a bug in React. Please file an issue.\"\n        );\n      }\n    } else {\n      // There's more work to do, but we ran out of time. Yield back to\n      // the renderer.\n      return null;\n    }\n  }\n\n  function scheduleCapture(sourceFiber, boundaryFiber, value, expirationTime) {\n    // TODO: We only support dispatching errors.\n    var capturedValue = createCapturedValue(value, sourceFiber);\n    var update = {\n      expirationTime: expirationTime,\n      partialState: null,\n      callback: null,\n      isReplace: false,\n      isForced: false,\n      capturedValue: capturedValue,\n      next: null\n    };\n    insertUpdateIntoFiber(boundaryFiber, update);\n    scheduleWork(boundaryFiber, expirationTime);\n  }\n\n  function dispatch(sourceFiber, value, expirationTime) {\n    invariant(\n      !isWorking || isCommitting,\n      \"dispatch: Cannot dispatch during the render phase.\"\n    );\n\n    // TODO: Handle arrays\n\n    var fiber = sourceFiber[\"return\"];\n    while (fiber !== null) {\n      switch (fiber.tag) {\n        case ClassComponent:\n          var ctor = fiber.type;\n          var instance = fiber.stateNode;\n          if (\n            typeof ctor.getDerivedStateFromCatch === \"function\" ||\n            (typeof instance.componentDidCatch === \"function\" &&\n              !isAlreadyFailedLegacyErrorBoundary(instance))\n          ) {\n            scheduleCapture(sourceFiber, fiber, value, expirationTime);\n            return;\n          }\n          break;\n        // TODO: Handle async boundaries\n        case HostRoot:\n          scheduleCapture(sourceFiber, fiber, value, expirationTime);\n          return;\n      }\n      fiber = fiber[\"return\"];\n    }\n\n    if (sourceFiber.tag === HostRoot) {\n      // Error was thrown at the root. There is no parent, so the root\n      // itself should capture it.\n      scheduleCapture(sourceFiber, sourceFiber, value, expirationTime);\n    }\n  }\n\n  function onCommitPhaseError(fiber, error) {\n    return dispatch(fiber, error, Sync);\n  }\n\n  function computeAsyncExpiration(currentTime) {\n    // Given the current clock time, returns an expiration time. We use rounding\n    // to batch like updates together.\n    // Should complete within ~1000ms. 1200ms max.\n    var expirationMs = 5000;\n    var bucketSizeMs = 250;\n    return computeExpirationBucket(currentTime, expirationMs, bucketSizeMs);\n  }\n\n  function computeInteractiveExpiration(currentTime) {\n    // Should complete within ~500ms. 600ms max.\n    var expirationMs = 500;\n    var bucketSizeMs = 100;\n    return computeExpirationBucket(currentTime, expirationMs, bucketSizeMs);\n  }\n\n  // Creates a unique async expiration time.\n  function computeUniqueAsyncExpiration() {\n    var currentTime = recalculateCurrentTime();\n    var result = computeAsyncExpiration(currentTime);\n    if (result <= lastUniqueAsyncExpiration) {\n      // Since we assume the current time monotonically increases, we only hit\n      // this branch when computeUniqueAsyncExpiration is fired multiple times\n      // within a 200ms window (or whatever the async bucket size is).\n      result = lastUniqueAsyncExpiration + 1;\n    }\n    lastUniqueAsyncExpiration = result;\n    return lastUniqueAsyncExpiration;\n  }\n\n  function computeExpirationForFiber(fiber) {\n    var expirationTime = void 0;\n    if (expirationContext !== NoWork) {\n      // An explicit expiration context was set;\n      expirationTime = expirationContext;\n    } else if (isWorking) {\n      if (isCommitting) {\n        // Updates that occur during the commit phase should have sync priority\n        // by default.\n        expirationTime = Sync;\n      } else {\n        // Updates during the render phase should expire at the same time as\n        // the work that is being rendered.\n        expirationTime = nextRenderExpirationTime;\n      }\n    } else {\n      // No explicit expiration context was set, and we're not currently\n      // performing work. Calculate a new expiration time.\n      if (fiber.mode & AsyncMode) {\n        if (isBatchingInteractiveUpdates) {\n          // This is an interactive update\n          var currentTime = recalculateCurrentTime();\n          expirationTime = computeInteractiveExpiration(currentTime);\n        } else {\n          // This is an async update\n          var _currentTime = recalculateCurrentTime();\n          expirationTime = computeAsyncExpiration(_currentTime);\n        }\n      } else {\n        // This is a sync update\n        expirationTime = Sync;\n      }\n    }\n    if (isBatchingInteractiveUpdates) {\n      // This is an interactive update. Keep track of the lowest pending\n      // interactive expiration time. This allows us to synchronously flush\n      // all interactive updates when needed.\n      if (\n        lowestPendingInteractiveExpirationTime === NoWork ||\n        expirationTime > lowestPendingInteractiveExpirationTime\n      ) {\n        lowestPendingInteractiveExpirationTime = expirationTime;\n      }\n    }\n    return expirationTime;\n  }\n\n  function scheduleWork(fiber, expirationTime) {\n    return scheduleWorkImpl(fiber, expirationTime, false);\n  }\n\n  function scheduleWorkImpl(fiber, expirationTime, isErrorRecovery) {\n    recordScheduleUpdate();\n\n    {\n      if (!isErrorRecovery && fiber.tag === ClassComponent) {\n        var instance = fiber.stateNode;\n        warnAboutInvalidUpdates(instance);\n      }\n    }\n\n    var node = fiber;\n    while (node !== null) {\n      // Walk the parent path to the root and update each node's\n      // expiration time.\n      if (\n        node.expirationTime === NoWork ||\n        node.expirationTime > expirationTime\n      ) {\n        node.expirationTime = expirationTime;\n      }\n      if (node.alternate !== null) {\n        if (\n          node.alternate.expirationTime === NoWork ||\n          node.alternate.expirationTime > expirationTime\n        ) {\n          node.alternate.expirationTime = expirationTime;\n        }\n      }\n      if (node[\"return\"] === null) {\n        if (node.tag === HostRoot) {\n          var root = node.stateNode;\n          if (\n            !isWorking &&\n            nextRenderExpirationTime !== NoWork &&\n            expirationTime < nextRenderExpirationTime\n          ) {\n            // This is an interruption. (Used for performance tracking.)\n            interruptedBy = fiber;\n            resetContextStack();\n          }\n          if (nextRoot !== root || !isWorking) {\n            requestWork(root, expirationTime);\n          }\n          if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {\n            invariant(\n              false,\n              \"Maximum update depth exceeded. This can happen when a \" +\n                \"component repeatedly calls setState inside \" +\n                \"componentWillUpdate or componentDidUpdate. React limits \" +\n                \"the number of nested updates to prevent infinite loops.\"\n            );\n          }\n        } else {\n          {\n            if (!isErrorRecovery && fiber.tag === ClassComponent) {\n              warnAboutUpdateOnUnmounted(fiber);\n            }\n          }\n          return;\n        }\n      }\n      node = node[\"return\"];\n    }\n  }\n\n  function recalculateCurrentTime() {\n    // Subtract initial time so it fits inside 32bits\n    mostRecentCurrentTimeMs = now() - originalStartTimeMs;\n    mostRecentCurrentTime = msToExpirationTime(mostRecentCurrentTimeMs);\n    return mostRecentCurrentTime;\n  }\n\n  function deferredUpdates(fn) {\n    var previousExpirationContext = expirationContext;\n    var currentTime = recalculateCurrentTime();\n    expirationContext = computeAsyncExpiration(currentTime);\n    try {\n      return fn();\n    } finally {\n      expirationContext = previousExpirationContext;\n    }\n  }\n  function syncUpdates(fn, a, b, c, d) {\n    var previousExpirationContext = expirationContext;\n    expirationContext = Sync;\n    try {\n      return fn(a, b, c, d);\n    } finally {\n      expirationContext = previousExpirationContext;\n    }\n  }\n\n  // TODO: Everything below this is written as if it has been lifted to the\n  // renderers. I'll do this in a follow-up.\n\n  // Linked-list of roots\n  var firstScheduledRoot = null;\n  var lastScheduledRoot = null;\n\n  var callbackExpirationTime = NoWork;\n  var callbackID = -1;\n  var isRendering = false;\n  var nextFlushedRoot = null;\n  var nextFlushedExpirationTime = NoWork;\n  var lowestPendingInteractiveExpirationTime = NoWork;\n  var deadlineDidExpire = false;\n  var hasUnhandledError = false;\n  var unhandledError = null;\n  var deadline = null;\n\n  var isBatchingUpdates = false;\n  var isUnbatchingUpdates = false;\n  var isBatchingInteractiveUpdates = false;\n\n  var completedBatches = null;\n\n  // Use these to prevent an infinite loop of nested updates\n  var NESTED_UPDATE_LIMIT = 1000;\n  var nestedUpdateCount = 0;\n\n  var timeHeuristicForUnitOfWork = 1;\n\n  function scheduleCallbackWithExpiration(expirationTime) {\n    if (callbackExpirationTime !== NoWork) {\n      // A callback is already scheduled. Check its expiration time (timeout).\n      if (expirationTime > callbackExpirationTime) {\n        // Existing callback has sufficient timeout. Exit.\n        return;\n      } else {\n        // Existing callback has insufficient timeout. Cancel and schedule a\n        // new one.\n        cancelDeferredCallback(callbackID);\n      }\n      // The request callback timer is already running. Don't start a new one.\n    } else {\n      startRequestCallbackTimer();\n    }\n\n    // Compute a timeout for the given expiration time.\n    var currentMs = now() - originalStartTimeMs;\n    var expirationMs = expirationTimeToMs(expirationTime);\n    var timeout = expirationMs - currentMs;\n\n    callbackExpirationTime = expirationTime;\n    callbackID = scheduleDeferredCallback(performAsyncWork, {\n      timeout: timeout\n    });\n  }\n\n  // requestWork is called by the scheduler whenever a root receives an update.\n  // It's up to the renderer to call renderRoot at some point in the future.\n  function requestWork(root, expirationTime) {\n    addRootToSchedule(root, expirationTime);\n\n    if (isRendering) {\n      // Prevent reentrancy. Remaining work will be scheduled at the end of\n      // the currently rendering batch.\n      return;\n    }\n\n    if (isBatchingUpdates) {\n      // Flush work at the end of the batch.\n      if (isUnbatchingUpdates) {\n        // ...unless we're inside unbatchedUpdates, in which case we should\n        // flush it now.\n        nextFlushedRoot = root;\n        nextFlushedExpirationTime = Sync;\n        performWorkOnRoot(root, Sync, false);\n      }\n      return;\n    }\n\n    // TODO: Get rid of Sync and use current time?\n    if (expirationTime === Sync) {\n      performSyncWork();\n    } else {\n      scheduleCallbackWithExpiration(expirationTime);\n    }\n  }\n\n  function addRootToSchedule(root, expirationTime) {\n    // Add the root to the schedule.\n    // Check if this root is already part of the schedule.\n    if (root.nextScheduledRoot === null) {\n      // This root is not already scheduled. Add it.\n      root.remainingExpirationTime = expirationTime;\n      if (lastScheduledRoot === null) {\n        firstScheduledRoot = lastScheduledRoot = root;\n        root.nextScheduledRoot = root;\n      } else {\n        lastScheduledRoot.nextScheduledRoot = root;\n        lastScheduledRoot = root;\n        lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;\n      }\n    } else {\n      // This root is already scheduled, but its priority may have increased.\n      var remainingExpirationTime = root.remainingExpirationTime;\n      if (\n        remainingExpirationTime === NoWork ||\n        expirationTime < remainingExpirationTime\n      ) {\n        // Update the priority.\n        root.remainingExpirationTime = expirationTime;\n      }\n    }\n  }\n\n  function findHighestPriorityRoot() {\n    var highestPriorityWork = NoWork;\n    var highestPriorityRoot = null;\n    if (lastScheduledRoot !== null) {\n      var previousScheduledRoot = lastScheduledRoot;\n      var root = firstScheduledRoot;\n      while (root !== null) {\n        var remainingExpirationTime = root.remainingExpirationTime;\n        if (remainingExpirationTime === NoWork) {\n          // This root no longer has work. Remove it from the scheduler.\n\n          // TODO: This check is redudant, but Flow is confused by the branch\n          // below where we set lastScheduledRoot to null, even though we break\n          // from the loop right after.\n          invariant(\n            previousScheduledRoot !== null && lastScheduledRoot !== null,\n            \"Should have a previous and last root. This error is likely \" +\n              \"caused by a bug in React. Please file an issue.\"\n          );\n          if (root === root.nextScheduledRoot) {\n            // This is the only root in the list.\n            root.nextScheduledRoot = null;\n            firstScheduledRoot = lastScheduledRoot = null;\n            break;\n          } else if (root === firstScheduledRoot) {\n            // This is the first root in the list.\n            var next = root.nextScheduledRoot;\n            firstScheduledRoot = next;\n            lastScheduledRoot.nextScheduledRoot = next;\n            root.nextScheduledRoot = null;\n          } else if (root === lastScheduledRoot) {\n            // This is the last root in the list.\n            lastScheduledRoot = previousScheduledRoot;\n            lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;\n            root.nextScheduledRoot = null;\n            break;\n          } else {\n            previousScheduledRoot.nextScheduledRoot = root.nextScheduledRoot;\n            root.nextScheduledRoot = null;\n          }\n          root = previousScheduledRoot.nextScheduledRoot;\n        } else {\n          if (\n            highestPriorityWork === NoWork ||\n            remainingExpirationTime < highestPriorityWork\n          ) {\n            // Update the priority, if it's higher\n            highestPriorityWork = remainingExpirationTime;\n            highestPriorityRoot = root;\n          }\n          if (root === lastScheduledRoot) {\n            break;\n          }\n          previousScheduledRoot = root;\n          root = root.nextScheduledRoot;\n        }\n      }\n    }\n\n    // If the next root is the same as the previous root, this is a nested\n    // update. To prevent an infinite loop, increment the nested update count.\n    var previousFlushedRoot = nextFlushedRoot;\n    if (\n      previousFlushedRoot !== null &&\n      previousFlushedRoot === highestPriorityRoot &&\n      highestPriorityWork === Sync\n    ) {\n      nestedUpdateCount++;\n    } else {\n      // Reset whenever we switch roots.\n      nestedUpdateCount = 0;\n    }\n    nextFlushedRoot = highestPriorityRoot;\n    nextFlushedExpirationTime = highestPriorityWork;\n  }\n\n  function performAsyncWork(dl) {\n    performWork(NoWork, true, dl);\n  }\n\n  function performSyncWork() {\n    performWork(Sync, false, null);\n  }\n\n  function performWork(minExpirationTime, isAsync, dl) {\n    deadline = dl;\n\n    // Keep working on roots until there's no more work, or until the we reach\n    // the deadline.\n    findHighestPriorityRoot();\n\n    if (enableUserTimingAPI && deadline !== null) {\n      var didExpire = nextFlushedExpirationTime < recalculateCurrentTime();\n      stopRequestCallbackTimer(didExpire);\n    }\n\n    if (isAsync) {\n      while (\n        nextFlushedRoot !== null &&\n        nextFlushedExpirationTime !== NoWork &&\n        (minExpirationTime === NoWork ||\n          minExpirationTime >= nextFlushedExpirationTime) &&\n        (!deadlineDidExpire ||\n          recalculateCurrentTime() >= nextFlushedExpirationTime)\n      ) {\n        performWorkOnRoot(\n          nextFlushedRoot,\n          nextFlushedExpirationTime,\n          !deadlineDidExpire\n        );\n        findHighestPriorityRoot();\n      }\n    } else {\n      while (\n        nextFlushedRoot !== null &&\n        nextFlushedExpirationTime !== NoWork &&\n        (minExpirationTime === NoWork ||\n          minExpirationTime >= nextFlushedExpirationTime)\n      ) {\n        performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, false);\n        findHighestPriorityRoot();\n      }\n    }\n\n    // We're done flushing work. Either we ran out of time in this callback,\n    // or there's no more work left with sufficient priority.\n\n    // If we're inside a callback, set this to false since we just completed it.\n    if (deadline !== null) {\n      callbackExpirationTime = NoWork;\n      callbackID = -1;\n    }\n    // If there's work left over, schedule a new callback.\n    if (nextFlushedExpirationTime !== NoWork) {\n      scheduleCallbackWithExpiration(nextFlushedExpirationTime);\n    }\n\n    // Clean-up.\n    deadline = null;\n    deadlineDidExpire = false;\n\n    finishRendering();\n  }\n\n  function flushRoot(root, expirationTime) {\n    invariant(\n      !isRendering,\n      \"work.commit(): Cannot commit while already rendering. This likely \" +\n        \"means you attempted to commit from inside a lifecycle method.\"\n    );\n    // Perform work on root as if the given expiration time is the current time.\n    // This has the effect of synchronously flushing all work up to and\n    // including the given time.\n    performWorkOnRoot(root, expirationTime, false);\n    finishRendering();\n  }\n\n  function finishRendering() {\n    nestedUpdateCount = 0;\n\n    if (completedBatches !== null) {\n      var batches = completedBatches;\n      completedBatches = null;\n      for (var i = 0; i < batches.length; i++) {\n        var batch = batches[i];\n        try {\n          batch._onComplete();\n        } catch (error) {\n          if (!hasUnhandledError) {\n            hasUnhandledError = true;\n            unhandledError = error;\n          }\n        }\n      }\n    }\n\n    if (hasUnhandledError) {\n      var error = unhandledError;\n      unhandledError = null;\n      hasUnhandledError = false;\n      throw error;\n    }\n  }\n\n  function performWorkOnRoot(root, expirationTime, isAsync) {\n    invariant(\n      !isRendering,\n      \"performWorkOnRoot was called recursively. This error is likely caused \" +\n        \"by a bug in React. Please file an issue.\"\n    );\n\n    isRendering = true;\n\n    // Check if this is async work or sync/expired work.\n    if (!isAsync) {\n      // Flush sync work.\n      var finishedWork = root.finishedWork;\n      if (finishedWork !== null) {\n        // This root is already complete. We can commit it.\n        completeRoot(root, finishedWork, expirationTime);\n      } else {\n        root.finishedWork = null;\n        finishedWork = renderRoot(root, expirationTime, false);\n        if (finishedWork !== null) {\n          // We've completed the root. Commit it.\n          completeRoot(root, finishedWork, expirationTime);\n        }\n      }\n    } else {\n      // Flush async work.\n      var _finishedWork = root.finishedWork;\n      if (_finishedWork !== null) {\n        // This root is already complete. We can commit it.\n        completeRoot(root, _finishedWork, expirationTime);\n      } else {\n        root.finishedWork = null;\n        _finishedWork = renderRoot(root, expirationTime, true);\n        if (_finishedWork !== null) {\n          // We've completed the root. Check the deadline one more time\n          // before committing.\n          if (!shouldYield()) {\n            // Still time left. Commit the root.\n            completeRoot(root, _finishedWork, expirationTime);\n          } else {\n            // There's no time left. Mark this root as complete. We'll come\n            // back and commit it later.\n            root.finishedWork = _finishedWork;\n          }\n        }\n      }\n    }\n\n    isRendering = false;\n  }\n\n  function completeRoot(root, finishedWork, expirationTime) {\n    // Check if there's a batch that matches this expiration time.\n    var firstBatch = root.firstBatch;\n    if (firstBatch !== null && firstBatch._expirationTime <= expirationTime) {\n      if (completedBatches === null) {\n        completedBatches = [firstBatch];\n      } else {\n        completedBatches.push(firstBatch);\n      }\n      if (firstBatch._defer) {\n        // This root is blocked from committing by a batch. Unschedule it until\n        // we receive another update.\n        root.finishedWork = finishedWork;\n        root.remainingExpirationTime = NoWork;\n        return;\n      }\n    }\n\n    // Commit the root.\n    root.finishedWork = null;\n    root.remainingExpirationTime = commitRoot(finishedWork);\n  }\n\n  // When working on async work, the reconciler asks the renderer if it should\n  // yield execution. For DOM, we implement this with requestIdleCallback.\n  function shouldYield() {\n    if (deadline === null) {\n      return false;\n    }\n    if (deadline.timeRemaining() > timeHeuristicForUnitOfWork) {\n      // Disregard deadline.didTimeout. Only expired work should be flushed\n      // during a timeout. This path is only hit for non-expired work.\n      return false;\n    }\n    deadlineDidExpire = true;\n    return true;\n  }\n\n  function onUncaughtError(error) {\n    invariant(\n      nextFlushedRoot !== null,\n      \"Should be working on a root. This error is likely caused by a bug in \" +\n        \"React. Please file an issue.\"\n    );\n    // Unschedule this root so we don't work on it again until there's\n    // another update.\n    nextFlushedRoot.remainingExpirationTime = NoWork;\n    if (!hasUnhandledError) {\n      hasUnhandledError = true;\n      unhandledError = error;\n    }\n  }\n\n  // TODO: Batching should be implemented at the renderer level, not inside\n  // the reconciler.\n  function batchedUpdates(fn, a) {\n    var previousIsBatchingUpdates = isBatchingUpdates;\n    isBatchingUpdates = true;\n    try {\n      return fn(a);\n    } finally {\n      isBatchingUpdates = previousIsBatchingUpdates;\n      if (!isBatchingUpdates && !isRendering) {\n        performSyncWork();\n      }\n    }\n  }\n\n  // TODO: Batching should be implemented at the renderer level, not inside\n  // the reconciler.\n  function unbatchedUpdates(fn, a) {\n    if (isBatchingUpdates && !isUnbatchingUpdates) {\n      isUnbatchingUpdates = true;\n      try {\n        return fn(a);\n      } finally {\n        isUnbatchingUpdates = false;\n      }\n    }\n    return fn(a);\n  }\n\n  // TODO: Batching should be implemented at the renderer level, not within\n  // the reconciler.\n  function flushSync(fn, a) {\n    invariant(\n      !isRendering,\n      \"flushSync was called from inside a lifecycle method. It cannot be \" +\n        \"called when React is already rendering.\"\n    );\n    var previousIsBatchingUpdates = isBatchingUpdates;\n    isBatchingUpdates = true;\n    try {\n      return syncUpdates(fn, a);\n    } finally {\n      isBatchingUpdates = previousIsBatchingUpdates;\n      performSyncWork();\n    }\n  }\n\n  function interactiveUpdates(fn, a, b) {\n    if (isBatchingInteractiveUpdates) {\n      return fn(a, b);\n    }\n    // If there are any pending interactive updates, synchronously flush them.\n    // This needs to happen before we read any handlers, because the effect of\n    // the previous event may influence which handlers are called during\n    // this event.\n    if (\n      !isBatchingUpdates &&\n      !isRendering &&\n      lowestPendingInteractiveExpirationTime !== NoWork\n    ) {\n      // Synchronously flush pending interactive updates.\n      performWork(lowestPendingInteractiveExpirationTime, false, null);\n      lowestPendingInteractiveExpirationTime = NoWork;\n    }\n    var previousIsBatchingInteractiveUpdates = isBatchingInteractiveUpdates;\n    var previousIsBatchingUpdates = isBatchingUpdates;\n    isBatchingInteractiveUpdates = true;\n    isBatchingUpdates = true;\n    try {\n      return fn(a, b);\n    } finally {\n      isBatchingInteractiveUpdates = previousIsBatchingInteractiveUpdates;\n      isBatchingUpdates = previousIsBatchingUpdates;\n      if (!isBatchingUpdates && !isRendering) {\n        performSyncWork();\n      }\n    }\n  }\n\n  function flushInteractiveUpdates() {\n    if (!isRendering && lowestPendingInteractiveExpirationTime !== NoWork) {\n      // Synchronously flush pending interactive updates.\n      performWork(lowestPendingInteractiveExpirationTime, false, null);\n      lowestPendingInteractiveExpirationTime = NoWork;\n    }\n  }\n\n  function flushControlled(fn) {\n    var previousIsBatchingUpdates = isBatchingUpdates;\n    isBatchingUpdates = true;\n    try {\n      syncUpdates(fn);\n    } finally {\n      isBatchingUpdates = previousIsBatchingUpdates;\n      if (!isBatchingUpdates && !isRendering) {\n        performWork(Sync, false, null);\n      }\n    }\n  }\n\n  return {\n    recalculateCurrentTime: recalculateCurrentTime,\n    computeExpirationForFiber: computeExpirationForFiber,\n    scheduleWork: scheduleWork,\n    requestWork: requestWork,\n    flushRoot: flushRoot,\n    batchedUpdates: batchedUpdates,\n    unbatchedUpdates: unbatchedUpdates,\n    flushSync: flushSync,\n    flushControlled: flushControlled,\n    deferredUpdates: deferredUpdates,\n    syncUpdates: syncUpdates,\n    interactiveUpdates: interactiveUpdates,\n    flushInteractiveUpdates: flushInteractiveUpdates,\n    computeUniqueAsyncExpiration: computeUniqueAsyncExpiration\n  };\n};\n\nvar didWarnAboutNestedUpdates = void 0;\n\n{\n  didWarnAboutNestedUpdates = false;\n}\n\n// 0 is PROD, 1 is DEV.\n// Might add PROFILE later.\n\nfunction getContextForSubtree(parentComponent) {\n  if (!parentComponent) {\n    return emptyObject;\n  }\n\n  var fiber = get(parentComponent);\n  var parentContext = findCurrentUnmaskedContext(fiber);\n  return isContextProvider(fiber)\n    ? processChildContext(fiber, parentContext)\n    : parentContext;\n}\n\nvar ReactFiberReconciler$1 = function(config) {\n  var getPublicInstance = config.getPublicInstance;\n\n  var _ReactFiberScheduler = ReactFiberScheduler(config),\n    computeUniqueAsyncExpiration =\n      _ReactFiberScheduler.computeUniqueAsyncExpiration,\n    recalculateCurrentTime = _ReactFiberScheduler.recalculateCurrentTime,\n    computeExpirationForFiber = _ReactFiberScheduler.computeExpirationForFiber,\n    scheduleWork = _ReactFiberScheduler.scheduleWork,\n    requestWork = _ReactFiberScheduler.requestWork,\n    flushRoot = _ReactFiberScheduler.flushRoot,\n    batchedUpdates = _ReactFiberScheduler.batchedUpdates,\n    unbatchedUpdates = _ReactFiberScheduler.unbatchedUpdates,\n    flushSync = _ReactFiberScheduler.flushSync,\n    flushControlled = _ReactFiberScheduler.flushControlled,\n    deferredUpdates = _ReactFiberScheduler.deferredUpdates,\n    syncUpdates = _ReactFiberScheduler.syncUpdates,\n    interactiveUpdates = _ReactFiberScheduler.interactiveUpdates,\n    flushInteractiveUpdates = _ReactFiberScheduler.flushInteractiveUpdates;\n\n  function scheduleRootUpdate(\n    current,\n    element,\n    currentTime,\n    expirationTime,\n    callback\n  ) {\n    {\n      if (\n        ReactDebugCurrentFiber.phase === \"render\" &&\n        ReactDebugCurrentFiber.current !== null &&\n        !didWarnAboutNestedUpdates\n      ) {\n        didWarnAboutNestedUpdates = true;\n        warning(\n          false,\n          \"Render methods should be a pure function of props and state; \" +\n            \"triggering nested component updates from render is not allowed. \" +\n            \"If necessary, trigger nested updates in componentDidUpdate.\\n\\n\" +\n            \"Check the render method of %s.\",\n          getComponentName(ReactDebugCurrentFiber.current) || \"Unknown\"\n        );\n      }\n    }\n\n    callback = callback === undefined ? null : callback;\n    {\n      warning(\n        callback === null || typeof callback === \"function\",\n        \"render(...): Expected the last optional `callback` argument to be a \" +\n          \"function. Instead received: %s.\",\n        callback\n      );\n    }\n\n    var update = {\n      expirationTime: expirationTime,\n      partialState: { element: element },\n      callback: callback,\n      isReplace: false,\n      isForced: false,\n      capturedValue: null,\n      next: null\n    };\n    insertUpdateIntoFiber(current, update);\n    scheduleWork(current, expirationTime);\n\n    return expirationTime;\n  }\n\n  function updateContainerAtExpirationTime(\n    element,\n    container,\n    parentComponent,\n    currentTime,\n    expirationTime,\n    callback\n  ) {\n    // TODO: If this is a nested container, this won't be the root.\n    var current = container.current;\n\n    {\n      if (ReactFiberInstrumentation_1.debugTool) {\n        if (current.alternate === null) {\n          ReactFiberInstrumentation_1.debugTool.onMountContainer(container);\n        } else if (element === null) {\n          ReactFiberInstrumentation_1.debugTool.onUnmountContainer(container);\n        } else {\n          ReactFiberInstrumentation_1.debugTool.onUpdateContainer(container);\n        }\n      }\n    }\n\n    var context = getContextForSubtree(parentComponent);\n    if (container.context === null) {\n      container.context = context;\n    } else {\n      container.pendingContext = context;\n    }\n\n    return scheduleRootUpdate(\n      current,\n      element,\n      currentTime,\n      expirationTime,\n      callback\n    );\n  }\n\n  function findHostInstance(fiber) {\n    var hostFiber = findCurrentHostFiber(fiber);\n    if (hostFiber === null) {\n      return null;\n    }\n    return hostFiber.stateNode;\n  }\n\n  return {\n    createContainer: function(containerInfo, isAsync, hydrate) {\n      return createFiberRoot(containerInfo, isAsync, hydrate);\n    },\n    updateContainer: function(element, container, parentComponent, callback) {\n      var current = container.current;\n      var currentTime = recalculateCurrentTime();\n      var expirationTime = computeExpirationForFiber(current);\n      return updateContainerAtExpirationTime(\n        element,\n        container,\n        parentComponent,\n        currentTime,\n        expirationTime,\n        callback\n      );\n    },\n    updateContainerAtExpirationTime: function(\n      element,\n      container,\n      parentComponent,\n      expirationTime,\n      callback\n    ) {\n      var currentTime = recalculateCurrentTime();\n      return updateContainerAtExpirationTime(\n        element,\n        container,\n        parentComponent,\n        currentTime,\n        expirationTime,\n        callback\n      );\n    },\n\n    flushRoot: flushRoot,\n\n    requestWork: requestWork,\n\n    computeUniqueAsyncExpiration: computeUniqueAsyncExpiration,\n\n    batchedUpdates: batchedUpdates,\n\n    unbatchedUpdates: unbatchedUpdates,\n\n    deferredUpdates: deferredUpdates,\n\n    syncUpdates: syncUpdates,\n\n    interactiveUpdates: interactiveUpdates,\n\n    flushInteractiveUpdates: flushInteractiveUpdates,\n\n    flushControlled: flushControlled,\n\n    flushSync: flushSync,\n\n    getPublicRootInstance: function(container) {\n      var containerFiber = container.current;\n      if (!containerFiber.child) {\n        return null;\n      }\n      switch (containerFiber.child.tag) {\n        case HostComponent:\n          return getPublicInstance(containerFiber.child.stateNode);\n        default:\n          return containerFiber.child.stateNode;\n      }\n    },\n\n    findHostInstance: findHostInstance,\n\n    findHostInstanceWithNoPortals: function(fiber) {\n      var hostFiber = findCurrentHostFiberWithNoPortals(fiber);\n      if (hostFiber === null) {\n        return null;\n      }\n      return hostFiber.stateNode;\n    },\n    injectIntoDevTools: function(devToolsConfig) {\n      var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;\n\n      return injectInternals(\n        Object.assign({}, devToolsConfig, {\n          findHostInstanceByFiber: function(fiber) {\n            return findHostInstance(fiber);\n          },\n          findFiberByHostInstance: function(instance) {\n            if (!findFiberByHostInstance) {\n              // Might not be implemented by the renderer.\n              return null;\n            }\n            return findFiberByHostInstance(instance);\n          }\n        })\n      );\n    }\n  };\n};\n\nvar ReactFiberReconciler$2 = Object.freeze({\n  default: ReactFiberReconciler$1\n});\n\nvar ReactFiberReconciler$3 =\n  (ReactFiberReconciler$2 && ReactFiberReconciler$1) || ReactFiberReconciler$2;\n\n// TODO: bundle Flow types with the package.\n\n// TODO: decide on the top-level export form.\n// This is hacky but makes it work with both Rollup and Jest.\nvar reactReconciler = ReactFiberReconciler$3[\"default\"]\n  ? ReactFiberReconciler$3[\"default\"]\n  : ReactFiberReconciler$3;\n\nvar viewConfigCallbacks = new Map();\nvar viewConfigs = new Map();\n\n/**\n * Registers a native view/component by name.\n * A callback is provided to load the view config from UIManager.\n * The callback is deferred until the view is actually rendered.\n * This is done to avoid causing Prepack deopts.\n */\nfunction register(name, callback) {\n  invariant(\n    !viewConfigCallbacks.has(name),\n    \"Tried to register two views with the same name %s\",\n    name\n  );\n  viewConfigCallbacks.set(name, callback);\n  return name;\n}\n\n/**\n * Retrieves a config for the specified view.\n * If this is the first time the view has been used,\n * This configuration will be lazy-loaded from UIManager.\n */\nfunction get$1(name) {\n  var viewConfig = void 0;\n  if (!viewConfigs.has(name)) {\n    var callback = viewConfigCallbacks.get(name);\n    invariant(\n      typeof callback === \"function\",\n      \"View config not found for name %s\",\n      name\n    );\n    viewConfigCallbacks.set(name, null);\n    viewConfig = callback();\n    viewConfigs.set(name, viewConfig);\n  } else {\n    viewConfig = viewConfigs.get(name);\n  }\n  invariant(viewConfig, \"View config not found for name %s\", name);\n  return viewConfig;\n}\n\nfunction _classCallCheck$2(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\n// Modules provided by RN:\n/**\n * This component defines the same methods as NativeMethodsMixin but without the\n * findNodeHandle wrapper. This wrapper is unnecessary for HostComponent views\n * and would also result in a circular require.js dependency (since\n * ReactNativeFiber depends on this component and NativeMethodsMixin depends on\n * ReactNativeFiber).\n */\n\nvar ReactNativeFiberHostComponent = (function() {\n  function ReactNativeFiberHostComponent(tag, viewConfig) {\n    _classCallCheck$2(this, ReactNativeFiberHostComponent);\n\n    this._nativeTag = tag;\n    this._children = [];\n    this.viewConfig = viewConfig;\n  }\n\n  ReactNativeFiberHostComponent.prototype.blur = function blur() {\n    TextInputState.blurTextInput(this._nativeTag);\n  };\n\n  ReactNativeFiberHostComponent.prototype.focus = function focus() {\n    TextInputState.focusTextInput(this._nativeTag);\n  };\n\n  ReactNativeFiberHostComponent.prototype.measure = function measure(callback) {\n    UIManager.measure(this._nativeTag, mountSafeCallback(this, callback));\n  };\n\n  ReactNativeFiberHostComponent.prototype.measureInWindow = function measureInWindow(\n    callback\n  ) {\n    UIManager.measureInWindow(\n      this._nativeTag,\n      mountSafeCallback(this, callback)\n    );\n  };\n\n  ReactNativeFiberHostComponent.prototype.measureLayout = function measureLayout(\n    relativeToNativeNode,\n    onSuccess,\n    onFail /* currently unused */\n  ) {\n    UIManager.measureLayout(\n      this._nativeTag,\n      relativeToNativeNode,\n      mountSafeCallback(this, onFail),\n      mountSafeCallback(this, onSuccess)\n    );\n  };\n\n  ReactNativeFiberHostComponent.prototype.setNativeProps = function setNativeProps(\n    nativeProps\n  ) {\n    {\n      warnForStyleProps(nativeProps, this.viewConfig.validAttributes);\n    }\n\n    var updatePayload = create(nativeProps, this.viewConfig.validAttributes);\n\n    // Avoid the overhead of bridge calls if there's no update.\n    // This is an expensive no-op for Android, and causes an unnecessary\n    // view invalidation for certain components (eg RCTTextInput) on iOS.\n    if (updatePayload != null) {\n      UIManager.updateView(\n        this._nativeTag,\n        this.viewConfig.uiViewClassName,\n        updatePayload\n      );\n    }\n  };\n\n  return ReactNativeFiberHostComponent;\n})();\n\nvar hasNativePerformanceNow =\n  typeof performance === \"object\" && typeof performance.now === \"function\";\n\nvar now = hasNativePerformanceNow\n  ? function() {\n      return performance.now();\n    }\n  : function() {\n      return Date.now();\n    };\n\nvar scheduledCallback = null;\nvar frameDeadline = 0;\n\nvar frameDeadlineObject = {\n  timeRemaining: function() {\n    return frameDeadline - now();\n  }\n};\n\nfunction setTimeoutCallback() {\n  // TODO (bvaughn) Hard-coded 5ms unblocks initial async testing.\n  // React API probably changing to boolean rather than time remaining.\n  // Longer-term plan is to rewrite this using shared memory,\n  // And just return the value of the bit as the boolean.\n  frameDeadline = now() + 5;\n\n  var callback = scheduledCallback;\n  scheduledCallback = null;\n  if (callback !== null) {\n    callback(frameDeadlineObject);\n  }\n}\n\n// RN has a poor polyfill for requestIdleCallback so we aren't using it.\n// This implementation is only intended for short-term use anyway.\n// We also don't implement cancel functionality b'c Fiber doesn't currently need it.\nfunction scheduleDeferredCallback(callback) {\n  // We assume only one callback is scheduled at a time b'c that's how Fiber works.\n  scheduledCallback = callback;\n  return setTimeout(setTimeoutCallback, 1);\n}\n\nfunction cancelDeferredCallback(callbackID) {\n  scheduledCallback = null;\n  clearTimeout(callbackID);\n}\n\n// Modules provided by RN:\nfunction recursivelyUncacheFiberNode(node) {\n  if (typeof node === \"number\") {\n    // Leaf node (eg text)\n    uncacheFiberNode(node);\n  } else {\n    uncacheFiberNode(node._nativeTag);\n\n    node._children.forEach(recursivelyUncacheFiberNode);\n  }\n}\n\nvar NativeRenderer = reactReconciler({\n  appendInitialChild: function(parentInstance, child) {\n    parentInstance._children.push(child);\n  },\n  createInstance: function(\n    type,\n    props,\n    rootContainerInstance,\n    hostContext,\n    internalInstanceHandle\n  ) {\n    var tag = ReactNativeTagHandles.allocateTag();\n    var viewConfig = get$1(type);\n\n    {\n      for (var key in viewConfig.validAttributes) {\n        if (props.hasOwnProperty(key)) {\n          deepFreezeAndThrowOnMutationInDev(props[key]);\n        }\n      }\n    }\n\n    var updatePayload = create(props, viewConfig.validAttributes);\n\n    UIManager.createView(\n      tag, // reactTag\n      viewConfig.uiViewClassName, // viewName\n      rootContainerInstance, // rootTag\n      updatePayload\n    );\n\n    var component = new ReactNativeFiberHostComponent(tag, viewConfig);\n\n    precacheFiberNode(internalInstanceHandle, tag);\n    updateFiberProps(tag, props);\n\n    // Not sure how to avoid this cast. Flow is okay if the component is defined\n    // in the same file but if it's external it can't see the types.\n    return component;\n  },\n  createTextInstance: function(\n    text,\n    rootContainerInstance,\n    hostContext,\n    internalInstanceHandle\n  ) {\n    var tag = ReactNativeTagHandles.allocateTag();\n\n    UIManager.createView(\n      tag, // reactTag\n      \"RCTRawText\", // viewName\n      rootContainerInstance, // rootTag\n      { text: text }\n    );\n\n    precacheFiberNode(internalInstanceHandle, tag);\n\n    return tag;\n  },\n  finalizeInitialChildren: function(\n    parentInstance,\n    type,\n    props,\n    rootContainerInstance\n  ) {\n    // Don't send a no-op message over the bridge.\n    if (parentInstance._children.length === 0) {\n      return false;\n    }\n\n    // Map from child objects to native tags.\n    // Either way we need to pass a copy of the Array to prevent it from being frozen.\n    var nativeTags = parentInstance._children.map(function(child) {\n      return typeof child === \"number\"\n        ? child // Leaf node (eg text)\n        : child._nativeTag;\n    });\n\n    UIManager.setChildren(\n      parentInstance._nativeTag, // containerTag\n      nativeTags\n    );\n\n    return false;\n  },\n  getRootHostContext: function() {\n    return emptyObject;\n  },\n  getChildHostContext: function() {\n    return emptyObject;\n  },\n  getPublicInstance: function(instance) {\n    return instance;\n  },\n\n  now: now,\n\n  prepareForCommit: function() {\n    // Noop\n  },\n  prepareUpdate: function(\n    instance,\n    type,\n    oldProps,\n    newProps,\n    rootContainerInstance,\n    hostContext\n  ) {\n    return emptyObject;\n  },\n  resetAfterCommit: function() {\n    // Noop\n  },\n\n  scheduleDeferredCallback: scheduleDeferredCallback,\n  cancelDeferredCallback: cancelDeferredCallback,\n\n  shouldDeprioritizeSubtree: function(type, props) {\n    return false;\n  },\n  shouldSetTextContent: function(type, props) {\n    // TODO (bvaughn) Revisit this decision.\n    // Always returning false simplifies the createInstance() implementation,\n    // But creates an additional child Fiber for raw text children.\n    // No additional native views are created though.\n    // It's not clear to me which is better so I'm deferring for now.\n    // More context @ github.com/facebook/react/pull/8560#discussion_r92111303\n    return false;\n  },\n\n  mutation: {\n    appendChild: function(parentInstance, child) {\n      var childTag = typeof child === \"number\" ? child : child._nativeTag;\n      var children = parentInstance._children;\n      var index = children.indexOf(child);\n\n      if (index >= 0) {\n        children.splice(index, 1);\n        children.push(child);\n\n        UIManager.manageChildren(\n          parentInstance._nativeTag, // containerTag\n          [index], // moveFromIndices\n          [children.length - 1], // moveToIndices\n          [], // addChildReactTags\n          [], // addAtIndices\n          []\n        );\n      } else {\n        children.push(child);\n\n        UIManager.manageChildren(\n          parentInstance._nativeTag, // containerTag\n          [], // moveFromIndices\n          [], // moveToIndices\n          [childTag], // addChildReactTags\n          [children.length - 1], // addAtIndices\n          []\n        );\n      }\n    },\n    appendChildToContainer: function(parentInstance, child) {\n      var childTag = typeof child === \"number\" ? child : child._nativeTag;\n      UIManager.setChildren(\n        parentInstance, // containerTag\n        [childTag]\n      );\n    },\n    commitTextUpdate: function(textInstance, oldText, newText) {\n      UIManager.updateView(\n        textInstance, // reactTag\n        \"RCTRawText\", // viewName\n        { text: newText }\n      );\n    },\n    commitMount: function(instance, type, newProps, internalInstanceHandle) {\n      // Noop\n    },\n    commitUpdate: function(\n      instance,\n      updatePayloadTODO,\n      type,\n      oldProps,\n      newProps,\n      internalInstanceHandle\n    ) {\n      var viewConfig = instance.viewConfig;\n\n      updateFiberProps(instance._nativeTag, newProps);\n\n      var updatePayload = diff(oldProps, newProps, viewConfig.validAttributes);\n\n      // Avoid the overhead of bridge calls if there's no update.\n      // This is an expensive no-op for Android, and causes an unnecessary\n      // view invalidation for certain components (eg RCTTextInput) on iOS.\n      if (updatePayload != null) {\n        UIManager.updateView(\n          instance._nativeTag, // reactTag\n          viewConfig.uiViewClassName, // viewName\n          updatePayload\n        );\n      }\n    },\n    insertBefore: function(parentInstance, child, beforeChild) {\n      var children = parentInstance._children;\n      var index = children.indexOf(child);\n\n      // Move existing child or add new child?\n      if (index >= 0) {\n        children.splice(index, 1);\n        var beforeChildIndex = children.indexOf(beforeChild);\n        children.splice(beforeChildIndex, 0, child);\n\n        UIManager.manageChildren(\n          parentInstance._nativeTag, // containerID\n          [index], // moveFromIndices\n          [beforeChildIndex], // moveToIndices\n          [], // addChildReactTags\n          [], // addAtIndices\n          []\n        );\n      } else {\n        var _beforeChildIndex = children.indexOf(beforeChild);\n        children.splice(_beforeChildIndex, 0, child);\n\n        var childTag = typeof child === \"number\" ? child : child._nativeTag;\n\n        UIManager.manageChildren(\n          parentInstance._nativeTag, // containerID\n          [], // moveFromIndices\n          [], // moveToIndices\n          [childTag], // addChildReactTags\n          [_beforeChildIndex], // addAtIndices\n          []\n        );\n      }\n    },\n    insertInContainerBefore: function(parentInstance, child, beforeChild) {\n      // TODO (bvaughn): Remove this check when...\n      // We create a wrapper object for the container in ReactNative render()\n      // Or we refactor to remove wrapper objects entirely.\n      // For more info on pros/cons see PR #8560 description.\n      invariant(\n        typeof parentInstance !== \"number\",\n        \"Container does not support insertBefore operation\"\n      );\n    },\n    removeChild: function(parentInstance, child) {\n      recursivelyUncacheFiberNode(child);\n      var children = parentInstance._children;\n      var index = children.indexOf(child);\n\n      children.splice(index, 1);\n\n      UIManager.manageChildren(\n        parentInstance._nativeTag, // containerID\n        [], // moveFromIndices\n        [], // moveToIndices\n        [], // addChildReactTags\n        [], // addAtIndices\n        [index]\n      );\n    },\n    removeChildFromContainer: function(parentInstance, child) {\n      recursivelyUncacheFiberNode(child);\n      UIManager.manageChildren(\n        parentInstance, // containerID\n        [], // moveFromIndices\n        [], // moveToIndices\n        [], // addChildReactTags\n        [], // addAtIndices\n        [0]\n      );\n    },\n    resetTextContent: function(instance) {\n      // Noop\n    }\n  }\n});\n\n// Module provided by RN:\nvar getInspectorDataForViewTag = void 0;\n\n{\n  var traverseOwnerTreeUp = function(hierarchy, instance) {\n    if (instance) {\n      hierarchy.unshift(instance);\n      traverseOwnerTreeUp(hierarchy, instance._debugOwner);\n    }\n  };\n\n  var getOwnerHierarchy = function(instance) {\n    var hierarchy = [];\n    traverseOwnerTreeUp(hierarchy, instance);\n    return hierarchy;\n  };\n\n  var lastNonHostInstance = function(hierarchy) {\n    for (var i = hierarchy.length - 1; i > 1; i--) {\n      var instance = hierarchy[i];\n\n      if (instance.tag !== HostComponent) {\n        return instance;\n      }\n    }\n    return hierarchy[0];\n  };\n\n  var getHostProps = function(fiber) {\n    var host = findCurrentHostFiber(fiber);\n    if (host) {\n      return host.memoizedProps || emptyObject;\n    }\n    return emptyObject;\n  };\n\n  var getHostNode = function(fiber, findNodeHandle) {\n    var hostNode = void 0;\n    // look for children first for the hostNode\n    // as composite fibers do not have a hostNode\n    while (fiber) {\n      if (fiber.stateNode !== null && fiber.tag === HostComponent) {\n        hostNode = findNodeHandle(fiber.stateNode);\n      }\n      if (hostNode) {\n        return hostNode;\n      }\n      fiber = fiber.child;\n    }\n    return null;\n  };\n\n  var createHierarchy = function(fiberHierarchy) {\n    return fiberHierarchy.map(function(fiber) {\n      return {\n        name: getComponentName(fiber),\n        getInspectorData: function(findNodeHandle) {\n          return {\n            measure: function(callback) {\n              return UIManager.measure(\n                getHostNode(fiber, findNodeHandle),\n                callback\n              );\n            },\n            props: getHostProps(fiber),\n            source: fiber._debugSource\n          };\n        }\n      };\n    });\n  };\n\n  getInspectorDataForViewTag = function(viewTag) {\n    var closestInstance = getInstanceFromTag(viewTag);\n\n    // Handle case where user clicks outside of ReactNative\n    if (!closestInstance) {\n      return {\n        hierarchy: [],\n        props: emptyObject,\n        selection: null,\n        source: null\n      };\n    }\n\n    var fiber = findCurrentFiberUsingSlowPath(closestInstance);\n    var fiberHierarchy = getOwnerHierarchy(fiber);\n    var instance = lastNonHostInstance(fiberHierarchy);\n    var hierarchy = createHierarchy(fiberHierarchy);\n    var props = getHostProps(instance);\n    var source = instance._debugSource;\n    var selection = fiberHierarchy.indexOf(instance);\n\n    return {\n      hierarchy: hierarchy,\n      props: props,\n      selection: selection,\n      source: source\n    };\n  };\n}\n\n/**\n * Creates a renderable ReactNative host component.\n * Use this method for view configs that are loaded from UIManager.\n * Use createReactNativeComponentClass() for view configs defined within JavaScript.\n *\n * @param {string} config iOS View configuration.\n * @private\n */\nvar createReactNativeComponentClass = function(name, callback) {\n  return register(name, callback);\n};\n\n// Module provided by RN:\n/**\n * Capture an image of the screen, window or an individual view. The image\n * will be stored in a temporary file that will only exist for as long as the\n * app is running.\n *\n * The `view` argument can be the literal string `window` if you want to\n * capture the entire window, or it can be a reference to a specific\n * React Native component.\n *\n * The `options` argument may include:\n * - width/height (number) - the width and height of the image to capture.\n * - format (string) - either 'png' or 'jpeg'. Defaults to 'png'.\n * - quality (number) - the quality when using jpeg. 0.0 - 1.0 (default).\n *\n * Returns a Promise.\n * @platform ios\n */\nfunction takeSnapshot(view, options) {\n  if (typeof view !== \"number\" && view !== \"window\") {\n    view = findNumericNodeHandleFiber(view) || \"window\";\n  }\n\n  // Call the hidden '__takeSnapshot' method; the main one throws an error to\n  // prevent accidental backwards-incompatible usage.\n  return UIManager.__takeSnapshot(view, options);\n}\n\n// Module provided by RN:\ninjectFindHostInstance(NativeRenderer.findHostInstance);\n\ninjection$2.injectRenderer(NativeRenderer);\n\nvar roots = new Map();\n\nvar ReactNativeRenderer = {\n  NativeComponent: ReactNativeComponent,\n\n  findNodeHandle: findNumericNodeHandleFiber,\n\n  render: function(element, containerTag, callback) {\n    var root = roots.get(containerTag);\n\n    if (!root) {\n      // TODO (bvaughn): If we decide to keep the wrapper component,\n      // We could create a wrapper for containerTag as well to reduce special casing.\n      root = NativeRenderer.createContainer(containerTag, false, false);\n      roots.set(containerTag, root);\n    }\n    NativeRenderer.updateContainer(element, root, null, callback);\n\n    return NativeRenderer.getPublicRootInstance(root);\n  },\n  unmountComponentAtNode: function(containerTag) {\n    var root = roots.get(containerTag);\n    if (root) {\n      // TODO: Is it safe to reset this now or should I wait since this unmount could be deferred?\n      NativeRenderer.updateContainer(null, root, null, function() {\n        roots[\"delete\"](containerTag);\n      });\n    }\n  },\n  unmountComponentAtNodeAndRemoveContainer: function(containerTag) {\n    ReactNativeRenderer.unmountComponentAtNode(containerTag);\n\n    // Call back into native to remove all of the subviews from this container\n    UIManager.removeRootView(containerTag);\n  },\n  createPortal: function(children, containerTag) {\n    var key =\n      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n    return createPortal(children, containerTag, null, key);\n  },\n\n  unstable_batchedUpdates: batchedUpdates,\n\n  flushSync: NativeRenderer.flushSync,\n\n  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {\n    // Used as a mixin in many createClass-based components\n    NativeMethodsMixin: NativeMethodsMixin,\n    // Used by react-native-github/Libraries/ components\n    ReactNativeBridgeEventPlugin: ReactNativeBridgeEventPlugin, // requireNativeComponent\n    ReactNativeComponentTree: ReactNativeComponentTree, // ScrollResponder\n    ReactNativePropRegistry: ReactNativePropRegistry, // flattenStyle, Stylesheet\n    TouchHistoryMath: TouchHistoryMath, // PanResponder\n    createReactNativeComponentClass: createReactNativeComponentClass, // RCTText, RCTView, ReactNativeART\n    takeSnapshot: takeSnapshot\n  }\n};\n\n{\n  // $FlowFixMe\n  Object.assign(\n    ReactNativeRenderer.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,\n    {\n      // TODO: none of these work since Fiber. Remove these dependencies.\n      // Used by RCTRenderingPerf, Systrace:\n      ReactDebugTool: {\n        addHook: function() {},\n        removeHook: function() {}\n      },\n      // Used by ReactPerfStallHandler, RCTRenderingPerf:\n      ReactPerf: {\n        start: function() {},\n        stop: function() {},\n        printInclusive: function() {},\n        printWasted: function() {}\n      }\n    }\n  );\n}\n\nNativeRenderer.injectIntoDevTools({\n  findFiberByHostInstance: getInstanceFromTag,\n  getInspectorDataForViewTag: getInspectorDataForViewTag,\n  bundleType: 1,\n  version: ReactVersion,\n  rendererPackageName: \"react-native-renderer\"\n});\n\nvar ReactNativeRenderer$2 = Object.freeze({\n  default: ReactNativeRenderer\n});\n\nvar ReactNativeRenderer$3 =\n  (ReactNativeRenderer$2 && ReactNativeRenderer) || ReactNativeRenderer$2;\n\n// TODO: decide on the top-level export form.\n// This is hacky but makes it work with both Rollup and Jest.\nvar reactNativeRenderer = ReactNativeRenderer$3[\"default\"]\n  ? ReactNativeRenderer$3[\"default\"]\n  : ReactNativeRenderer$3;\n\nmodule.exports = reactNativeRenderer;\n\n  })();\n}\n"]}